diff --git a/libgloss/config/default.mh b/libgloss/config/default.mh
index 64dc02f05..dc36ea95f 100644
--- a/libgloss/config/default.mh
+++ b/libgloss/config/default.mh
@@ -4,7 +4,7 @@ NEWLIB_LDFLAGS = `if [ -d ${objroot}/newlib ]; then echo -B${objroot}/newlib/ -L
 INCLUDES = -I. -I$(srcdir)/.. -I$(objdir)/.. -idirafter $(srcroot)/include
 # Note that when building the library, ${MULTILIB} is not the way multilib
 # options are passed; they're passed in $(CFLAGS).
-CFLAGS_FOR_TARGET = -O2 -g ${MULTILIB} ${INCLUDES} ${NEWLIB_CFLAGS}
+CFLAGS_FOR_TARGET = -O2 -g ${MULTILIB} ${INCLUDES} ${NEWLIB_CFLAGS}  -fpermissive
 LDFLAGS_FOR_TARGET = ${MULTILIB} ${NEWLIB_LDFLAGS}
 AR_FLAGS = rc
 
diff --git a/libgloss/glue.h b/libgloss/glue.h
index 0a7e36db2..98c0a6ad2 100644
--- a/libgloss/glue.h
+++ b/libgloss/glue.h
@@ -13,6 +13,7 @@
  * they apply.
  */
 #include <_ansi.h>
+#include <unistd.h>
 
 #ifndef NULL
 #  define NULL 0
@@ -28,4 +29,5 @@ extern char _end[];                /* _end is set in the linker command file */
 /* only one prcess support, as this is OS dependant */
 #define __MYPID 1
 
+int outbyte (char);
 
diff --git a/libgloss/m32r/m32r-stub.c b/libgloss/m32r/m32r-stub.c
index 4d54f72d6..0b15d2e18 100644
--- a/libgloss/m32r/m32r-stub.c
+++ b/libgloss/m32r/m32r-stub.c
@@ -160,6 +160,8 @@ static int *stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];
 
 static unsigned int save_vectors[18];	/* previous exception vectors */
 
+extern unsigned int getExceptionHandler (int);
+
 /* Indicate to caller of mem2hex or hex2mem that there has been an error. */
 static volatile int mem_err = 0;
 
@@ -198,8 +200,8 @@ static unsigned long crc32 (unsigned char *, int, unsigned long);
 static void gdb_error (char *, char *);
 static int gdb_putchar (int), gdb_puts (char *), gdb_write (char *, int);
 
-static unsigned char *strcpy (unsigned char *, const unsigned char *);
-static int strlen (const unsigned char *);
+static unsigned char *my_strcpy (unsigned char *, const unsigned char *);
+static int my_strlen (const unsigned char *);
 
 /*
  * This function does all command procesing for interfacing to gdb.
@@ -326,10 +328,10 @@ handle_exception (int exceptionVector)
 	case 'R':
 	  if (hexToInt (&ptr, &addr))
 	    registers[PC] = addr;
-	  strcpy (remcomOutBuffer, "OK");
+	  my_strcpy (remcomOutBuffer, "OK");
 	  break;
 	case '!':
-	  strcpy (remcomOutBuffer, "OK");
+	  my_strcpy (remcomOutBuffer, "OK");
 	  break;
 	case 'X':		/* XAA..AA,LLLL:<binary data>#cs */
 	  binary = 1;
@@ -348,18 +350,18 @@ handle_exception (int exceptionVector)
 			hex2mem (ptr, (unsigned char *) addr, length, 1);
 		      if (mem_err)
 			{
-			  strcpy (remcomOutBuffer, "E03");
+			  my_strcpy (remcomOutBuffer, "E03");
 			  gdb_error ("memory fault", "");
 			}
 		      else
 			{
-			  strcpy (remcomOutBuffer, "OK");
+			  my_strcpy (remcomOutBuffer, "OK");
 			}
 		      ptr = 0;
 		    }
 	    if (ptr)
 	      {
-		strcpy (remcomOutBuffer, "E02");
+		my_strcpy (remcomOutBuffer, "E02");
 	      }
 	  }
 	  break;
@@ -375,13 +377,13 @@ handle_exception (int exceptionVector)
 			   1);
 		  if (mem_err)
 		    {
-		      strcpy (remcomOutBuffer, "E03");
+		      my_strcpy (remcomOutBuffer, "E03");
 		      gdb_error ("memory fault", "");
 		    }
 		}
 	  if (ptr)
 	    {
-	      strcpy (remcomOutBuffer, "E01");
+	      my_strcpy (remcomOutBuffer, "E01");
 	    }
 	  break;
 	case '?':
@@ -436,15 +438,15 @@ handle_exception (int exceptionVector)
 		      else	/* stack in interrupt mode */
 			registers[R15] = registers[SPU];
 		    }
-		  strcpy (remcomOutBuffer, "OK");
+		  my_strcpy (remcomOutBuffer, "OK");
 		  break;
 		}
-	    strcpy (remcomOutBuffer, "E01");
+	    my_strcpy (remcomOutBuffer, "E01");
 	    break;
 	  }
 	case 'G':		/* set the value of the CPU registers - return OK */
 	  hex2mem (ptr, (unsigned char *) registers, NUMREGBYTES, 0);
-	  strcpy (remcomOutBuffer, "OK");
+	  my_strcpy (remcomOutBuffer, "OK");
 	  break;
 	case 's':		/* sAA..AA      Step one instruction from AA..AA(optional) */
 	  stepping = 1;
@@ -511,7 +513,7 @@ handle_exception (int exceptionVector)
 	  putpacket ("OK");
 	  return;		/* continue the inferior */
 #else
-	  strcpy (remcomOutBuffer, "OK");
+	  my_strcpy (remcomOutBuffer, "OK");
 	  break;
 #endif
 	case 'q':
@@ -1692,7 +1694,7 @@ gdb_write (char *data, int len)
 static int
 gdb_puts (char *str)
 {
-  return gdb_write (str, strlen (str));
+  return gdb_write (str, my_strlen (str));
 }
 
 /* Function: gdb_error(char *, char *)
@@ -1709,12 +1711,12 @@ gdb_error (char *format, char *parm)
   if (remote_debug)
     {
       if (format && *format)
-	len = strlen (format);
+	len = my_strlen (format);
       else
 	return;			/* empty input */
 
       if (parm && *parm)
-	len += strlen (parm);
+	len += my_strlen (parm);
 
       for (cpy = buf; *format;)
 	{
@@ -1733,7 +1735,7 @@ gdb_error (char *format, char *parm)
 }
 
 static unsigned char *
-strcpy (unsigned char *dest, const unsigned char *src)
+my_strcpy (unsigned char *dest, const unsigned char *src)
 {
   unsigned char *ret = dest;
 
@@ -1747,7 +1749,7 @@ strcpy (unsigned char *dest, const unsigned char *src)
 }
 
 static int
-strlen (const unsigned char *src)
+my_strlen (const unsigned char *src)
 {
   int ret;
 
diff --git a/libgloss/mcore/sbrk.c b/libgloss/mcore/sbrk.c
index 1eb8047fc..c6860194c 100644
--- a/libgloss/mcore/sbrk.c
+++ b/libgloss/mcore/sbrk.c
@@ -14,6 +14,7 @@
  */
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <stdlib.h>
 #include "glue.h"
 
 extern int _write (int, char *, int);
diff --git a/libgloss/putnum.c b/libgloss/putnum.c
index c368c4136..6e1051e24 100644
--- a/libgloss/putnum.c
+++ b/libgloss/putnum.c
@@ -14,6 +14,8 @@
  */
 #include "glue.h"
 
+extern void print (char *ptr);
+
 /*
  * putnum -- print a 32 bit number in hex
  */
diff --git a/libgloss/read.c b/libgloss/read.c
index 24108ce0d..83a3b549b 100644
--- a/libgloss/read.c
+++ b/libgloss/read.c
@@ -22,10 +22,11 @@ extern char inbyte (void);
  */
 int
 read (int fd,
-       char *buf,
-       int nbytes)
+       void *buf_,
+       size_t nbytes)
 {
   int i = 0;
+  char *buf = buf_;
 
   for (i = 0; i < nbytes; i++) {
     *(buf + i) = inbyte();
diff --git a/libgloss/unlink.c b/libgloss/unlink.c
index 76c1a4fef..af06c51d7 100644
--- a/libgloss/unlink.c
+++ b/libgloss/unlink.c
@@ -20,7 +20,7 @@
  *           we just return an error.
  */
 int
-unlink (char * path)
+unlink (const char * path)
 {
   errno = EIO;
   return (-1);
diff --git a/libgloss/write.c b/libgloss/write.c
index 28b7ea37a..08526a9db 100644
--- a/libgloss/write.c
+++ b/libgloss/write.c
@@ -23,10 +23,11 @@ extern int  outbyte (char x);
  */
 int
 write (int fd,
-       char *buf,
-       int nbytes)
+       void *buf_,
+       size_t nbytes)
 {
   int i;
+  char *buf = buf_;
 
   for (i = 0; i < nbytes; i++) {
     if (*(buf + i) == '\n') {
diff --git a/newlib/libc/reent/signalr.c b/newlib/libc/reent/signalr.c
index 863ae7400..2a33e333e 100644
--- a/newlib/libc/reent/signalr.c
+++ b/newlib/libc/reent/signalr.c
@@ -6,6 +6,8 @@
 #include <unistd.h>
 #include <_syslist.h>
 
+int _kill (pid_t, int); 
+
 /* Some targets provides their own versions of these functions.  Those
    targets should define REENTRANT_SYSCALLS_PROVIDED in TARGET_CFLAGS.  */
 
diff --git a/newlib/libc/search/hash_page.c b/newlib/libc/search/hash_page.c
index 9d15b0cb7..59fc81850 100644
--- a/newlib/libc/search/hash_page.c
+++ b/newlib/libc/search/hash_page.c
@@ -36,6 +36,12 @@ static char sccsid[] = "@(#)hash_page.c	8.7 (Berkeley) 8/16/94";
 #endif /* LIBC_SCCS and not lint */
 #include <sys/cdefs.h>
 
+#include <signal.h>
+#ifndef sigfillset
+int sigfillset (sigset_t *); 
+#endif
+
+
 /*
  * PACKAGE:  hashing
  *
diff --git a/newlib/libc/stdlib/system.c b/newlib/libc/stdlib/system.c
index f30b7df80..04b285bcc 100644
--- a/newlib/libc/stdlib/system.c
+++ b/newlib/libc/stdlib/system.c
@@ -56,6 +56,10 @@ Supporting OS subroutines required: <<_exit>>, <<_execve>>, <<_fork_r>>,
 static int do_system (struct _reent *ptr, const char *s);
 #endif
 
+#if defined(HAVE_SYSTEM)
+int _system(const char *command);
+#endif
+
 int
 _system_r (struct _reent *ptr,
      const char *s)
diff --git a/newlib/libc/sys/h8300hms/crt0.S b/newlib/libc/sys/h8300hms/crt0.S
index 6394f6841..05634113c 100644
--- a/newlib/libc/sys/h8300hms/crt0.S
+++ b/newlib/libc/sys/h8300hms/crt0.S
@@ -9,12 +9,10 @@
 _start:
 	mov.w	#_stack,sp
 	mov.w	#_edata,r0
-	mov.w	#_end,r1
-	sub.w   r2,r2
-.Loop:	mov.w	r2,@r0
-	adds	#2,r0
-	cmp	r1,r0
-	blo	.Loop
+	mov.w	#_end,r2
+	sub.w   r1,r1
+	sub.w	r0,r2
+	jsr	@_memset
 #ifdef __ELF__
 	mov.l   #__fini,r0
 	jsr     @_atexit
@@ -43,12 +41,10 @@ _stack:	.word 	1
 _start:
 	mov.l	#_stack,sp
 	mov.l	#_edata,er0
-	mov.l	#_end,er1
-	sub.w   r2,r2           ; not sure about alignment requirements
-.Loop:	mov.w	r2,@er0		; playing it safe for now
-	adds	#2,er0
-	cmp.l	er1,er0
-	blo	.Loop
+	mov.l	#_end,er2
+	sub.w   r1,r1
+	sub.l	er0,er2
+	jsr	@_memset
 #ifdef __ELF__
 	mov.l   #__fini,er0
 	jsr     @_atexit
@@ -77,12 +73,10 @@ _stack:	.long 	1
 _start:
 	mov.l	#_stack,sp
 	mov.l	#_edata,er0
-	mov.l	#_end,er1
-	sub.w   r2,r2           ; not sure about alignment requirements
-.Loop:	mov.w	r2,@er0		; playing it safe for now
-	adds	#2,er0
-	cmp.l	er1,er0
-	blo	.Loop
+	mov.l	#_end,er2
+	sub.w   r1,r1
+	sub.l	er0,er2
+	jsr	@_memset
 #ifdef __ELF__
 	mov.l   #__fini,er0
 	jsr     @_atexit
diff --git a/newlib/libm/complex/cargl.c b/newlib/libm/complex/cargl.c
index 790cffe8f..ac6ba1e7d 100644
--- a/newlib/libm/complex/cargl.c
+++ b/newlib/libm/complex/cargl.c
@@ -7,6 +7,8 @@
 #include <complex.h>
 #include <math.h>
 
+long double atan2l(long double y, long double x);
+
 long double
 cargl(long double complex z)
 {     
diff --git a/newlib/libm/complex/catanl.c b/newlib/libm/complex/catanl.c
index 13839ac73..78172d8c4 100644
--- a/newlib/libm/complex/catanl.c
+++ b/newlib/libm/complex/catanl.c
@@ -33,6 +33,9 @@
 #include <math.h>
 #include "cephes_subrl.h"
 
+long double logl(long double x);
+long double atan2l(long double x, long double y);
+
 #ifdef __weak_alias
 __weak_alias(catanl, _catanl)
 #endif
diff --git a/newlib/libm/complex/ccoshl.c b/newlib/libm/complex/ccoshl.c
index f59fadf7a..2ee4ca364 100644
--- a/newlib/libm/complex/ccoshl.c
+++ b/newlib/libm/complex/ccoshl.c
@@ -32,6 +32,11 @@
 #include <complex.h>
 #include <math.h>
 
+long double coshl(long double x);
+long double sinhl(long double x);
+long double sinl(long double x);
+long double cosl(long double x);
+
 long double complex
 ccoshl(long double complex z)
 {
diff --git a/newlib/libm/complex/ccosl.c b/newlib/libm/complex/ccosl.c
index c310f4024..f71d94385 100644
--- a/newlib/libm/complex/ccosl.c
+++ b/newlib/libm/complex/ccosl.c
@@ -33,6 +33,9 @@
 #include <math.h>
 #include "cephes_subrl.h"
 
+long double cosl(long double x);
+long double sinl(long double x);
+
 long double complex
 ccosl(long double complex z)
 {
diff --git a/newlib/libm/complex/cephes_subrl.c b/newlib/libm/complex/cephes_subrl.c
index 8af11df76..f890447c7 100644
--- a/newlib/libm/complex/cephes_subrl.c
+++ b/newlib/libm/complex/cephes_subrl.c
@@ -33,6 +33,13 @@
 #include <math.h>
 #include "cephes_subrl.h"
 
+long double expl(long double x);
+long double cosl(long double x);
+long double sinl(long double x);
+long double coshl(long double x);
+long double sinhl(long double x);
+long double fabsl(long double x);
+
 /* calculate cosh and sinh */
 
 void
diff --git a/newlib/libm/complex/cexpl.c b/newlib/libm/complex/cexpl.c
index 8b56634ba..627b4f33b 100644
--- a/newlib/libm/complex/cexpl.c
+++ b/newlib/libm/complex/cexpl.c
@@ -32,6 +32,10 @@
 #include <complex.h>
 #include <math.h>
 
+long double expl(long double x);
+long double cosl(long double x);
+long double sinl(long double x);
+
 long double complex
 cexpl(long double complex z)
 {
diff --git a/newlib/libm/complex/clogl.c b/newlib/libm/complex/clogl.c
index 3644a44fc..48b9f3ac9 100644
--- a/newlib/libm/complex/clogl.c
+++ b/newlib/libm/complex/clogl.c
@@ -32,6 +32,9 @@
 #include <complex.h>
 #include <math.h>
 
+long double logl (long double);
+long double atan2l(long double y, long double x);
+
 long double complex
 clogl(long double complex z)
 {
diff --git a/newlib/libm/complex/cpowl.c b/newlib/libm/complex/cpowl.c
index 85c2c20f2..b6695c179 100644
--- a/newlib/libm/complex/cpowl.c
+++ b/newlib/libm/complex/cpowl.c
@@ -32,6 +32,13 @@
 #include <complex.h>
 #include <math.h>
 
+long double powl(long double, long double);
+long double expl(long double x);
+long double logl(long double x);
+long double cosl(long double x);
+long double sinl(long double x);
+
+
 long double complex
 cpowl(long double complex a, long double complex z)
 {
diff --git a/newlib/libm/complex/cprojl.c b/newlib/libm/complex/cprojl.c
index e71c77353..d82516a62 100644
--- a/newlib/libm/complex/cprojl.c
+++ b/newlib/libm/complex/cprojl.c
@@ -33,6 +33,8 @@ __RCSID("$NetBSD: cprojl.c,v 1.7 2014/10/10 00:48:18 christos Exp $");
 
 #include "../common/fdlibm.h"
 
+long double copysignl(long double x, long double y);
+
 /*
  * cprojl(long double complex z)
  *
diff --git a/newlib/libm/complex/csinhl.c b/newlib/libm/complex/csinhl.c
index 44ed05037..e9865f995 100644
--- a/newlib/libm/complex/csinhl.c
+++ b/newlib/libm/complex/csinhl.c
@@ -32,6 +32,11 @@
 #include <complex.h>
 #include <math.h>
 
+long double cosl(long double x);
+long double sinl(long double x);
+long double coshl(long double x);
+long double sinhl(long double x);
+
 long double complex
 csinhl(long double complex z)
 {
diff --git a/newlib/libm/complex/csinl.c b/newlib/libm/complex/csinl.c
index 2b96c7225..2c1997cae 100644
--- a/newlib/libm/complex/csinl.c
+++ b/newlib/libm/complex/csinl.c
@@ -33,6 +33,9 @@
 #include <math.h>
 #include "cephes_subrl.h"
 
+long double cosl(long double x);
+long double sinl(long double x);
+
 long double complex
 csinl(long double complex z)
 {
diff --git a/newlib/libm/complex/csqrtl.c b/newlib/libm/complex/csqrtl.c
index c10a1264a..985aad4b0 100644
--- a/newlib/libm/complex/csqrtl.c
+++ b/newlib/libm/complex/csqrtl.c
@@ -35,6 +35,11 @@ __RCSID("$NetBSD: csqrtl.c,v 1.2 2014/10/11 00:43:51 christos Exp $");
 #include <float.h>
 #include <math.h>
 #include <stdbool.h>
+
+long double fabsl(long double x);
+long double copysignl(long double x, long double y);
+
+
 /*
  * gcc doesn't implement complex multiplication or division correctly,
  * so we need to handle infinities specially. We turn on this pragma to
diff --git a/newlib/libm/complex/ctanhl.c b/newlib/libm/complex/ctanhl.c
index 1db886f63..619a03f72 100644
--- a/newlib/libm/complex/ctanhl.c
+++ b/newlib/libm/complex/ctanhl.c
@@ -32,6 +32,11 @@
 #include <complex.h>
 #include <math.h>
 
+long double cosl(long double x);
+long double sinl(long double x);
+long double coshl(long double x);
+long double sinhl(long double x);
+
 long double complex
 ctanhl(long double complex z)
 {
diff --git a/newlib/libm/complex/ctanl.c b/newlib/libm/complex/ctanl.c
index c5c887c74..5fe76a718 100644
--- a/newlib/libm/complex/ctanl.c
+++ b/newlib/libm/complex/ctanl.c
@@ -34,6 +34,12 @@
 #include <math.h>
 #include "cephes_subrl.h"
 
+long double cosl(long double x);
+long double sinl(long double x);
+long double coshl(long double x);
+long double sinhl(long double x);
+long double fabsl(long double x);
+
 long double complex
 ctanl(long double complex z)
 {
