diff --git a/gcc/bb-reorder.cc b/gcc/bb-reorder.cc
index 5cd48255f8a..1c1cbaeb1e2 100644
--- a/gcc/bb-reorder.cc
+++ b/gcc/bb-reorder.cc
@@ -2570,7 +2570,7 @@ reorder_basic_blocks (void)
 
   /* Signal that rtl_verify_flow_info_1 can now verify that there
      is at most one switch between hot/cold sections.  */
-  crtl->bb_reorder_complete = true;
+  crtl->rtl_pass_progress |= PROGRESS_bb_reorder_complete;
 }
 
 /* Determine which partition the first basic block in the function
diff --git a/gcc/cfgrtl.cc b/gcc/cfgrtl.cc
index a05c338a4c8..8fe367e53c5 100644
--- a/gcc/cfgrtl.cc
+++ b/gcc/cfgrtl.cc
@@ -1907,7 +1907,7 @@ rtl_split_edge (edge edge_in)
              an extra partition crossing in the chain, which is illegal.
              It can't go after the src, because src may have a fall-through
              to a different block.  */
-          if (crtl->bb_reorder_complete
+          if (bb_reorder_complete
               && (edge_in->flags & EDGE_CROSSING))
             {
               after = last_bb_in_partition (edge_in->src);
@@ -2444,7 +2444,7 @@ fixup_partitions (void)
       while (! bbs_to_fix.is_empty ());
 
       /* Fix up hot cold block grouping if needed.  */
-      if (crtl->bb_reorder_complete && current_ir_type () == IR_RTL_CFGRTL)
+      if (bb_reorder_complete && current_ir_type () == IR_RTL_CFGRTL)
 	{
 	  basic_block bb, first = NULL, second = NULL;
 	  int current_partition = BB_UNPARTITIONED;
@@ -2507,7 +2507,7 @@ verify_hot_cold_block_grouping (void)
   /* Even after bb reordering is complete, we go into cfglayout mode
      again (in compgoto). Ensure we don't call this before going back
      into linearized RTL when any layout fixes would have been committed.  */
-  if (!crtl->bb_reorder_complete
+  if (!bb_reorder_complete
       || current_ir_type () != IR_RTL_CFGRTL)
     return err;
 
@@ -4481,7 +4481,7 @@ cfg_layout_initialize (int flags)
      layout required moving a block from the hot to the cold
      section. This would create an illegal partitioning unless some
      manual fixup was performed.  */
-  gcc_assert (!crtl->bb_reorder_complete || !crtl->has_bb_partition);
+  gcc_assert (!bb_reorder_complete || !crtl->has_bb_partition);
 
   initialize_original_copy_tables ();
 
diff --git a/gcc/combine.cc b/gcc/combine.cc
index a5fabf397f7..18e2a802757 100644
--- a/gcc/combine.cc
+++ b/gcc/combine.cc
@@ -14991,6 +14991,7 @@ rest_of_handle_combine (void)
     }
 
   regstat_free_n_sets_and_refs ();
+  crtl->rtl_pass_progress |= PROGRESS_combine_completed;
   return 0;
 }
 
diff --git a/gcc/config/i386/x86-tune-sched-atom.cc b/gcc/config/i386/x86-tune-sched-atom.cc
index 07d2093cce2..9fe3933e92a 100644
--- a/gcc/config/i386/x86-tune-sched-atom.cc
+++ b/gcc/config/i386/x86-tune-sched-atom.cc
@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "rtl-iter.h"
 #include "regset.h"
 #include "sched-int.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
 
 /* Try to reorder ready list to take advantage of Atom pipelined IMUL
    execution. It is applied if
diff --git a/gcc/config/i386/x86-tune-sched.cc b/gcc/config/i386/x86-tune-sched.cc
index 1ffaeef037c..315ce04e962 100644
--- a/gcc/config/i386/x86-tune-sched.cc
+++ b/gcc/config/i386/x86-tune-sched.cc
@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "insn-attr.h"
 #include "insn-opinit.h"
 #include "recog.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
 
 /* Return the maximum number of instructions a cpu can issue.  */
 
diff --git a/gcc/config/microblaze/microblaze.cc b/gcc/config/microblaze/microblaze.cc
index f32effecfb6..fcf61e076e5 100644
--- a/gcc/config/microblaze/microblaze.cc
+++ b/gcc/config/microblaze/microblaze.cc
@@ -3308,8 +3308,8 @@ microblaze_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   rtx this_rtx, funexp;
   rtx_insn *insn;
 
-  reload_completed = 1;
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
 
   /* Mark the end of the (empty) prologue.  */
   emit_note (NOTE_INSN_PROLOGUE_END);
@@ -3366,8 +3366,8 @@ microblaze_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   final_end_function ();
   assemble_end_function (thunk_fndecl, fnname);
 
-  reload_completed = 0;
-  epilogue_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
+  crtl->rtl_pass_progress &= ~PROGRESS_epilogue_completed;
 }
 
 bool
diff --git a/gcc/config/mips/mips.cc b/gcc/config/mips/mips.cc
index e81a245dcf4..a7aed77726e 100644
--- a/gcc/config/mips/mips.cc
+++ b/gcc/config/mips/mips.cc
@@ -19659,7 +19659,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   bool use_sibcall_p;
 
   /* Pretend to be a post-reload pass while generating rtl.  */
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   /* Mark the end of the (empty) prologue.  */
   emit_note (NOTE_INSN_PROLOGUE_END);
@@ -19774,7 +19774,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
 
   /* Clean up the vars set above.  Note that final_end_function resets
      the global pointer for us.  */
-  reload_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
 }
 
 
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index e0f0a582732..c0035066dad 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -2922,7 +2922,7 @@
    (clobber (match_operand:GPR 4 "lo_operand" "=l"))]
   "ISA_HAS_<D>DIV && !TARGET_FIX_VR4120 && TARGET_MIPS16"
   "#"
-  "&& cse_not_expected"
+  "&& crtl->cse_not_expected"
   [(const_int 0)]
 {
   emit_insn (gen_divmod<mode>4_split (operands[3], operands[1], operands[2]));
@@ -2982,7 +2982,7 @@
    (clobber (match_operand:GPR 4 "lo_operand" "=l"))]
   "ISA_HAS_<D>DIV && TARGET_MIPS16"
   "#"
-  "cse_not_expected"
+  "crtl->cse_not_expected"
   [(const_int 0)]
 {
   emit_insn (gen_udivmod<mode>4_split (operands[3], operands[1], operands[2]));
@@ -4544,7 +4544,7 @@
   "!TARGET_MIPS16
    && TARGET_EXPLICIT_RELOCS
    && ABI_HAS_64BIT_SYMBOLS
-   && cse_not_expected"
+   && crtl->cse_not_expected"
   "#"
   "&& reload_completed"
   [(set (match_dup 0) (high:DI (match_dup 3)))
diff --git a/gcc/config/nios2/nios2.cc b/gcc/config/nios2/nios2.cc
index 1a33c88f19f..ab65ca00f75 100644
--- a/gcc/config/nios2/nios2.cc
+++ b/gcc/config/nios2/nios2.cc
@@ -4502,7 +4502,7 @@ nios2_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   rtx_insn *insn;
 
   /* Pretend to be a post-reload pass while generating rtl.  */
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   if (flag_pic)
     nios2_load_pic_register ();
@@ -4557,7 +4557,7 @@ nios2_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   assemble_end_function (thunk_fndecl, fnname);
 
   /* Stop pretending to be a post-reload pass.  */
-  reload_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
 }
 
 
diff --git a/gcc/config/or1k/or1k.cc b/gcc/config/or1k/or1k.cc
index da2f59062ba..f5e84e265b0 100644
--- a/gcc/config/or1k/or1k.cc
+++ b/gcc/config/or1k/or1k.cc
@@ -1445,7 +1445,7 @@ or1k_expand_move (machine_mode mode, rtx op0, rtx op1)
 	      HOST_WIDE_INT hi = i ^ lo;
 	      rtx subtarget = op0;
 
-	      if (!cse_not_expected && can_create_pseudo_p ())
+	      if (!crtl->cse_not_expected && can_create_pseudo_p ())
 		subtarget = gen_reg_rtx (SImode);
 	      emit_insn (gen_rtx_SET (subtarget, GEN_INT (hi)));
 	      emit_insn (gen_iorsi3 (op0, subtarget, GEN_INT (lo)));
@@ -2102,8 +2102,8 @@ or1k_output_mi_thunk (FILE *file, tree thunk_fndecl,
   rtx this_rtx, funexp;
   rtx_insn *insn;
 
-  reload_completed = 1;
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
 
   emit_note (NOTE_INSN_PROLOGUE_END);
 
@@ -2187,8 +2187,8 @@ or1k_output_mi_thunk (FILE *file, tree thunk_fndecl,
   final_end_function ();
   assemble_end_function (thunk_fndecl, fnname);
 
-  reload_completed = 0;
-  epilogue_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
+  crtl->rtl_pass_progress &= ~PROGRESS_epilogue_completed;
 }
 
 #undef  TARGET_ASM_OUTPUT_MI_THUNK
diff --git a/gcc/config/s390/s390.cc b/gcc/config/s390/s390.cc
index 5aaf76a9490..eeb2984a712 100644
--- a/gcc/config/s390/s390.cc
+++ b/gcc/config/s390/s390.cc
@@ -342,8 +342,6 @@ const struct s390_processor processor_table[] =
   { "native", "",       PROCESSOR_NATIVE,      NULL,         0  }
 };
 
-extern int reload_completed;
-
 /* Kept up to date using the SCHED_VARIABLE_ISSUE hook.  */
 static rtx_insn *last_scheduled_insn;
 #define NUM_SIDES 2
diff --git a/gcc/config/sh/sh.cc b/gcc/config/sh/sh.cc
index 9bee618b639..db01e8e96c0 100644
--- a/gcc/config/sh/sh.cc
+++ b/gcc/config/sh/sh.cc
@@ -10796,8 +10796,8 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   int did_load = 0;
   rtx scratch0, scratch1, scratch2;
 
-  reload_completed = 1;
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
   crtl->uses_only_leaf_regs = 1;
 
   emit_note (NOTE_INSN_PROLOGUE_END);
@@ -10950,8 +10950,8 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   final_end_function ();
   assemble_end_function (thunk_fndecl, fnname);
 
-  reload_completed = 0;
-  epilogue_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
+  crtl->rtl_pass_progress &= ~PROGRESS_epilogue_completed;
 }
 
 /* Return an RTX pair for the address and call site label of a function
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index 59a7b216433..e169c9411d5 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -3638,7 +3638,7 @@
   [(set (reg:SI T_REG)
 	(lt:SI (match_operand:SI 0 "arith_reg_operand" "r") (const_int 0)))
    (clobber (match_scratch:SI 1 "=0"))]
-  "TARGET_SH1 && cse_not_expected"
+  "TARGET_SH1 && crtl->cse_not_expected"
   "shll	%0"
   [(set_attr "type" "arith")])
 
diff --git a/gcc/cse.cc b/gcc/cse.cc
index b13afd4ba72..b094a3897ea 100644
--- a/gcc/cse.cc
+++ b/gcc/cse.cc
@@ -7533,7 +7533,7 @@ rest_of_handle_cse (void)
 
   /* If we are not running more CSE passes, then we are no longer
      expecting CSE to be run.  But always rerun it in a cheap mode.  */
-  cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;
+  crtl->cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;
 
   if (tem == 2)
     {
@@ -7617,7 +7617,7 @@ rest_of_handle_cse2 (void)
   else if (tem == 1 || cse_cfg_altered)
     cse_cfg_altered |= cleanup_cfg (0);
 
-  cse_not_expected = 1;
+  crtl->cse_not_expected = true;
   return 0;
 }
 
@@ -7681,7 +7681,7 @@ rest_of_handle_cse_after_global_opts (void)
   cse_cfg_altered |= purge_all_dead_edges ();
   delete_trivially_dead_insns (get_insns (), max_reg_num ());
 
-  cse_not_expected = !flag_rerun_cse_after_loop;
+  crtl->cse_not_expected = !flag_rerun_cse_after_loop;
 
   /* If cse altered any jumps, rerun jump opts to clean things up.  */
   if (tem == 2)
diff --git a/gcc/df-problems.cc b/gcc/df-problems.cc
index 238424ceac8..8fd0470a801 100644
--- a/gcc/df-problems.cc
+++ b/gcc/df-problems.cc
@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "rtl-iter.h"
 #include "regs.h"
 #include "function-abi.h"
+#include "emit-rtl.h"
 
 /* Note that turning REG_DEAD_DEBUGGING on will cause
    gcc.c-torture/unsorted/dump-noaddr.c to fail because it prints
diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
index 7a58fedb97a..8dcbb365e23 100644
--- a/gcc/emit-rtl.h
+++ b/gcc/emit-rtl.h
@@ -54,6 +54,16 @@ struct GTY(()) incoming_args {
   rtx internal_arg_pointer;
 };
 
+#define PROGRESS_combine_completed	(1 << 0)
+#define PROGRESS_lra_in_progress	(1 << 1)
+#define PROGRESS_reload_in_progress	(1 << 2)
+#define PROGRESS_reload_completed	(1 << 3)
+#define PROGRESS_epilogue_completed	(1 << 4)
+#define PROGRESS_bb_reorder_complete	(1 << 5)
+#define PROGRESS_regstack_completed	(1 << 6)
+
+#define PROGRESS_no_pseudos \
+	(PROGRESS_reload_in_progress | PROGRESS_reload_completed)
 
 /* Datastructures maintained for currently processed function in RTL form.  */
 struct GTY(()) rtl_data {
@@ -76,6 +86,9 @@ struct GTY(()) rtl_data {
 
   rtl_ssa::function_info *GTY((skip)) ssa;
 
+  /* Track progress of RTL passes, reload_completed etc.  */
+  int rtl_pass_progress;
+
   /* For function.cc  */
 
   /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is
@@ -303,9 +316,13 @@ struct GTY(()) rtl_data {
      block.  */
   bool has_bb_partition;
 
-  /* Nonzero if the function being compiled has completed the bb reordering
-     pass.  */
-  bool bb_reorder_complete;
+  /* If this is nonzero, we do not bother generating VOLATILE
+     around volatile memory references, and we are willing to
+     output indirect addresses.  If cse is to follow, we reject
+     indirect addresses so a useful potential cse is generated;
+     if it is used only once, instruction combination will produce
+     the same indirect address eventually.  */
+  bool cse_not_expected;
 
   /* Like regs_ever_live, but 1 if a reg is set or clobbered from an
      asm.  Unlike regs_ever_live, elements of this array corresponding
@@ -342,6 +359,20 @@ extern GTY(()) struct rtl_data x_rtl;
    want to do differently.  */
 #define crtl (&x_rtl)
 
+/* rtl_pass_progress macros.  */
+#define crtl_pass_progress (crtl->rtl_pass_progress)
+
+#define combine_completed (crtl_pass_progress & PROGRESS_combine_completed)
+#define lra_in_progress (crtl_pass_progress & PROGRESS_lra_in_progress)
+#define reload_in_progress (crtl_pass_progress & PROGRESS_reload_in_progress)
+#define reload_completed (crtl_pass_progress & PROGRESS_reload_completed)
+#define bb_reorder_complete (crtl_pass_progress & PROGRESS_bb_reorder_complete)
+#define epilogue_completed (crtl_pass_progress & PROGRESS_epilogue_completed)
+#define regstack_completed (crtl_pass_progress & PROGRESS_regstack_completed)
+
+/* This macro indicates whether you may create a new pseudo-register.  */
+#define can_create_pseudo_p() ((crtl_pass_progress & PROGRESS_no_pseudos) == 0)
+
 /* Return whether two MEM_ATTRs are equal.  */
 bool mem_attrs_eq_p (const class mem_attrs *, const class mem_attrs *);
 
diff --git a/gcc/explow.cc b/gcc/explow.cc
index ddb4d6ae360..9fbeea77321 100644
--- a/gcc/explow.cc
+++ b/gcc/explow.cc
@@ -439,7 +439,7 @@ memory_address_addr_space (machine_mode mode, rtx x, addr_space_t as)
 
   /* By passing constant addresses through registers
      we get a chance to cse them.  */
-  if (! cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))
+  if (! crtl->cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))
     x = force_reg (address_mode, x);
 
   /* We get better cse by rejecting indirect addressing at this stage.
@@ -448,7 +448,7 @@ memory_address_addr_space (machine_mode mode, rtx x, addr_space_t as)
      are visible.  But not if cse won't be done!  */
   else
     {
-      if (! cse_not_expected && !REG_P (x))
+      if (! crtl->cse_not_expected && !REG_P (x))
 	x = break_out_memory_refs (x);
 
       /* At this point, any valid address is accepted.  */
@@ -603,7 +603,7 @@ use_anchored_address (rtx x)
      We will then be able to reuse registers for several accesses, if the
      target costs say that that's worthwhile.  */
   mode = GET_MODE (base);
-  if (!cse_not_expected)
+  if (!crtl->cse_not_expected)
     base = force_reg (mode, base);
 
   return replace_equiv_address (x, plus_constant (mode, base, offset));
diff --git a/gcc/final.cc b/gcc/final.cc
index 0352786e49b..5ee812e321d 100644
--- a/gcc/final.cc
+++ b/gcc/final.cc
@@ -4511,11 +4511,7 @@ rest_of_clean_state (void)
     }
 
   flag_rerun_cse_after_global_opts = 0;
-  reload_completed = 0;
-  epilogue_completed = 0;
-#ifdef STACK_REGS
-  regstack_completed = 0;
-#endif
+  crtl->rtl_pass_progress = 0;
 
   /* Clear out the insn_length contents now that they are no
      longer valid.  */
diff --git a/gcc/function.cc b/gcc/function.cc
index 31256b57197..349aaa3e617 100644
--- a/gcc/function.cc
+++ b/gcc/function.cc
@@ -4924,7 +4924,7 @@ prepare_function_start (void)
   if (flag_stack_usage_info && !flag_callgraph_info)
     allocate_stack_usage_info ();
 
-  cse_not_expected = ! optimize;
+  crtl->cse_not_expected = ! optimize;
 
   /* Caller save not needed yet.  */
   caller_save_needed = 0;
@@ -6093,7 +6093,7 @@ thread_prologue_and_epilogue_insns (void)
   /* A small fib -- epilogue is not yet completed, but we wish to re-use
      this marker for the splits of EH_RETURN patterns, and nothing else
      uses the flag in the meantime.  */
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
 
   /* Find non-fallthru edges that end with EH_RETURN instructions.  On
      some targets, these get split to a special version of the epilogue
@@ -6259,7 +6259,7 @@ thread_prologue_and_epilogue_insns (void)
 
   /* Threading the prologue and epilogue changes the artificial refs
      in the entry and exit blocks.  */
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
   df_update_entry_exit_and_calls ();
 }
 
diff --git a/gcc/genconditions.cc b/gcc/genconditions.cc
index f63a3f495c5..52ea654de98 100644
--- a/gcc/genconditions.cc
+++ b/gcc/genconditions.cc
@@ -97,6 +97,7 @@ write_header (void)
 #include \"resource.h\"\n\
 #include \"diagnostic-core.h\"\n\
 #include \"reload.h\"\n\
+#include \"emit-rtl.h\"\n\
 #include \"tm-constrs.h\"\n");
 
   if (saw_eh_return)
diff --git a/gcc/genpeep.cc b/gcc/genpeep.cc
index 24b991afd16..b5ff2511fb7 100644
--- a/gcc/genpeep.cc
+++ b/gcc/genpeep.cc
@@ -378,6 +378,7 @@ from the machine description file `md'.  */\n\n");
   printf ("#include \"except.h\"\n");
   printf ("#include \"diagnostic-core.h\"\n");
   printf ("#include \"flags.h\"\n");
+  printf ("#include \"emit-rtl.h\"\n");
   printf ("#include \"tm-constrs.h\"\n\n");
 
   printf ("extern rtx peep_operand[];\n\n");
diff --git a/gcc/ifcvt.cc b/gcc/ifcvt.cc
index 2e8ab396e26..fd7d1ed39c0 100644
--- a/gcc/ifcvt.cc
+++ b/gcc/ifcvt.cc
@@ -2128,7 +2128,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)
      conditional on their addresses followed by a load.  Don't do this
      early because it'll screw alias analysis.  Note that we've
      already checked for no side effects.  */
-  if (cse_not_expected
+  if (crtl->cse_not_expected
       && MEM_P (a) && MEM_P (b)
       && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b))
     {
diff --git a/gcc/lra-eliminations.cc b/gcc/lra-eliminations.cc
index c630ff4af2d..434e4ec9483 100644
--- a/gcc/lra-eliminations.cc
+++ b/gcc/lra-eliminations.cc
@@ -1261,14 +1261,14 @@ init_elim_table (void)
      will cause, e.g., gen_rtx_REG (Pmode, STACK_POINTER_REGNUM) to
      equal stack_pointer_rtx.  We depend on this. Threfore we switch
      off that we are in LRA temporarily.  */
-  lra_in_progress = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_lra_in_progress;
   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)
     {
       ep->from_rtx = gen_rtx_REG (Pmode, ep->from);
       ep->to_rtx = gen_rtx_REG (Pmode, ep->to);
       eliminable_reg_rtx[ep->from] = ep->from_rtx;
     }
-  lra_in_progress = 1;
+  crtl->rtl_pass_progress |= PROGRESS_lra_in_progress;
 }
 
 /* Function for initialization of elimination once per function.  It
diff --git a/gcc/lra.cc b/gcc/lra.cc
index 1444cb75914..ce4843fc0a9 100644
--- a/gcc/lra.cc
+++ b/gcc/lra.cc
@@ -2218,9 +2218,6 @@ update_inc_notes (void)
       }
 }
 
-/* Set to 1 while in lra.  */
-int lra_in_progress;
-
 /* Start of pseudo regnos before the LRA.  */
 int lra_new_regno_start;
 
@@ -2316,7 +2313,7 @@ lra (FILE *f)
   if (flag_checking)
     check_rtl (false);
 
-  lra_in_progress = 1;
+  crtl->rtl_pass_progress |= PROGRESS_lra_in_progress;
 
   lra_live_range_iter = lra_coalesce_iter = lra_constraint_iter = 0;
   lra_assignment_iter = lra_assignment_iter_after_spill = 0;
@@ -2508,7 +2505,7 @@ lra (FILE *f)
   ira_restore_scratches (lra_dump_file);
   lra_eliminate (true, false);
   lra_final_code_change ();
-  lra_in_progress = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_lra_in_progress;
   if (live_p)
     lra_clear_live_ranges ();
   lra_live_ranges_finish ();
@@ -2519,7 +2516,7 @@ lra (FILE *f)
   finish_insn_recog_data ();
   regstat_free_n_sets_and_refs ();
   regstat_free_ri ();
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
   update_inc_notes ();
 
   inserted_p = fixup_abnormal_edges ();
diff --git a/gcc/modulo-sched.cc b/gcc/modulo-sched.cc
index 162de199da6..f3b15a47aa4 100644
--- a/gcc/modulo-sched.cc
+++ b/gcc/modulo-sched.cc
@@ -1369,11 +1369,11 @@ sms_schedule (void)
   /* Initialize issue_rate.  */
   if (targetm.sched.issue_rate)
     {
-      int temp = reload_completed;
+      int temp = crtl->rtl_pass_progress;
 
-      reload_completed = 1;
+      crtl->rtl_pass_progress |= PROGRESS_reload_completed;
       issue_rate = targetm.sched.issue_rate ();
-      reload_completed = temp;
+      crtl->rtl_pass_progress = temp;
     }
   else
     issue_rate = 1;
diff --git a/gcc/passes.cc b/gcc/passes.cc
index 78a07f8691a..9a1a0d8d352 100644
--- a/gcc/passes.cc
+++ b/gcc/passes.cc
@@ -2541,12 +2541,12 @@ skip_pass (opt_pass *pass)
   /* Pass "reload" sets the global "reload_completed", and many
      things depend on this (e.g. instructions in .md files).  */
   if (strcmp (pass->name, "reload") == 0)
-    reload_completed = 1;
+    crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   /* Similar for pass "pro_and_epilogue" and the "epilogue_completed" global
      variable.  */
   if (strcmp (pass->name, "pro_and_epilogue") == 0)
-    epilogue_completed = 1;
+    crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
 
   /* The INSN_ADDRESSES vec is normally set up by
      shorten_branches; set it up for the benefit of passes that
diff --git a/gcc/recog.cc b/gcc/recog.cc
index dac172bc7c0..cb1e331bfbb 100644
--- a/gcc/recog.cc
+++ b/gcc/recog.cc
@@ -85,15 +85,6 @@ static operand_alternative asm_op_alt[MAX_RECOG_OPERANDS
 
 int which_alternative;
 
-/* Nonzero after end of reload pass.
-   Set to 1 or 0 by toplev.cc.
-   Controls the significance of (SUBREG (MEM)).  */
-
-int reload_completed;
-
-/* Nonzero after thread_prologue_and_epilogue_insns has run.  */
-int epilogue_completed;
-
 /* Initialize data used by the function `recog'.
    This must be called once in the compilation of a function
    before any insn recognition may be done in the function.  */
diff --git a/gcc/reg-stack.cc b/gcc/reg-stack.cc
index fd032501ad9..a2580f1aa10 100644
--- a/gcc/reg-stack.cc
+++ b/gcc/reg-stack.cc
@@ -188,8 +188,6 @@ static vec<char> stack_regs_mentioned_data;
 
 #define REG_STACK_SIZE (LAST_STACK_REG - FIRST_STACK_REG + 1)
 
-int regstack_completed = 0;
-
 /* This is the basic stack record.  TOP is an index into REG[] such
    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.
 
@@ -3440,7 +3438,7 @@ rest_of_handle_stack_regs (void)
 #ifdef STACK_REGS
   if (reg_to_stack ())
     df_insn_rescan_all ();
-  regstack_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_regstack_completed;
 #endif
   return 0;
 }
diff --git a/gcc/regstat.cc b/gcc/regstat.cc
index db2835474b8..1825a4f4c4b 100644
--- a/gcc/regstat.cc
+++ b/gcc/regstat.cc
@@ -27,6 +27,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "predict.h"
 #include "df.h"
 #include "regs.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
 
 
 struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;
diff --git a/gcc/reload1.cc b/gcc/reload1.cc
index 728dc2a1a5c..153315e4665 100644
--- a/gcc/reload1.cc
+++ b/gcc/reload1.cc
@@ -216,10 +216,6 @@ int reload_first_uid;
    a call-clobbered reg across calls.  */
 int caller_save_needed;
 
-/* Set to 1 while reload_as_needed is operating.
-   Required by some machines to handle any generated moves differently.  */
-int reload_in_progress = 0;
-
 /* This obstack is used for allocation of rtl during register elimination.
    The allocated storage can be freed once find_reloads has processed the
    insn.  */
@@ -877,7 +873,7 @@ reload (rtx_insn *first, int global)
   /* From now on, we may need to generate moves differently.  We may also
      allow modifications of insns which cause them to not be recognized.
      Any such modifications will be cleaned up during reload itself.  */
-  reload_in_progress = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_in_progress;
 
   /* This loop scans the entire function each go-round
      and repeats until one repetition spills no additional hard regs.  */
@@ -1067,7 +1063,7 @@ reload (rtx_insn *first, int global)
 
   CLEAR_REG_SET (&changed_allocation_pseudos);
   CLEAR_REG_SET (&spilled_pseudos);
-  reload_in_progress = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_in_progress;
 
   /* Now eliminate all pseudo regs by modifying them into
      their equivalent memory references.
@@ -1158,7 +1154,7 @@ reload (rtx_insn *first, int global)
   /* We must set reload_completed now since the cleanup_subreg_operands call
      below will re-recognize each insn and reload may have generated insns
      which are only valid during and after reload.  */
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   /* Make a pass over all the insns and delete all USEs which we inserted
      only to tag a REG_EQUAL note on them.  Remove all REG_DEAD and REG_UNUSED
@@ -1294,7 +1290,10 @@ reload (rtx_insn *first, int global)
 
   gcc_assert (bitmap_empty_p (&spilled_pseudos));
 
-  reload_completed = !failure;
+  if (failure)
+    crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
+  else
+    crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   return need_dce;
 }
diff --git a/gcc/rtl.h b/gcc/rtl.h
index 488016bb42a..55c34354eb3 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -4089,41 +4089,6 @@ PUT_MODE (rtx x, machine_mode mode)
 extern rtx output_constant_def (tree, int);
 extern rtx lookup_constant_def (tree);
 
-/* Nonzero after end of reload pass.
-   Set to 1 or 0 by reload1.cc.  */
-
-extern int reload_completed;
-
-/* Nonzero after thread_prologue_and_epilogue_insns has run.  */
-extern int epilogue_completed;
-
-/* Set to 1 while reload_as_needed is operating.
-   Required by some machines to handle any generated moves differently.  */
-
-extern int reload_in_progress;
-
-/* Set to 1 while in lra.  */
-extern int lra_in_progress;
-
-/* This macro indicates whether you may create a new
-   pseudo-register.  */
-
-#define can_create_pseudo_p() (!reload_in_progress && !reload_completed)
-
-#ifdef STACK_REGS
-/* Nonzero after end of regstack pass.
-   Set to 1 or 0 by reg-stack.cc.  */
-extern int regstack_completed;
-#endif
-
-/* If this is nonzero, we do not bother generating VOLATILE
-   around volatile memory references, and we are willing to
-   output indirect addresses.  If cse is to follow, we reject
-   indirect addresses so a useful potential cse is generated;
-   if it is used only once, instruction combination will produce
-   the same indirect address eventually.  */
-extern int cse_not_expected;
-
 /* Translates rtx code to tree code, for those codes needed by
    real_arithmetic.  The function returns an int because the caller may not
    know what `enum tree_code' means.  */
diff --git a/gcc/sched-ebb.cc b/gcc/sched-ebb.cc
index 71d72b6161f..89e4be97723 100644
--- a/gcc/sched-ebb.cc
+++ b/gcc/sched-ebb.cc
@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "cfgrtl.h"
 #include "cfgbuild.h"
 #include "sched-int.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
 
 
 #ifdef INSN_SCHEDULING
diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index 2e83ca07394..b5fe2b3e997 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -4906,7 +4906,7 @@ riscv_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   rtx_insn *insn;
 
   /* Pretend to be a post-reload pass while generating rtl.  */
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   /* Mark the end of the (empty) prologue.  */
   emit_note (NOTE_INSN_PROLOGUE_END);
@@ -4969,7 +4969,7 @@ riscv_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
 
   /* Clean up the vars set above.  Note that final_end_function resets
      the global pointer for us.  */
-  reload_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
 }
 
 /* Allocate a chunk of memory for per-function machine-dependent data.  */
diff --git a/gcc/config/arm/arm.cc b/gcc/config/arm/arm.cc
index 33fb98d5cad..3ea5d5bc62b 100644
--- a/gcc/config/arm/arm.cc
+++ b/gcc/config/arm/arm.cc
@@ -28983,7 +28983,7 @@ arm32_output_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,
 
   rtx temp = gen_rtx_REG (Pmode, IP_REGNUM);
   rtx this_rtx = gen_rtx_REG (Pmode, this_regno);
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
   emit_note (NOTE_INSN_PROLOGUE_END);
 
   /* Add DELTA to THIS_RTX.  */
@@ -29035,7 +29035,7 @@ arm32_output_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,
   final_end_function ();
 
   /* Stop pretending this is a post-reload pass.  */
-  reload_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
 }
 
 /* Output code to add DELTA to the first argument, and then jump
diff --git a/gcc/config/m68k/m68k.cc b/gcc/config/m68k/m68k.cc
index 62898dafe92..113844f39a3 100644
--- a/gcc/config/m68k/m68k.cc
+++ b/gcc/config/m68k/m68k.cc
@@ -5583,7 +5583,7 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
   tmp = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);
 
   /* Pretend to be a post-reload pass while generating rtl.  */
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   /* The "this" pointer is stored at 4(%sp).  */
   this_slot = gen_rtx_MEM (Pmode, plus_constant (Pmode,
@@ -5658,7 +5658,7 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
   assemble_end_function (thunk, fnname);
 
   /* Clean up the vars set above.  */
-  reload_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
 
   /* Restore the original PIC register.  */
   if (flag_pic)
diff --git a/gcc/config/pa/predicates.md b/gcc/config/pa/predicates.md
index 98a024e8c9b..8f0544043b8 100644
--- a/gcc/config/pa/predicates.md
+++ b/gcc/config/pa/predicates.md
@@ -450,7 +450,7 @@
      we need to delay creating move insns with unscaled indexed addresses
      until CSE is not expected.  */
   if (!TARGET_NO_SPACE_REGS
-      && !cse_not_expected
+      && !crtl->cse_not_expected
       && GET_CODE (XEXP (op, 0)) == PLUS
       && REG_P (XEXP (XEXP (op, 0), 0))
       && REG_P (XEXP (XEXP (op, 0), 1)))
@@ -474,7 +474,7 @@
      we need to delay creating move insns with unscaled indexed addresses
      until CSE is not expected.  */
   if (!TARGET_NO_SPACE_REGS
-      && !cse_not_expected
+      && !crtl->cse_not_expected
       && GET_CODE (XEXP (op, 0)) == PLUS
       && REG_P (XEXP (XEXP (op, 0), 0))
       && REG_P (XEXP (XEXP (op, 0), 1)))
diff --git a/gcc/config/pa/pa.cc b/gcc/config/pa/pa.cc
index 54ab486a02d..70ad1800db4 100644
--- a/gcc/config/pa/pa.cc
+++ b/gcc/config/pa/pa.cc
@@ -1798,7 +1798,7 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
      a result, we loose various opportunities to create insns with
      unscaled indexed addresses.  */
   if (!TARGET_NO_SPACE_REGS
-      && !cse_not_expected
+      && !crtl->cse_not_expected
       && GET_CODE (operand1) == MEM
       && GET_CODE (XEXP (operand1, 0)) == PLUS
       && REG_P (XEXP (XEXP (operand1, 0), 0))
diff --git a/gcc/config/aarch64/aarch64.cc b/gcc/config/aarch64/aarch64.cc
index 4b486aeea90..199b6de49d2 100644
--- a/gcc/config/aarch64/aarch64.cc
+++ b/gcc/config/aarch64/aarch64.cc
@@ -10001,7 +10001,7 @@ aarch64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
   if (aarch64_bti_enabled ())
     emit_insn (gen_bti_c());
 
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
   emit_note (NOTE_INSN_PROLOGUE_END);
 
   this_rtx = gen_rtx_REG (Pmode, this_regno);
@@ -10073,7 +10073,7 @@ aarch64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
   assemble_end_function (thunk, fnname);
 
   /* Stop pretending to be a post-reload pass.  */
-  reload_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
 }
 
 static bool
diff --git a/gcc/config/rs6000/rs6000-internal.h b/gcc/config/rs6000/rs6000-internal.h
index 8ee8c987b81..0b5390b993a 100644
--- a/gcc/config/rs6000/rs6000-internal.h
+++ b/gcc/config/rs6000/rs6000-internal.h
@@ -26,7 +26,7 @@
 
 /* Structure used to define the rs6000 stack */
 typedef struct rs6000_stack {
-  int reload_completed;		/* stack info won't change from here on */
+  int reload_completed_;		/* stack info won't change from here on */
   int first_gp_reg_save;	/* first callee saved GP register used */
   int first_fp_reg_save;	/* first callee saved FP register used */
   int first_altivec_reg_save;	/* first callee saved AltiVec register used */
diff --git a/gcc/config/rs6000/rs6000-logue.cc b/gcc/config/rs6000/rs6000-logue.cc
index 59fe1c8cb8b..7c77e216f4d 100644
--- a/gcc/config/rs6000/rs6000-logue.cc
+++ b/gcc/config/rs6000/rs6000-logue.cc
@@ -78,7 +78,7 @@ int rs6000_pic_labelno = 0;
 struct machine_function *
 rs6000_init_machine_status (void)
 {
-  stack_info.reload_completed = 0;
+  stack_info.reload_completed_ = 0;
   return ggc_cleared_alloc<machine_function> ();
 }
 
@@ -683,11 +683,11 @@ rs6000_stack_info (void)
   HOST_WIDE_INT non_fixed_size;
   bool using_static_chain_p;
 
-  if (reload_completed && info->reload_completed)
+  if (reload_completed && info->reload_completed_)
     return info;
 
   memset (info, 0, sizeof (*info));
-  info->reload_completed = reload_completed;
+  info->reload_completed_ = reload_completed;
 
   /* Select which calling sequence.  */
   info->abi = DEFAULT_ABI;
diff --git a/gcc/config/sparc/sparc.cc b/gcc/config/sparc/sparc.cc
index c72c38e1999..699e85fc77a 100644
--- a/gcc/config/sparc/sparc.cc
+++ b/gcc/config/sparc/sparc.cc
@@ -12372,8 +12372,8 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   rtx_insn *insn;
   unsigned int int_arg_first;
 
-  reload_completed = 1;
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
 
   emit_note (NOTE_INSN_PROLOGUE_END);
 
@@ -12561,8 +12561,8 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   final_end_function ();
   assemble_end_function (thunk_fndecl, fnname);
 
-  reload_completed = 0;
-  epilogue_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
+  crtl->rtl_pass_progress &= ~PROGRESS_epilogue_completed;
 }
 
 /* Return true if sparc_output_mi_thunk would be able to output the
diff --git a/gcc/fold-const.cc b/gcc/fold-const.cc
index 99021a82df4..c9e741776cd 100644
--- a/gcc/fold-const.cc
+++ b/gcc/fold-const.cc
@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "gimple.h"
 #include "predict.h"
 #include "memmodel.h"
+#include "emit-rtl.h"
 #include "tm_p.h"
 #include "tree-ssa-operands.h"
 #include "optabs-query.h"
diff --git a/gcc/tree-ssa-ifcombine.cc b/gcc/tree-ssa-ifcombine.cc
index 80c41c45489..0e926115390 100644
--- a/gcc/tree-ssa-ifcombine.cc
+++ b/gcc/tree-ssa-ifcombine.cc
@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "cfghooks.h"
 #include "tree-pass.h"
 #include "memmodel.h"
+#include "emit-rtl.h"
 #include "tm_p.h"
 #include "ssa.h"
 #include "tree-pretty-print.h"
diff --git a/gcc/tree-ssa-reassoc.cc b/gcc/tree-ssa-reassoc.cc
index e13e2cb308d..f5450107db4 100644
--- a/gcc/tree-ssa-reassoc.cc
+++ b/gcc/tree-ssa-reassoc.cc
@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "alloc-pool.h"
 #include "tree-pass.h"
 #include "memmodel.h"
+#include "emit-rtl.h"
 #include "tm_p.h"
 #include "ssa.h"
 #include "optabs-tree.h"
diff --git a/gcc/config/rs6000/rs6000-call.cc b/gcc/config/rs6000/rs6000-call.cc
index 551968b0995..efedb50e214 100644
--- a/gcc/config/rs6000/rs6000-call.cc
+++ b/gcc/config/rs6000/rs6000-call.cc
@@ -2924,8 +2924,8 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   rtx this_rtx, funexp;
   rtx_insn *insn;
 
-  reload_completed = 1;
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
 
   /* Mark the end of the (empty) prologue.  */
   emit_note (NOTE_INSN_PROLOGUE_END);
@@ -2986,6 +2986,6 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   final_end_function ();
   assemble_end_function (thunk_fndecl, fnname);
 
-  reload_completed = 0;
-  epilogue_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
+  crtl->rtl_pass_progress &= ~PROGRESS_epilogue_completed;
 }
diff --git a/gcc/config/xtensa/xtensa.cc b/gcc/config/xtensa/xtensa.cc
index 828c7642b7c..343b3cc550b 100644
--- a/gcc/config/xtensa/xtensa.cc
+++ b/gcc/config/xtensa/xtensa.cc
@@ -5037,7 +5037,7 @@ xtensa_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
   rtx temp0 = gen_rtx_REG (Pmode, A9_REG);
   const char *fnname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk));
 
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
 
   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))
     this_reg_no = 3;
@@ -5097,7 +5097,7 @@ xtensa_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
   assemble_end_function (thunk, fnname);
 
   /* Stop pretending to be a post-reload pass.  */
-  reload_completed = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
 }
 
 static rtx
