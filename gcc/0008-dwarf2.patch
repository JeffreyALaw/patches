diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index a30c9f1dd146..889c08c09e83 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -12641,6 +12641,13 @@ riscv_dwarf_poly_indeterminate_value (unsigned int i, unsigned int *factor,
   */
   gcc_assert (i == 1);
   *factor = BYTES_PER_RISCV_VECTOR.coeffs[1];
+
+  /* The factor will be zero if vector is not enabled.  That ultimately
+     causes problems in the dwarf2 emitter as the factor is used for
+     a division, causing a divide by zero.  */
+  if (*factor == 0)
+    *factor = 1;
+
   *offset = 1;
   return RISCV_DWARF_VLENB;
 }
diff --git a/gcc/testsuite/gcc.target/riscv/pr120674.c b/gcc/testsuite/gcc.target/riscv/pr120674.c
new file mode 100644
index 000000000000..ec8835feb24d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr120674.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-g -w -march=rv32gcv -mabi=ilp32" { target rv32 } } */
+/* { dg-additional-options "-g -w -march=rv64gcv -mabi=lp64d" { target rv64 } } */
+
+#pragma riscv intrinsic "vector"
+void GB_AxB_saxpy5_unrolled_rvv() { vfloat64m8_t vc; }
