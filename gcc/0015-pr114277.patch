diff --git a/gcc/expr.cc b/gcc/expr.cc
index a310b2d9131..ac65fcb4269 100644
--- a/gcc/expr.cc
+++ b/gcc/expr.cc
@@ -10327,7 +10327,7 @@ expand_expr_real_2 (const_sepops ops, rtx target, machine_mode tmode,
 
       expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);
 
-      /* Expand X*Y as X&-Y when Y must be zero or one.  */
+      /* Expand X*Y as a conditional move or X&-Y when Y must be zero or one.  */
       if (SCALAR_INT_MODE_P (mode))
 	{
 	  bool gimple_zero_one_valued_p (tree, tree (*)(tree));
@@ -10349,6 +10349,14 @@ expand_expr_real_2 (const_sepops ops, rtx target, machine_mode tmode,
 					  &algorithm, &variant, cost)
 		  : cost < mul_cost (speed, mode))
 		{
+		  /* First try to expand using a conditional move.  */
+		  if (bit0_p)
+		    temp = expand_cond_expr_using_cmove (treeop0, treeop1, integer_zero_node);
+		  else
+		    temp = expand_cond_expr_using_cmove (treeop1, treeop0, integer_zero_node);
+		  if (temp)
+		    return temp;
+
 		  temp = bit0_p ? expand_and (mode, negate_rtx (mode, op0),
 					      op1, target)
 				: expand_and (mode, op0,
diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index dd50fe4eddf..574d545838e 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -5265,14 +5270,14 @@ riscv_expand_conditional_move (rtx dest, rtx op, rtx cons, rtx alt)
       machine_mode mode0 = GET_MODE (op0);
       machine_mode mode1 = GET_MODE (op1);
 
-      /* An integer comparison must be comparing WORD_MODE objects.  We
-	 must enforce that so that we don't strip away a sign_extension
-	 thinking it is unnecessary.  We might consider using
-	 riscv_extend_operands if they are not already properly extended.  */
+      /* An integer comparison must be comparing WORD_MODE objects.
+	 Extend the comparison arguments as necessary.  */
       if ((INTEGRAL_MODE_P (mode0) && mode0 != word_mode)
 	  || (INTEGRAL_MODE_P (mode1) && mode1 != word_mode))
-	return false;
+	riscv_extend_comparands (code, &op0, &op1);
 
+      op0 = force_reg (word_mode, op0);
+      op1 = force_reg (word_mode, op1);
       /* In the fallback generic case use MODE rather than WORD_MODE for
 	 the output of the SCC instruction, to match the mode of the NEG
 	 operation below.  The output of SCC is 0 or 1 boolean, so it is
diff --git a/gcc/testsuite/gcc.target/i386/pr114277.c b/gcc/testsuite/gcc.target/i386/pr114277.c
new file mode 100644
index 00000000000..f74caf2d9f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr114277.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int a,b;
+void func(int x){
+    a=x*(x||b);
+}
+
+/* { dg-final { scan-assembler-not "or" } } */
+/* { dg-final { scan-assembler-not "cmove" } } */
+
diff --git a/gcc/testsuite/gcc.target/riscv/pr111126.c b/gcc/testsuite/gcc.target/riscv/pr111126.c
new file mode 100644
index 00000000000..f305c31eb4d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr111126.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-march=rv64gc_zicond -mabi=lp64d" { target rv64 } } 
+/* { dg-options "-march=rv32gc_zicond -mabi=ilp32" { target rv32 } } 
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-O3" "-Og" } } */
+
+int f(bool a, int c)
+{
+  return a * c;
+}
+
+int f0(bool a, int c)
+{
+  return (-a) & c;
+}
+
+int f1(bool a, int c)
+{
+  return a ? c : 0;
+}
+
+int f3(int a, int b, int c)
+{
+  return (a == b) * c;
+}
+int g0(bool a, int c)
+{
+  return a ? 0 : c;
+}
+int g1(bool a, int c)
+{
+  a = !a;
+  return a * c;
+}
+
+/* { dg-final { scan-assembler-times "czero" 6 } } */
+
diff --git a/gcc/testsuite/gcc.target/riscv/pr114277.c b/gcc/testsuite/gcc.target/riscv/pr114277.c
new file mode 100644
index 00000000000..10e63babcf3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr114277.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=rv64gc_zicond -mabi=lp64d" { target rv64 } } */
+/* { dg-options "-O2 -march=rv32gc_zicond -mabi=ilp32" { target rv32 } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-O3" "-Og" } } */
+int a,b;
+void func(int x){
+    a=x*(x||b);
+}
+/* { dg-final { scan-assembler-not "czero" } } */
+
diff --git a/gcc/testsuite/gcc.target/riscv/pr118384.c b/gcc/testsuite/gcc.target/riscv/pr118384.c
new file mode 100644
index 00000000000..dae65a3d28c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr118384.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=rv64gc_zicond -mabi=lp64d" { target rv64 } } */
+/* { dg-options "-O2 -march=rv32gc_zicond -mabi=ilp32" { target rv32 } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-O3" "-Og" } } */
+
+#include <stdint-gcc.h>
+uint64_t muldi3(uint64_t a, uint64_t b)
+{
+
+    uint64_t Product;
+
+    Product = 0;
+    while (a) {
+        if (a & 1) {
+            Product += b;
+        }
+        a >>= 1;
+        b <<= 1;
+    }
+
+    return Product;
+}
+
+/* { dg-final { scan-assembler-times "czero" 1 } } */
+
