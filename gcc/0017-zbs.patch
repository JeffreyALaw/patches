diff --git a/gcc/config/riscv/bitmanip.md b/gcc/config/riscv/bitmanip.md
index 23dc47eaaef..8f9b456dd82 100644
--- a/gcc/config/riscv/bitmanip.md
+++ b/gcc/config/riscv/bitmanip.md
@@ -790,18 +790,6 @@ (define_insn "*<bit_optab>i<mode>"
   "<bit_optab>i\t%0,%1,%S2"
   [(set_attr "type" "bitmanip")])
 
-;; As long as the SImode operand is not a partial subreg, we can use a
-;; bseti without postprocessing, as the middle end is smart enough to
-;; stay away from the signbit.
-(define_insn "*<bit_optab>idisi"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(any_or:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "r"))
-		   (match_operand 2 "single_bit_mask_operand" "i")))]
-  "TARGET_ZBS && TARGET_64BIT
-   && !partial_subreg_p (operands[1])"
-  "<bit_optab>i\t%0,%1,%S2"
-  [(set_attr "type" "bitmanip")])
-
 ;; We can easily handle zero extensions
 (define_split
   [(set (match_operand:DI 0 "register_operand")
diff --git a/gcc/testsuite/gcc.target/riscv/pr116715.c b/gcc/testsuite/gcc.target/riscv/pr116715.c
new file mode 100644
index 00000000000..234c6052040
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr116715.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-march=rv64gc_zbs -mabi=lp64d" { target { riscv64*-*-* } } } */
+/* { dg-options "-march=rv32gc_zbs -mabi=ilp32" { target { riscv32*-*-* } } } */
+#include <stdint-gcc.h>
+int32_t a, b;
+int32_t d;
+int64_t f = 695372830942;
+int main() {
+  d = 0;
+  for (; d < 1; d = 1)
+    --f;
+  d |= b = f;
+  int64_t h = d;
+  a = h >> 40;
+  if (a != -1)
+    __builtin_abort ();
+  __builtin_exit (0);
+}
