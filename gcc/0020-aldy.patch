From b79cd12bdcb3c9bcd9e4ae568879360f391b8e53 Mon Sep 17 00:00:00 2001
From: Aldy Hernandez <aldyh@redhat.com>
Date: Thu, 9 May 2024 23:37:30 +0200
Subject: [PATCH] [prange] Do not assume all pointers are the same size
 [PR115009]

In a world with same sized pointers we can always reuse the storage
slots, but since this is not always the case, we need to be more
careful.  However, we can always store an undefined, because that
requires no extra storage.

gcc/ChangeLog:

	PR tree-optimization/115009
	* value-range-storage.cc (prange_storage::alloc): Do not assume
	all pointers are the same size.
	(prange_storage::prange_storage): Same.
	(prange_storage::fits_p): Same.
---
 gcc/value-range-storage.cc | 25 ++++++++++++++++---------
 1 file changed, 16 insertions(+), 9 deletions(-)

diff --git a/gcc/value-range-storage.cc b/gcc/value-range-storage.cc
index bbae0da4772..08783c6aafb 100644
--- a/gcc/value-range-storage.cc
+++ b/gcc/value-range-storage.cc
@@ -593,12 +593,13 @@ frange_storage::fits_p (const frange &) const
 prange_storage *
 prange_storage::alloc (vrange_internal_alloc &allocator, const prange &r)
 {
-  // Assume all pointers are the same size.
-  unsigned prec = TYPE_PRECISION (TREE_TYPE (null_pointer_node));
-  gcc_checking_assert (r.undefined_p () || TYPE_PRECISION (r.type ()) == prec);
-
   typedef trailing_wide_ints<NINTS> twi;
-  size_t size = sizeof (prange_storage) + twi::extra_size (prec);
+  size_t size = sizeof (prange_storage);
+  if (!r.undefined_p ())
+    {
+      unsigned prec = TYPE_PRECISION (r.type ());
+      size += twi::extra_size (prec);
+    }
   prange_storage *p = static_cast <prange_storage *> (allocator.alloc (size));
   new (p) prange_storage (r);
   return p;
@@ -610,7 +611,11 @@ prange_storage::prange_storage (const prange &r)
 {
   // It is the caller's responsibility to allocate enough space such
   // that the precision fits.
-  unsigned prec = TYPE_PRECISION (TREE_TYPE (null_pointer_node));
+  unsigned prec;
+  if (r.undefined_p ())
+    prec = 0;
+  else
+    prec = TYPE_PRECISION (r.type ());
   m_trailing_ints.set_precision (prec);
 
   set_prange (r);
@@ -669,10 +674,12 @@ prange_storage::equal_p (const prange &r) const
 }
 
 bool
-prange_storage::fits_p (const prange &) const
+prange_storage::fits_p (const prange &r) const
 {
-  // All pointers are the same size.
-  return true;
+  if (r.undefined_p ())
+    return true;
+
+  return TYPE_PRECISION (r.type ()) <= m_trailing_ints.get_precision ();
 }
 
 
-- 
2.45.0

