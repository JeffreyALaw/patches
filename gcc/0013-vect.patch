diff --git a/gcc/genopinit.c b/gcc/genopinit.c
index fe0791c27d6..c5cda286924 100644
--- a/gcc/genopinit.c
+++ b/gcc/genopinit.c
@@ -320,7 +320,6 @@ main (int argc, const char **argv)
 	   "  signed char supports_vec_scatter_store[NUM_MACHINE_MODES];\n"
 	   "};\n"
 	   "extern void init_all_optabs (struct target_optabs *);\n"
-	   "extern bool partial_vectors_supported_p (void);\n"
 	   "\n"
 	   "extern struct target_optabs default_target_optabs;\n"
 	   "extern struct target_optabs *this_fn_optabs;\n"
@@ -373,33 +372,6 @@ main (int argc, const char **argv)
     fprintf (s_file, "  ena[%u] = HAVE_%s;\n", i, p->name);
   fprintf (s_file, "}\n\n");
 
-  fprintf (s_file,
-	   "/* Returns TRUE if the target supports any of the partial vector\n"
-	   "   optabs: while_ult_optab, len_load_optab or len_store_optab,\n"
-	   "   for any mode.  */\n"
-	   "bool\npartial_vectors_supported_p (void)\n{\n");
-  bool any_match = false;
-  fprintf (s_file, "\treturn");
-  bool first = true;
-  for (i = 0; patterns.iterate (i, &p); ++i)
-    {
-#define CMP_NAME(N) !strncmp (p->name, (N), strlen ((N)))
-      if (CMP_NAME("while_ult") || CMP_NAME ("len_load")
-	  || CMP_NAME ("len_store"))
-	{
-	  if (first)
-	    fprintf (s_file, " HAVE_%s", p->name);
-	  else
-	    fprintf (s_file, " || HAVE_%s", p->name);
-	  first = false;
-	  any_match = true;
-	}
-    }
-  if (!any_match)
-    fprintf (s_file, " false");
-  fprintf (s_file, ";\n}\n");
-
-
   /* Perform a binary search on a pre-encoded optab+mode*2.  */
   /* ??? Perhaps even better to generate a minimal perfect hash.
      Using gperf directly is awkward since it's so geared to working
diff --git a/gcc/testsuite/gcc.target/aarch64/masked_epilogue.c b/gcc/testsuite/gcc.target/aarch64/masked_epilogue.c
deleted file mode 100644
index 286a7be236f..00000000000
--- a/gcc/testsuite/gcc.target/aarch64/masked_epilogue.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O2 -ftree-vectorize -fdump-tree-vect-details -march=armv8-a+sve -msve-vector-bits=scalable" } */
-
-void f(unsigned char y[restrict],
-       unsigned char x[restrict], int n) {
-  for (int i = 0; i < n; ++i)
-    y[i] = (y[i] + x[i] + 1) >> 1;
-}
-
-/* { dg-final { scan-tree-dump {LOOP EPILOGUE VECTORIZED \(MODE=VNx} "vect" } } */
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 6ed2b5f8724..77f1cc0f788 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -2936,6 +2936,8 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)
   machine_mode autodetected_vector_mode = VOIDmode;
   opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);
   unsigned int mode_i = 0;
+  unsigned int first_loop_i = 0;
+  unsigned int first_loop_next_i = 0;
   unsigned HOST_WIDE_INT simdlen = loop->simdlen;
 
   /* First determine the main loop vectorization mode, either the first
@@ -2944,6 +2946,7 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)
      lowest cost if pick_lowest_cost_p.  */
   while (1)
     {
+      unsigned int loop_vinfo_i = mode_i;
       bool fatal;
       opt_loop_vec_info loop_vinfo
 	= vect_analyze_loop_1 (loop, shared, &loop_form_info,
@@ -2972,7 +2975,11 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)
 	      first_loop_vinfo = opt_loop_vec_info::success (NULL);
 	    }
 	  if (first_loop_vinfo == NULL)
-	    first_loop_vinfo = loop_vinfo;
+	    {
+	      first_loop_vinfo = loop_vinfo;
+	      first_loop_i = loop_vinfo_i;
+	      first_loop_next_i = mode_i;
+	    }
 	  else
 	    {
 	      delete loop_vinfo;
@@ -3018,37 +3025,32 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)
   /* Now analyze first_loop_vinfo for epilogue vectorization.  */
   poly_uint64 lowest_th = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);
 
-  /* For epilogues start the analysis from the first mode.  The motivation
-     behind starting from the beginning comes from cases where the VECTOR_MODES
-     array may contain length-agnostic and length-specific modes.  Their
-     ordering is not guaranteed, so we could end up picking a mode for the main
-     loop that is after the epilogue's optimal mode.  */
-  mode_i = 1;
-  bool supports_partial_vectors = partial_vectors_supported_p ();
-  poly_uint64 first_vinfo_vf = LOOP_VINFO_VECT_FACTOR (first_loop_vinfo);
-
-  while (1)
+  /* Handle the case that the original loop can use partial
+     vectorization, but want to only adopt it for the epilogue.
+     The retry should be in the same mode as original.  */
+  if (LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (first_loop_vinfo))
     {
-      /* If the target does not support partial vectors we can shorten the
-	 number of modes to analyze for the epilogue as we know we can't pick a
-	 mode that has at least as many NUNITS as the main loop's vectorization
-	 factor, since that would imply the epilogue's vectorization factor
-	 would be at least as high as the main loop's and we would be
-	 vectorizing for more scalar iterations than there would be left.  */
-      if (!supports_partial_vectors
-	  && maybe_ge (GET_MODE_NUNITS (vector_modes[mode_i]), first_vinfo_vf))
-	{
-	  mode_i++;
-	  if (mode_i == vector_modes.length ())
-	    break;
-	  continue;
-	}
-
+      gcc_assert (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (first_loop_vinfo)
+		  && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (first_loop_vinfo));
       if (dump_enabled_p ())
 	dump_printf_loc (MSG_NOTE, vect_location,
-			 "***** Re-trying epilogue analysis with vector "
-			 "mode %s\n", GET_MODE_NAME (vector_modes[mode_i]));
+			 "***** Re-trying analysis with same vector mode"
+			 " %s for epilogue with partial vectors.\n",
+			 GET_MODE_NAME (first_loop_vinfo->vector_mode));
+      mode_i = first_loop_i;
+    }
+  else
+    {
+      mode_i = first_loop_next_i;
+      if (mode_i == vector_modes.length ())
+	return first_loop_vinfo;
+    }
 
+  /* ???  If first_loop_vinfo was using VOIDmode then we probably
+     want to instead search for the corresponding mode in vector_modes[].  */
+
+  while (1)
+    {
       bool fatal;
       opt_loop_vec_info loop_vinfo
 	= vect_analyze_loop_1 (loop, shared, &loop_form_info,
@@ -3100,6 +3102,11 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)
       if (mode_i == vector_modes.length ())
 	break;
 
+      /* Try the next biggest vector size.  */
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_NOTE, vect_location,
+			 "***** Re-trying epilogue analysis with vector "
+			 "mode %s\n", GET_MODE_NAME (vector_modes[mode_i]));
     }
 
   if (!first_loop_vinfo->epilogue_vinfos.is_empty ())
diff --git a/gcc/tree-vectorizer.c b/gcc/tree-vectorizer.c
index 48eed40cae2..e82750c29da 100644
--- a/gcc/tree-vectorizer.c
+++ b/gcc/tree-vectorizer.c
@@ -1887,13 +1887,11 @@ vector_costs::better_epilogue_loop_than_p (const vector_costs *other,
     {
       unsigned HOST_WIDE_INT main_vf_max
 	= estimated_poly_value (main_poly_vf, POLY_VALUE_MAX);
-      unsigned HOST_WIDE_INT other_vf_max
-	= estimated_poly_value (other_vf, POLY_VALUE_MAX);
-      unsigned HOST_WIDE_INT this_vf_max
-	= estimated_poly_value (this_vf, POLY_VALUE_MAX);
 
-      other_factor = CEIL (main_vf_max, other_vf_max);
-      this_factor = CEIL (main_vf_max, this_vf_max);
+      other_factor = main_vf_max / estimated_poly_value (other_vf,
+						       POLY_VALUE_MAX);
+      this_factor = main_vf_max / estimated_poly_value (this_vf,
+						       POLY_VALUE_MAX);
 
       /* If the loop is not using partial vectors then it will iterate one
 	 time less than one that does.  It is safe to subtract one here,
