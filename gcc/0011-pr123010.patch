diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index 3fe0ad0ccdf4..3e22d91c1e74 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -3065,6 +3065,20 @@ (define_insn "*lshrsi3_zero_extend_3"
   [(set_attr "type" "shift")
    (set_attr "mode" "SI")])
 
+;; Take advantage the implicit sign extension done by sllw when
+;; the number of bits extracted + shift count == 32
+(define_insn "sign_extract_vis_slliw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(ashift:DI
+	  (sign_extract:DI (match_operand:GPR 1 "register_operand" "r")
+			   (match_operand 2 "const_int_operand")
+			   (const_int 0))
+	  (match_operand 3 "const_int_operand")))]
+  "(TARGET_64BIT && INTVAL (operands[2]) + INTVAL (operands[3]) == 32)"
+  "slliw %0,%1,%3"
+  [(set_attr "type" "shift")
+   (set_attr "mode" "SI")])
+
 ;; Canonical form for a extend of a logical shift right (sign/zero extraction).
 ;; Special cases, that are ignored (handled elsewhere):
 ;; * Single-bit extraction (Zbs/XTheadBs)
diff --git a/gcc/testsuite/gcc.target/riscv/pr123010.c b/gcc/testsuite/gcc.target/riscv/pr123010.c
new file mode 100644
index 000000000000..f7fe5a4484d6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr123010.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target rv64 } } */
+/* { dg-options "-O3 -march=rv64gc -mabi=lp64" { target rv64 } } */
+#include <stdint-gcc.h>
+
+#define N 2
+
+uint32_t mulu(uint32_t a) {
+    return a * N;
+}
+
+int32_t muls(int32_t a) {
+    return a * N;
+}
+
+/* { dg-final { scan-assembler-times "slliw\t" 2 { target rv64 } } } */
+/* { dg-final { scan-assembler-not "sr\[al\]i\t" } } */
+
