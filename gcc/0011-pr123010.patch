diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index 3fe0ad0ccdf4..20f5d65fde16 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -3072,13 +3072,13 @@ (define_insn "*lshrsi3_zero_extend_3"
 ;; * Single-bit extraction (SFB)
 ;; * Extraction instruction th.ext(u) (XTheadBb)
 ;; * lshrsi3_extend_2 (see above)
-(define_insn_and_split "*<any_extract:optab><GPR:mode>3"
-  [(set (match_operand:GPR 0 "register_operand" "=r")
+(define_split
+  [(set (match_operand:GPR 0 "register_operand")
 	 (any_extract:GPR
-       (match_operand:GPR 1 "register_operand" " r")
+       (match_operand:GPR 1 "register_operand")
        (match_operand     2 "const_int_operand")
        (match_operand     3 "const_int_operand")))
-   (clobber (match_scratch:GPR  4 "=&r"))]
+   (clobber (match_operand:GPR  4 "register_operand"))]
   "!((TARGET_ZBS || TARGET_XTHEADBS || TARGET_ZICOND
       || TARGET_XVENTANACONDOPS || TARGET_SFB_ALU)
      && (INTVAL (operands[2]) == 1))
@@ -3087,8 +3087,6 @@ (define_insn_and_split "*<any_extract:optab><GPR:mode>3"
    && !(TARGET_64BIT
         && (INTVAL (operands[3]) > 0)
         && (INTVAL (operands[2]) + INTVAL (operands[3]) == 32))"
-  "#"
-  "&& reload_completed"
   [(set (match_dup 4)
      (ashift:GPR (match_dup 1) (match_dup 2)))
    (set (match_dup 0)
@@ -3101,9 +3099,7 @@ (define_insn_and_split "*<any_extract:optab><GPR:mode>3"
   int rshamt = lshamt + startbits;
   operands[2] = GEN_INT (lshamt);
   operands[3] = GEN_INT (rshamt);
-}
-  [(set_attr "type" "shift")
-   (set_attr "mode" "<GPR:MODE>")])
+})
 
 ;; Handle AND with 2^N-1 for N from 12 to XLEN.  This can be split into
 ;; two logical shifts.  Otherwise it requires 3 instructions: lui,
diff --git a/gcc/testsuite/gcc.target/riscv/pr123010.c b/gcc/testsuite/gcc.target/riscv/pr123010.c
new file mode 100644
index 000000000000..f7fe5a4484d6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr123010.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target rv64 } } */
+/* { dg-options "-O3 -march=rv64gc -mabi=lp64" { target rv64 } } */
+#include <stdint-gcc.h>
+
+#define N 2
+
+uint32_t mulu(uint32_t a) {
+    return a * N;
+}
+
+int32_t muls(int32_t a) {
+    return a * N;
+}
+
+/* { dg-final { scan-assembler-times "slliw\t" 2 { target rv64 } } } */
+/* { dg-final { scan-assembler-not "sr\[al\]i\t" } } */
+
