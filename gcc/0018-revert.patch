commit 0b2ef63b5897872e47b8157b04241660d7cb3cde
Author: Jeff Law <jlaw@ventanamicro.com>
Date:   Sun Oct 20 09:31:44 2024 -0600

    Revert "[PATCH 7/7] RISC-V: Disable by pieces for vector setmem length > UNITS_PER_WORD"
    
    This reverts commit 72ceddbfb78dbb95f0808c3eca1765e8cd48b023.

diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index 333e8c3150e..d1467ed594e 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -12742,22 +12742,6 @@ riscv_stack_clash_protection_alloca_probe_range (void)
   return STACK_CLASH_CALLER_GUARD;
 }
 
-static bool
-riscv_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,
-				      unsigned alignment,
-				      enum by_pieces_operation op, bool speed_p)
-{
-  /* For set/clear with size > UNITS_PER_WORD, by pieces uses vector broadcasts
-     with UNITS_PER_WORD size pieces.  Use setmem<mode> instead which can use
-     bigger chunks.  */
-  if (TARGET_VECTOR && stringop_strategy & STRATEGY_VECTOR
-      && (op == CLEAR_BY_PIECES || op == SET_BY_PIECES)
-      && speed_p && size > UNITS_PER_WORD)
-    return false;
-
-  return default_use_by_pieces_infrastructure_p (size, alignment, op, speed_p);
-}
-
 /* Generate instruction sequence
    which reflects the value of the OP using bswap and brev8 instructions.
    OP's mode may be less than word_mode, to get the correct number,
@@ -13284,9 +13268,6 @@ expand_reversed_crc_using_clmul (scalar_mode crc_mode, scalar_mode data_mode,
 #undef TARGET_C_MODE_FOR_FLOATING_TYPE
 #define TARGET_C_MODE_FOR_FLOATING_TYPE riscv_c_mode_for_floating_type
 
-#undef TARGET_USE_BY_PIECES_INFRASTRUCTURE_P
-#define TARGET_USE_BY_PIECES_INFRASTRUCTURE_P riscv_use_by_pieces_infrastructure_p
-
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-riscv.h"
diff --git a/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c b/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c
index f86084bdb40..d1c118c02d6 100644
--- a/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c
+++ b/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c
@@ -51,5 +51,4 @@ void p(int buf, __builtin_va_list ab, int q) {
  } while (k);
 }
 
-/* { dg-final { scan-assembler-times {vsetivli\tzero,\s*4,\s*e8,\s*mf4,\s*t[au],\s*m[au]} 1 } } */
-/* { dg-final { scan-assembler-times {vsetivli\tzero,\s*8,\s*e8,\s*mf2,\s*t[au],\s*m[au]} 1 } } */
+/* { dg-final { scan-assembler-times {vsetivli\tzero,\s*4,\s*e8,\s*mf4,\s*t[au],\s*m[au]} 2 } } */
diff --git a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c
index 838fbebadff..faea442a4bd 100644
--- a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c
+++ b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c
@@ -5,17 +5,15 @@
 
 #define MIN_VECTOR_BYTES (__riscv_v_min_vlen / 8)
 
-/* Vectorise with no loop.
+/* Small memsets shouldn't be vectorised.
 ** f1:
 **  (
-**  vsetivli\s+zero,\d+,e8,m1,ta,ma
+**  sb\s+a1,0\(a0\)
+**  ...
 **  |
-**  li\s+a\d+,\d+
-**  vsetvli\s+zero,a\d+,e8,m1,ta,ma
+**  li\s+a2,\d+
+**  tail\s+memset
 **  )
-**  vmv\.v\.x\s+v\d+,a1
-**  vse8\.v\s+v\d+,0\(a0\)
-**  ret
 */
 void *
 f1 (void *a, int const b)
diff --git a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c
index 02de9a94cc4..25be694d248 100644
--- a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c
+++ b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c
@@ -5,17 +5,15 @@
 
 #define MIN_VECTOR_BYTES (__riscv_v_min_vlen / 8)
 
-/* Vectorise with no loop.
+/* Small memsets shouldn't be vectorised.
 ** f1:
 **  (
-**  vsetivli\s+zero,\d+,e8,m1,ta,ma
+**  sb\s+a1,0\(a0\)
+**  ...
 **  |
-**  li\s+a\d+,\d+
-**  vsetvli\s+zero,a\d+,e8,m1,ta,ma
+**  li\s+a2,\d+
+**  tail\s+memset
 **  )
-**  vmv\.v\.x\s+v\d+,a1
-**  vse8\.v\s+v\d+,0\(a0\)
-**  ret
 */
 void *
 f1 (void *a, int const b)
