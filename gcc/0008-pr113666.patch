diff --git a/gcc/match.pd b/gcc/match.pd
index 492d88514fce..274d64c98ac1 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -12196,3 +12196,10 @@ and,
         && TYPE_UNSIGNED (type)
         && @0 == @3)
     (bit_xor (rrotate @0 @4) @2)))
+
+/* Optimize extraction from a uniform vector to a representative element as
+   long as the requested element is within range.  */
+(simplify (IFN_VEC_EXTRACT @0 INTEGER_CST@1)
+ (if (uniform_vector_p (@0)
+      && known_lt (tree_to_uhwi (@1), TYPE_VECTOR_SUBPARTS (TREE_TYPE (@0))))
+  { uniform_vector_p (@0); }))
diff --git a/gcc/testsuite/gcc.target/riscv/rvv/base/pr113666.c b/gcc/testsuite/gcc.target/riscv/rvv/base/pr113666.c
new file mode 100644
index 000000000000..b1034d7676d0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/rvv/base/pr113666.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-march=rv64gcv -mabi=lp64 -O3" { target rv64} } */
+/* { dg-options "-march=rv32gcv -mabi=ilp32 -O3" { target rv32} } */
+
+unsigned char a;
+
+int main() {
+  short b = a = 0;
+  for (; a != 19; a++)
+    if (a)
+      b = 32872 >> a;
+
+  if (b == 0)
+    return 0;
+  else
+    return 1;
+}
+
+/* If we vectorized, we should still be able to collapse away the VEC_EXTRACT,
+   leaving zero vector code in the final assembly.  So there should be no 
+   vsetvl instructions.  */
+/* { dg-final { scan-assembler-not {vsetivli} } } */
+
+
