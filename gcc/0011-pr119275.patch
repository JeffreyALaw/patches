diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index e394cac7d417..e9217dcb0433 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -3685,7 +3685,8 @@ riscv_legitimize_move (machine_mode mode, rtx dest, rtx src)
       /* This test can fail if (for example) we want a HF and Z[v]fh is
 	 not enabled.  In that case we just want to let the standard
 	 expansion path run.  */
-      if (riscv_vector::get_vector_mode (smode, nunits).exists (&vmode))
+      if (riscv_vector::get_vector_mode (smode, nunits).exists (&vmode)
+	  && gen_lowpart_common (vmode, SUBREG_REG (src)))
 	{
 	  rtx v = gen_lowpart (vmode, SUBREG_REG (src));
 	  rtx int_reg = dest;
diff --git a/gcc/testsuite/gcc.target/riscv/pr119275.c b/gcc/testsuite/gcc.target/riscv/pr119275.c
new file mode 100644
index 000000000000..02a1a7bebd23
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr119275.c
@@ -0,0 +1,26 @@
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-march=rv64gv -mabi=lp64d -mrvv-vector-bits=zvl" { target { rv64 } } } */
+
+__int128 h, j;
+int y;
+double d;
+void *p;
+char *q;
+char x;
+long u;
+
+char *bar(int, int);
+
+typedef __attribute__((__vector_size__ (2))) char V;
+
+void
+foo(V v)
+{
+  x += *bar (0, 0);
+  for(;;) {
+    __builtin_strcat (p, 7 + q);
+    d += __builtin_stdc_rotate_left (
+        (unsigned __int128) u | h << *__builtin_strcat (p, 7 + q), j);
+    u += (long) __builtin_memmove (&y, &v, 2);
+  }
+}
