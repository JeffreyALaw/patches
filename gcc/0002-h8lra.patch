diff --git a/gcc/config/h8300/testcompare.md b/gcc/config/h8300/testcompare.md
index 81dce1d0bc1..b8b952717fa 100644
--- a/gcc/config/h8300/testcompare.md
+++ b/gcc/config/h8300/testcompare.md
@@ -171,16 +171,29 @@
    (set_attr "length_table" "*,add")])
 
 ;; Convert a memory comparison to a move if there is a scratch register.
+;; This is preferred over the next as we can proactively avoid the
+;; comparison.
+(define_peephole2
+  [(match_scratch:QHSI 1 "r")
+   (set (reg:CC CC_REG)
+	(compare (match_operand:QHSI 0 "memory_operand" "")
+		 (const_int 0)))]
+  "!mode_dependent_address_p (XEXP (operands[0], 0), MEM_ADDR_SPACE (operands[0]))"
+  [(parallel [(set (reg:CCZN CC_REG) (compare:CCZN (match_dup 0) (const_int 0)))
+	      (set (match_dup 1) (match_dup 0))])])
 
+;; Similarly, but used when the memory reference is an autoinc address
+;; mode.
 (define_peephole2
   [(match_scratch:QHSI 1 "r")
    (set (reg:CC CC_REG)
 	(compare (match_operand:QHSI 0 "memory_operand" "")
 		 (const_int 0)))]
-  ""
+  "mode_dependent_address_p (XEXP (operands[0], 0), MEM_ADDR_SPACE (operands[0]))"
   [(parallel [(set (match_dup 1) (match_dup 0)) (clobber (reg:CC CC_REG))])
           (set (reg:CC CC_REG) (compare:CC (match_dup 1) (const_int 0)))])
 
+
 ;; The compare-elimination pass does not handle memory reference.  So this
 ;; little peephole helps fill the gap and avoid code quality regressions.
 (define_peephole2
