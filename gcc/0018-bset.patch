diff --git a/gcc/config/riscv/bitmanip.md b/gcc/config/riscv/bitmanip.md
index 0d35fb786e1..c6bd55c53f9 100644
--- a/gcc/config/riscv/bitmanip.md
+++ b/gcc/config/riscv/bitmanip.md
@@ -642,6 +654,18 @@ (define_split
      (any_or:DI (ashift:DI (const_int 1) (match_dup 1))
 		(match_dup 3)))])
 
+;; Yet another form of a bset/bclr that can be created by combine.
+(define_insn "*bsetclr_zero_extract"
+  [(set (zero_extract:X (match_operand:X 0 "register_operand" "+r")
+			(const_int 1)
+			(zero_extend:X (match_operand:QI 1 "register_operand" "r")))
+	(match_operand 2 "immediate_operand" "n"))]
+  "TARGET_ZBS
+   && (operands[2] == CONST0_RTX (<MODE>mode)
+       || operands[2] == CONST1_RTX (<MODE>mode))"
+  { return operands[2] == CONST0_RTX (<MODE>mode) ? "bclr\t%0,%0,%1" : "bset\t%0,%0,%1"; }
+  [(set_attr "type" "bitmanip")])
+
 (define_insn "*bclr<mode>"
   [(set (match_operand:X 0 "register_operand" "=r")
 	(and:X (rotate:X (const_int -2)
diff --git a/gcc/testsuite/gcc.target/riscv/zbs-zext-3.c b/gcc/testsuite/gcc.target/riscv/zbs-zext-3.c
new file mode 100644
index 00000000000..4fa33f681d8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/zbs-zext-3.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-march=rv64gc_zba_zbb_zbs" { target { rv64 } } } */
+/* { dg-options "-march=rv64gc_zba_zbb_zbs" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+
+/* We need to adjust the constant so this works for rv32 and rv64.  */
+#if __riscv_xlen == 32
+#define ONE 1U
+#else
+#define ONE 1ULL
+#endif
+
+void add_to_hard_reg_set(long long *a, unsigned int count) {
+  int i = 0;
+  while(i++ < count)
+    *a |= (1U << i);
+}
+
+void remove_from_hard_reg_set(long long *a, unsigned int count) {
+  int i = 0;
+  while(i++ < count)
+    *a &= ~(ONE << i);
+}
+
+
+/* { dg-final { scan-assembler-not "and\t" } } */
+/* { dg-final { scan-assembler-not "andn\t" } } */
