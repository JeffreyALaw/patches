diff --git a/gcc/config/h8300/addsub.md b/gcc/config/h8300/addsub.md
index b1eb0d20188..32eba9df67a 100644
--- a/gcc/config/h8300/addsub.md
+++ b/gcc/config/h8300/addsub.md
@@ -239,3 +239,80 @@ (define_insn "*negsf2_clobber_flags"
   "reload_completed"
   "xor.w\\t#32768,%e0"
   [(set_attr "length" "4")])
+
+(define_expand "uaddv<mode>4"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(plus:QHSI (match_operand:QHSI 1 "register_operand" "")
+		   (match_operand:QHSI 2 "register_operand" "")))
+   (set (pc)
+	(if_then_else (ltu (match_dup 0) (match_dup 1))
+		      (label_ref (match_operand 3 ""))
+		      (pc)))]
+  "")
+
+(define_insn_and_split "*uaddv"
+  [(set (match_operand:QHSI2 3 "register_operand" "=&r")
+	(ltu:QHSI2 (plus:QHSI (match_operand:QHSI 1 "register_operand" "%0")
+			   (match_operand:QHSI 2 "register_operand" "r"))
+		(match_dup 1)))
+   (set (match_operand:QHSI 0 "register_operand" "=r")
+	(plus:QHSI (match_dup 1) (match_dup 2)))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 3) (ltu:QHSI2 (plus:QHSI (match_dup 1) (match_dup 2))
+					  (match_dup 1)))
+	      (set (match_dup 0) (plus:QHSI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*uaddv"
+  [(set (match_operand:QHSI2 3 "register_operand" "=&r")
+	(ltu:QHSI2 (plus:QHSI (match_operand:QHSI 1 "register_operand" "%0")
+			     (match_operand:QHSI 2 "register_operand" "r"))
+		(match_dup 1)))
+   (set (match_operand:QHSI 0 "register_operand" "=r")
+	(plus (match_dup 1) (match_dup 2)))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  if (E_<QHSI2:MODE>mode == E_QImode)
+    {
+      if (E_<QHSI:MODE>mode == E_QImode)
+	return "sub.b\t%X3,%X3\;add.b\t%X2,%X0\;addx\t%X3,%X3";
+      else if (E_<QHSI:MODE>mode == E_HImode)
+	return "sub.b\t%X3,%X3\;add.w\t%T2,%T0\;addx\t%X3,%X3";
+      else if (E_<QHSI:MODE>mode == E_SImode)
+	return "sub.b\t%X3,%X3\;add.l\t%S2,%S0\;addx\t%X3,%X3";
+    }
+  else if (E_<QHSI2:MODE>mode == E_HImode)
+    {
+      if (E_<QHSI:MODE>mode == E_QImode)
+	return "sub.w\t%T3,%T3\;add.b\t%X2,%X0\;addx\t%X3,%X3";
+      else if (E_<QHSI:MODE>mode == E_HImode)
+	return "sub.w\t%T3,%T3\;add.w\t%T2,%T0\;addx\t%X3,%X3";
+      else if (E_<QHSI:MODE>mode == E_SImode)
+	return "sub.w\t%T3,%T3\;add.l\t%S2,%S0\;addx\t%X3,%X3";
+    }
+  else if (E_<QHSI2:MODE>mode == E_SImode)
+    {
+      if (E_<QHSI:MODE>mode == E_QImode)
+	return "sub.l\t%S3,%S3\;add.b\t%X2,%X0\;addx\t%X3,%X3";
+      else if (E_<QHSI:MODE>mode == E_HImode)
+	return "sub.l\t%S3,%S3\;add.w\t%T2,%T0\;addx\t%X3,%X3";
+      else if (E_<QHSI:MODE>mode == E_SImode)
+	return "sub.l\t%S3,%S3\;add.l\t%S2,%S0\;addx\t%X3,%X3";
+    }
+  else
+    gcc_unreachable ();
+}
+  [(set_attr "length" "6")])
+
+(define_expand "usubv<mode>4"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(minus:QHSI (match_operand:QHSI 1 "register_operand" "")
+		    (match_operand:QHSI 2 "register_operand" "")))
+   (set (pc)
+	(if_then_else (ltu (match_dup 1) (match_dup 2))
+		      (label_ref (match_operand 3 ""))
+		      (pc)))]
+  "")
diff --git a/gcc/config/h8300/logical.md b/gcc/config/h8300/logical.md
index 5df0922ef4e..5e3181fb234 100644
--- a/gcc/config/h8300/logical.md
+++ b/gcc/config/h8300/logical.md
@@ -121,7 +121,7 @@ (define_insn "*andor<mode>3_clobber_flags"
       }
 
     gcc_unreachable ();
-	
+
   }
   [(set_attr "length" "6")])
 
@@ -194,7 +194,7 @@ (define_insn "*<code>qi3_1<cczn>"
 		     (match_operand:QI 2 "h8300_src_operand" "rn")))
    (clobber (reg:CC CC_REG))]
   ""
-  { 
+  {
     if (<CODE> == IOR)
       return "or\\t%X2,%X0";
     else if (<CODE> == XOR)
@@ -261,6 +261,39 @@ (define_insn "one_cmpl<mode>2_<cczn>"
   }
   [(set_attr "length_table" "unary")])
 
+;; A logical operation that feeds into a left shift by 31
+;; can be done on just the high half, then rotated into
+;; position.  This saves 2 bytes of instruction space.
+(define_insn_and_split ""
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lshiftrt:SI (logicals:SI (match_operand:SI 1 "register_operand" "0")
+			          (match_operand:SI 2 "register_operand" "r"))
+		     (const_int 31)))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 0)
+		  (lshiftrt:SI (logicals:SI (match_dup 1) (match_dup 2))
+			       (const_int 31)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lshiftrt:SI (logicals:SI (match_operand:SI 1 "register_operand" "0")
+				  (match_operand:SI 2 "register_operand" "r"))
+		     (const_int 31)))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed"
+  {
+    if (<CODE> == IOR)
+      return "or.w\\t%f2,%f0\;rotxl.l\\t%0\;xor.l\t%0,%0\;rotxl.l\t%0";
+    else if (<CODE> == XOR)
+      return "xor.w\\t%f2,%f0\;rotxl.l\\t%0\;xor.l\t%0,%0\;rotxl.l\t%0";
+    else if (<CODE> == AND)
+      return "and.w\\t%f2,%f0\;rotxl.l\\t%0\;xor.l\t%0,%0\;rotxl.l\t%0";
+  }
+  [(set_attr "length" "10")])
+
 ;; The next four peephole2's will try to transform
 ;;
 ;;   mov.b A,r0l    (or mov.l A,er0)
