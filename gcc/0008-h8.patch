diff --git a/gcc/config/h8300/h8300.cc b/gcc/config/h8300/h8300.cc
index 78cf15f15c7..a54e9a45cb0 100644
--- a/gcc/config/h8300/h8300.cc
+++ b/gcc/config/h8300/h8300.cc
@@ -5385,15 +5385,20 @@ h8300_move_ok (rtx dest, rtx src)
   else
     return true;
 
-  /* Validate that auto-inc doesn't affect OTHER.  */
-  if (GET_RTX_CLASS (GET_CODE (addr)) != RTX_AUTOINC)
-    return true;
-  addr = XEXP (addr, 0);
+  /* We used to enforce the rules WRT autoinc operands not
+     being valid as source operands elsewhere in the same
+     insn.
 
-  if (addr == stack_pointer_rtx)
-    return register_no_sp_elim_operand (other, VOIDmode);
-  else
-    return !reg_overlap_mentioned_p(other, addr);
+     But neither reload nor LRA correctly handle the case
+     where we push a pseudo and after register elimination
+     the pseudo is equivalent to the stack pointer.
+
+     The "obvious" semantics in that case is that the SP
+     source operand has the value before the push and
+     those match the behavior of the H8.
+
+     So while technically invalid, we allow it.  */
+  return true;
 }
 
 /* Perform target dependent optabs initialization.  */
