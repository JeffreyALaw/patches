diff --git a/gcc/simplify-rtx.cc b/gcc/simplify-rtx.cc
index c4de035b44fd..b9591eb6bb71 100644
--- a/gcc/simplify-rtx.cc
+++ b/gcc/simplify-rtx.cc
@@ -3673,6 +3673,63 @@ simplify_context::simplify_binary_operation_1 (rtx_code code,
 	  && GET_MODE_CLASS (mode) != MODE_CC)
 	return CONSTM1_RTX (mode);
 
+      /* IOR of two single bit bitfields extracted from the same object.
+	 Bitfields are represented as an AND based extraction */
+      if (GET_CODE (op0) == AND
+	  && GET_CODE (op1) == AND
+	  /* Verify both AND operands are logical right shifts. */
+	  && GET_CODE (XEXP (op0, 0)) == LSHIFTRT
+	  && GET_CODE (XEXP (op1, 0)) == LSHIFTRT
+	  /* Verify both bitfields are extracted from the same object. */
+	  && XEXP (XEXP (op0, 0), 0) == XEXP (XEXP (op1, 0), 0)
+	  /* Verify both fields are a single bit (could be generalized). */
+	  && XEXP (op0, 1) == CONST1_RTX (mode)
+	  && XEXP (op1, 1) == CONST1_RTX (mode)
+	  /* Verify bit positions (for cases with variable bit position). */
+	  && CONST_INT_P (XEXP (op0, 1))
+	  && CONST_INT_P (XEXP (op1, 1)))
+	{
+	  unsigned HOST_WIDE_INT bitpos1 = INTVAL (XEXP (XEXP (op0, 0), 1));
+	  unsigned HOST_WIDE_INT bitpos2 = INTVAL (XEXP (XEXP (op1, 0), 1));
+	  unsigned HOST_WIDE_INT mask
+	    = (HOST_WIDE_INT_1U << bitpos1) | (HOST_WIDE_INT_1U << bitpos2);
+
+	  rtx m = GEN_INT (mask);
+	  rtx t = gen_rtx_AND (mode, XEXP (XEXP (op0, 0), 0), m);
+	  t = gen_rtx_NE (mode, t, CONST0_RTX (mode));
+	  return t;
+	}
+
+      /* IOR of multiple single bit bitfields extracted from the same object
+	 (building on previous case).
+	 First bitfield is represented as an AND based extraction, as done
+		above. Second represented as NE based extraction, from
+		output above. */
+      if (GET_CODE (op0) == AND
+	  && GET_CODE (op1) == NE
+	  /* Verify AND operand is logical right shift. */
+	  && GET_CODE (XEXP (op0, 0)) == LSHIFTRT
+	  /* Verify NE operand is an AND (based on output above). */
+	  && GET_CODE (XEXP (op1, 0)) == AND
+	  /* Verify both bitfields are extracted from the same object. */
+	  && XEXP (XEXP (op0, 0), 0) == XEXP (XEXP (op1, 0), 0)
+	  /* Verify masking is with a single bit and that we have a NE 0
+	     comparison for the other operand.  */
+	  && XEXP (op0, 1) == CONST1_RTX (mode)
+	  && XEXP (op1, 1) == CONST0_RTX (mode)
+	  /* Verify bit position. */
+	  && CONST_INT_P (XEXP (op0, 1)))
+	{
+	  unsigned HOST_WIDE_INT bitpos1 = INTVAL (XEXP (XEXP (op0, 0), 1));
+	  unsigned HOST_WIDE_INT mask
+	    = (HOST_WIDE_INT_1U << bitpos1) | INTVAL (XEXP (XEXP (op1, 0), 1));
+
+	  rtx m = GEN_INT (mask);
+	  rtx t = gen_rtx_AND (mode, XEXP (XEXP (op0, 0), 0), m);
+	  t = gen_rtx_NE (mode, t, CONST0_RTX (mode));
+	  return t;
+	}
+
       /* Convert (ior (plus (A - 1)) (neg A)) to -1.  */
       if (match_plus_neg_pattern (op0, op1, mode))
 	return CONSTM1_RTX (mode);
diff --git a/gcc/testsuite/gcc.target/riscv/pr67731.c b/gcc/testsuite/gcc.target/riscv/pr67731.c
new file mode 100644
index 000000000000..5f49ca810fb0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr67731.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=rv64gcbv -mabi=lp64d" { target { rv64 } } } */
+
+typedef struct
+{
+  _Bool a : 1;
+  _Bool b : 1;
+  _Bool c : 1;
+  _Bool d : 1;
+  unsigned int e : 4;
+} S;
+
+_Bool test_00 (S* s)
+{
+  return s->b | s->c;
+}
+
+_Bool test_01 (S* s)
+{
+  return s->b | s->c | s->d;
+}
+/* { dg-final { scan-assembler-times {\tlw\ta0,0\(a0\).*?\n\tandi\ta0,a0,\d+.*?\n\tsnez\ta0,a0.*?\n\tret} 2 } } */
+/* { dg-final { scan-assembler-not {\tor} } } */
+/* { dg-final { scan-assembler-not {\tbexti} } } */
diff --git a/gcc/testsuite/gcc.target/sh/pr67731.c b/gcc/testsuite/gcc.target/sh/pr67731.c
new file mode 100644
index 000000000000..43c16577fa58
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sh/pr67731.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -m4 -ml" } */
+
+typedef struct
+{
+  _Bool a : 1;
+  _Bool b : 1;
+  _Bool c : 1;
+  _Bool d : 1;
+  unsigned int e : 4;
+} S;
+
+_Bool test_00 (S* s)
+{
+  return s->b | s->c;
+}
+
+_Bool test_01 (S* s)
+{
+  return s->b | s->c | s->d;
+}
+
+/* { dg-final { scan-assembler-times {\ttst} 2 } } */
+/* { dg-final { scan-assembler-times {\tnegc} 2 } } */
+/* { dg-final { scan-assembler-not {\tor} } } */
