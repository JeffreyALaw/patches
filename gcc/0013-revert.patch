commit c1dd1ac90d058b56c8d1c86e913e88fc1552d2a3
Author: Jeff Law <jlaw@ventanamicro.com>
Date:   Sat Oct 19 16:52:07 2024 -0600

    Revert "[PATCH 7/7] RISC-V: Disable by pieces for vector setmem length > UNITS_PER_WORD"
    
    This reverts commit 72ceddbfb78dbb95f0808c3eca1765e8cd48b023.

diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index fc2a83b2187..3ac40234345 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -12583,22 +12583,6 @@ riscv_stack_clash_protection_alloca_probe_range (void)
   return STACK_CLASH_CALLER_GUARD;
 }
 
-static bool
-riscv_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,
-				      unsigned alignment,
-				      enum by_pieces_operation op, bool speed_p)
-{
-  /* For set/clear with size > UNITS_PER_WORD, by pieces uses vector broadcasts
-     with UNITS_PER_WORD size pieces.  Use setmem<mode> instead which can use
-     bigger chunks.  */
-  if (TARGET_VECTOR && stringop_strategy & STRATEGY_VECTOR
-      && (op == CLEAR_BY_PIECES || op == SET_BY_PIECES)
-      && speed_p && size > UNITS_PER_WORD)
-    return false;
-
-  return default_use_by_pieces_infrastructure_p (size, alignment, op, speed_p);
-}
-
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
 #define TARGET_ASM_ALIGNED_HI_OP "\t.half\t"
@@ -12964,9 +12948,6 @@ riscv_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,
 #undef TARGET_C_MODE_FOR_FLOATING_TYPE
 #define TARGET_C_MODE_FOR_FLOATING_TYPE riscv_c_mode_for_floating_type
 
-#undef TARGET_USE_BY_PIECES_INFRASTRUCTURE_P
-#define TARGET_USE_BY_PIECES_INFRASTRUCTURE_P riscv_use_by_pieces_infrastructure_p
-
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-riscv.h"
diff --git a/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c b/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c
index f86084bdb40..d1c118c02d6 100644
--- a/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c
+++ b/gcc/testsuite/gcc.target/riscv/rvv/autovec/pr113469.c
@@ -51,5 +51,4 @@ void p(int buf, __builtin_va_list ab, int q) {
  } while (k);
 }
 
-/* { dg-final { scan-assembler-times {vsetivli\tzero,\s*4,\s*e8,\s*mf4,\s*t[au],\s*m[au]} 1 } } */
-/* { dg-final { scan-assembler-times {vsetivli\tzero,\s*8,\s*e8,\s*mf2,\s*t[au],\s*m[au]} 1 } } */
+/* { dg-final { scan-assembler-times {vsetivli\tzero,\s*4,\s*e8,\s*mf4,\s*t[au],\s*m[au]} 2 } } */
diff --git a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c
index 838fbebadff..faea442a4bd 100644
--- a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c
+++ b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-2.c
@@ -5,17 +5,15 @@
 
 #define MIN_VECTOR_BYTES (__riscv_v_min_vlen / 8)
 
-/* Vectorise with no loop.
+/* Small memsets shouldn't be vectorised.
 ** f1:
 **  (
-**  vsetivli\s+zero,\d+,e8,m1,ta,ma
+**  sb\s+a1,0\(a0\)
+**  ...
 **  |
-**  li\s+a\d+,\d+
-**  vsetvli\s+zero,a\d+,e8,m1,ta,ma
+**  li\s+a2,\d+
+**  tail\s+memset
 **  )
-**  vmv\.v\.x\s+v\d+,a1
-**  vse8\.v\s+v\d+,0\(a0\)
-**  ret
 */
 void *
 f1 (void *a, int const b)
diff --git a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c
index 02de9a94cc4..25be694d248 100644
--- a/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c
+++ b/gcc/testsuite/gcc.target/riscv/rvv/base/setmem-3.c
@@ -5,17 +5,15 @@
 
 #define MIN_VECTOR_BYTES (__riscv_v_min_vlen / 8)
 
-/* Vectorise with no loop.
+/* Small memsets shouldn't be vectorised.
 ** f1:
 **  (
-**  vsetivli\s+zero,\d+,e8,m1,ta,ma
+**  sb\s+a1,0\(a0\)
+**  ...
 **  |
-**  li\s+a\d+,\d+
-**  vsetvli\s+zero,a\d+,e8,m1,ta,ma
+**  li\s+a2,\d+
+**  tail\s+memset
 **  )
-**  vmv\.v\.x\s+v\d+,a1
-**  vse8\.v\s+v\d+,0\(a0\)
-**  ret
 */
 void *
 f1 (void *a, int const b)
