commit 12b32ca88282b39d3e94417866b1fd8011cf971e
Author: Jeff Law <jeffreyalaw@gmail.com>
Date:   Thu Feb 15 17:08:36 2024 -0700

    Re-enable inlining of strcmp, strlen and strcpy by default.
    
    Adjust test to correctly handle default to inlining on.
    Adjust strncmp inlining code to reasonably handle count of zero.
    
    (cherry picked from commit 63302a68baf84aef078ce2c5958f191e0b9c727d)

diff --git a/gcc/config/riscv/riscv-string.cc b/gcc/config/riscv/riscv-string.cc
index b09b51d7526..41cb061c746 100644
--- a/gcc/config/riscv/riscv-string.cc
+++ b/gcc/config/riscv/riscv-string.cc
@@ -153,7 +153,7 @@ emit_strcmp_scalar_compare_subword (rtx data1, rtx data2, rtx orc1,
   rtx imask = gen_rtx_CONST_INT (Xmode, im);
   rtx m_reg = gen_reg_rtx (Xmode);
   emit_insn (gen_rtx_SET (m_reg, imask));
-  do_rotr3 (m_reg, m_reg, GEN_INT (64 - cmp_bytes * BITS_PER_UNIT));
+  do_rotr3 (m_reg, m_reg, GEN_INT (BITS_PER_WORD - cmp_bytes * BITS_PER_UNIT));
   do_and3 (data1, m_reg, data1);
   do_and3 (data2, m_reg, data2);
   if (TARGET_ZBB)
@@ -497,6 +497,13 @@ riscv_expand_strcmp (rtx result, rtx src1, rtx src2,
 	return false;
       nbytes = UINTVAL (bytes_rtx);
 
+      /* If NBYTES is zero the result of strncmp will always be zero,
+	 but that would require special casing in the caller.  So for
+	 now just don't do an inline expansion.  This probably rarely
+	 happens in practice, but it is tested by the testsuite.  */
+      if (nbytes == 0)
+	return false;
+
       /* We don't emit parts of a strncmp() call.  */
       if (nbytes > compare_max)
 	return false;
diff --git a/gcc/config/riscv/riscv.opt b/gcc/config/riscv/riscv.opt
index ee824756381..95165e5fa89 100644
--- a/gcc/config/riscv/riscv.opt
+++ b/gcc/config/riscv/riscv.opt
@@ -515,15 +515,15 @@ Target Var(TARGET_INLINE_SUBWORD_ATOMIC) Init(1)
 Always inline subword atomic operations.
 
 minline-strcmp
-Target Var(riscv_inline_strcmp) Init(0)
+Target Var(riscv_inline_strcmp) Init(1)
 Inline strcmp calls if possible.
 
 minline-strncmp
-Target Var(riscv_inline_strncmp) Init(0)
+Target Var(riscv_inline_strncmp) Init(1)
 Inline strncmp calls if possible.
 
 minline-strlen
-Target Var(riscv_inline_strlen) Init(0)
+Target Var(riscv_inline_strlen) Init(1)
 Inline strlen calls if possible.
 
 -param=riscv-strcmp-inline-limit=
diff --git a/gcc/testsuite/gcc.target/riscv/zbb-strlen-disabled-2.c b/gcc/testsuite/gcc.target/riscv/zbb-strlen-disabled-2.c
index a481068aa0c..1295aeb0086 100644
--- a/gcc/testsuite/gcc.target/riscv/zbb-strlen-disabled-2.c
+++ b/gcc/testsuite/gcc.target/riscv/zbb-strlen-disabled-2.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-march=rv32gc_zbb" { target { rv32 } } } */
-/* { dg-options "-march=rv64gc_zbb" { target { rv64 } } } */
+/* { dg-options "-mno-inline-strlen -march=rv32gc_zbb" { target { rv32 } } } */
+/* { dg-options "-mno-inline-strlen -march=rv64gc_zbb" { target { rv64 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-Os" "-Og" "-Oz" } } */
 
 typedef long unsigned int size_t;
