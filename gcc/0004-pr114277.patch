diff --git a/gcc/match.pd b/gcc/match.pd
index 6991868fbe2..d267a0640db 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -58,6 +58,23 @@ along with GCC; see the file COPYING3.  If not see
 
 #include "cfn-operators.pd"
 
+
+/* When multiplying a value by a boolean involving the value, we may
+   be able to simplify further.  
+     a * ((a || b) != 0) -> a 
+     a * ((a || b) == 0) -> 0
+ 
+   There are also bit-and cases which don't show up in practice yet.
+     a * ((a && b) != 0) -> a * b
+     a * ((a && b) == 0) -> b != 0 ? a : b */
+(simplify
+ (mult:c (convert? (ne (bit_ior:c @0 @1) integer_zerop@2)) @0)
+ @0)
+
+(simplify
+ (mult:c (convert? (eq (bit_ior:c @0 @1) integer_zerop@2)) @0)
+  { build_zero_cst (type); })
+  
 /* Define operand lists for math rounding functions {,i,l,ll}FN,
    where the versions prefixed with "i" return an int, those prefixed with
    "l" return a long and those prefixed with "ll" return a long long.
diff --git a/gcc/testsuite/gcc.target/riscv/pr114277.c b/gcc/testsuite/gcc.target/riscv/pr114277.c
new file mode 100644
index 00000000000..9cfe5d4149d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr114277.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=rv64gc_zicond -mabi=lp64d" { target rv64 } } */
+/* { dg-options "-O2 -march=rv32gc_zicond -mabi=ilp32" { target rv32 } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-O3" "-Og" } } */
+
+int a,b;
+void func0(int x){ a=x*(x||b); }
+void func1(int x){ a=x*!(x||b); }
+
+/* { dg-final { scan-assembler-not "czero" } } */
+
