diff --git a/gcc/config/riscv/J b/gcc/config/riscv/J
new file mode 100644
index 000000000000..11ee18d15b60
--- /dev/null
+++ b/gcc/config/riscv/J
@@ -0,0 +1,519 @@
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   1) ;; Machine description for RISC-V atomic operations.
+83ffe9cde7fe0 (Jakub Jelinek   2023-01-16 11:50:43 +0100   2) ;; Copyright (C) 2011-2023 Free Software Foundation, Inc.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   3) ;; Contributed by Andrew Waterman (andrew@sifive.com).
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   4) ;; Based on MIPS target for GNU compiler.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   5) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   6) ;; This file is part of GCC.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   7) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   8) ;; GCC is free software; you can redistribute it and/or modify
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000   9) ;; it under the terms of the GNU General Public License as published by
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  10) ;; the Free Software Foundation; either version 3, or (at your option)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  11) ;; any later version.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  12) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  13) ;; GCC is distributed in the hope that it will be useful,
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  14) ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  15) ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  16) ;; GNU General Public License for more details.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  17) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  18) ;; You should have received a copy of the GNU General Public License
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  19) ;; along with GCC; see the file COPYING3.  If not see
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  20) ;; <http://www.gnu.org/licenses/>.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  21) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  22) (define_c_enum "unspec" [
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  23)   UNSPEC_COMPARE_AND_SWAP
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700  24)   UNSPEC_COMPARE_AND_SWAP_SUBWORD
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  25)   UNSPEC_SYNC_OLD_OP
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700  26)   UNSPEC_SYNC_OLD_OP_SUBWORD
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  27)   UNSPEC_SYNC_EXCHANGE
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700  28)   UNSPEC_SYNC_EXCHANGE_SUBWORD
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  29)   UNSPEC_ATOMIC_STORE
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  30)   UNSPEC_MEMORY_BARRIER
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  31) ])
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  32) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  33) ;; Memory barriers.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  34) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  35) (define_expand "mem_thread_fence"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  36)   [(match_operand:SI 0 "const_int_operand" "")] ;; model
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  37)   ""
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  38) {
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  39)   if (INTVAL (operands[0]) != MEMMODEL_RELAXED)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  40)     {
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  41)       rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  42)       MEM_VOLATILE_P (mem) = 1;
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  43)       emit_insn (gen_mem_thread_fence_1 (mem, operands[0]));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  44)     }
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  45)   DONE;
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  46) })
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  47) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  48) ;; Until the RISC-V memory model (hence its mapping from C++) is finalized,
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  49) ;; conservatively emit a full FENCE.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  50) (define_insn "mem_thread_fence_1"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  51)   [(set (match_operand:BLK 0 "" "")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  52) 	(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  53)    (match_operand:SI 1 "const_int_operand" "")] ;; model
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  54)   ""
+e05a9f8e560a0 (Palmer Dabbelt  2017-03-20 16:43:17 +0000  55)   "fence\tiorw,iorw")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  56) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  57) ;; Atomic memory operations.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  58) 
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  59) ;; Implement atomic stores with conservative fences.  Fall back to fences for
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  60) ;; atomic loads.
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  61) ;; This allows us to be compatible with the ISA manual Table A.6 and Table A.7.
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  62) (define_insn "atomic_store<mode>"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  63)   [(set (match_operand:GPR 0 "memory_operand" "=A")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  64)     (unspec_volatile:GPR
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  65)       [(match_operand:GPR 1 "reg_or_0_operand" "rJ")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  66)        (match_operand:SI 2 "const_int_operand")]      ;; model
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  67)       UNSPEC_ATOMIC_STORE))]
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  68)   "TARGET_ATOMIC"
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  69)   {
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  70)     enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  71)     model = memmodel_base (model);
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  72) 
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  73)     if (model == MEMMODEL_SEQ_CST)
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  74)       return "fence\trw,w\;"
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  75) 	     "s<amo>\t%z1,%0\;"
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  76) 	     "fence\trw,rw";
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  77)     if (model == MEMMODEL_RELEASE)
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  78)       return "fence\trw,w\;"
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  79) 	     "s<amo>\t%z1,%0";
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  80)     else
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  81)       return "s<amo>\t%z1,%0";
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  82)   }
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800  83)   [(set_attr "type" "atomic")
+6a2383f47ae70 (Patrick O'Neill 2023-04-05 09:56:33 -0700  84)    (set (attr "length") (const_int 12))])
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  85) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  86) (define_insn "atomic_<atomic_optab><mode>"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  87)   [(set (match_operand:GPR 0 "memory_operand" "+A")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  88) 	(unspec_volatile:GPR
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  89) 	  [(any_atomic:GPR (match_dup 0)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  90) 		     (match_operand:GPR 1 "reg_or_0_operand" "rJ"))
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  91) 	   (match_operand:SI 2 "const_int_operand")] ;; model
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  92) 	 UNSPEC_SYNC_OLD_OP))]
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  93)   "TARGET_ATOMIC"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  94)   "%F2amo<insn>.<amo>%A2 zero,%z1,%0"
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800  95)   [(set_attr "type" "atomic")
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800  96)    (set (attr "length") (const_int 8))])
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  97) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  98) (define_insn "atomic_fetch_<atomic_optab><mode>"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000  99)   [(set (match_operand:GPR 0 "register_operand" "=&r")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 100) 	(match_operand:GPR 1 "memory_operand" "+A"))
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 101)    (set (match_dup 1)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 102) 	(unspec_volatile:GPR
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 103) 	  [(any_atomic:GPR (match_dup 1)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 104) 		     (match_operand:GPR 2 "reg_or_0_operand" "rJ"))
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 105) 	   (match_operand:SI 3 "const_int_operand")] ;; model
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 106) 	 UNSPEC_SYNC_OLD_OP))]
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 107)   "TARGET_ATOMIC"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 108)   "%F3amo<insn>.<amo>%A3 %0,%z2,%1"
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800 109)   [(set_attr "type" "atomic")
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800 110)    (set (attr "length") (const_int 8))])
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 111) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 112) (define_insn "subword_atomic_fetch_strong_<atomic_optab>"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 113)   [(set (match_operand:SI 0 "register_operand" "=&r")		   ;; old value at mem
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 114) 	(match_operand:SI 1 "memory_operand" "+A"))		   ;; mem location
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 115)    (set (match_dup 1)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 116) 	(unspec_volatile:SI
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 117) 	  [(any_atomic:SI (match_dup 1)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 118) 		     (match_operand:SI 2 "register_operand" "rI")) ;; value for op
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 119) 	   (match_operand:SI 3 "register_operand" "rI")]	   ;; mask
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 120) 	 UNSPEC_SYNC_OLD_OP_SUBWORD))
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 121)     (match_operand:SI 4 "register_operand" "rI")		   ;; not_mask
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 122)     (clobber (match_scratch:SI 5 "=&r"))			   ;; tmp_1
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 123)     (clobber (match_scratch:SI 6 "=&r"))]			   ;; tmp_2
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 124)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 125)   {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 126)     return "1:\;"
+4990cf84c460f (Patrick O'Neill 2023-04-21 13:11:35 -0700 127) 	   "lr.w.aqrl\t%0, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 128) 	   "<insn>\t%5, %0, %2\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 129) 	   "and\t%5, %5, %3\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 130) 	   "and\t%6, %0, %4\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 131) 	   "or\t%6, %6, %5\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 132) 	   "sc.w.rl\t%5, %6, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 133) 	   "bnez\t%5, 1b";
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 134)   }
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 135)   [(set (attr "length") (const_int 28))])
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 136) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 137) (define_expand "atomic_fetch_nand<mode>"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 138)   [(match_operand:SHORT 0 "register_operand")			      ;; old value at mem
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 139)    (not:SHORT (and:SHORT (match_operand:SHORT 1 "memory_operand")     ;; mem location
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 140) 			 (match_operand:SHORT 2 "reg_or_0_operand"))) ;; value for op
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 141)    (match_operand:SI 3 "const_int_operand")]			      ;; model
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 142)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 143) {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 144)   /* We have no QImode/HImode atomics, so form a mask, then use
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 145)      subword_atomic_fetch_strong_nand to implement a LR/SC version of the
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 146)      operation.  */
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 147) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 148)   /* Logic duplicated in gcc/libgcc/config/riscv/atomic.c for use when inlining
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 149)      is disabled.  */
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 150) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 151)   rtx old = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 152)   rtx mem = operands[1];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 153)   rtx value = operands[2];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 154)   rtx aligned_mem = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 155)   rtx shift = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 156)   rtx mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 157)   rtx not_mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 158) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 159)   riscv_subword_address (mem, &aligned_mem, &shift, &mask, &not_mask);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 160) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 161)   rtx shifted_value = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 162)   riscv_lshift_subword (<MODE>mode, value, shift, &shifted_value);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 163) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 164)   emit_insn (gen_subword_atomic_fetch_strong_nand (old, aligned_mem,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 165) 						   shifted_value,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 166) 						   mask, not_mask));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 167) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 168)   emit_move_insn (old, gen_rtx_ASHIFTRT (SImode, old,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 169) 					 gen_lowpart (QImode, shift)));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 170) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 171)   emit_move_insn (operands[0], gen_lowpart (<MODE>mode, old));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 172) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 173)   DONE;
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 174) })
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 175) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 176) (define_insn "subword_atomic_fetch_strong_nand"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 177)   [(set (match_operand:SI 0 "register_operand" "=&r")			  ;; old value at mem
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 178) 	(match_operand:SI 1 "memory_operand" "+A"))			  ;; mem location
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 179)    (set (match_dup 1)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 180) 	(unspec_volatile:SI
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 181) 	  [(not:SI (and:SI (match_dup 1)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 182) 			   (match_operand:SI 2 "register_operand" "rI"))) ;; value for op
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 183) 	   (match_operand:SI 3 "register_operand" "rI")]		  ;; mask
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 184) 	 UNSPEC_SYNC_OLD_OP_SUBWORD))
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 185)     (match_operand:SI 4 "register_operand" "rI")			  ;; not_mask
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 186)     (clobber (match_scratch:SI 5 "=&r"))				  ;; tmp_1
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 187)     (clobber (match_scratch:SI 6 "=&r"))]				  ;; tmp_2
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 188)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 189)   {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 190)     return "1:\;"
+4990cf84c460f (Patrick O'Neill 2023-04-21 13:11:35 -0700 191) 	   "lr.w.aqrl\t%0, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 192) 	   "and\t%5, %0, %2\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 193) 	   "not\t%5, %5\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 194) 	   "and\t%5, %5, %3\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 195) 	   "and\t%6, %0, %4\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 196) 	   "or\t%6, %6, %5\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 197) 	   "sc.w.rl\t%5, %6, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 198) 	   "bnez\t%5, 1b";
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 199)   }
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 200)   [(set (attr "length") (const_int 32))])
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 201) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 202) (define_expand "atomic_fetch_<atomic_optab><mode>"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 203)   [(match_operand:SHORT 0 "register_operand")			 ;; old value at mem
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 204)    (any_atomic:SHORT (match_operand:SHORT 1 "memory_operand")	 ;; mem location
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 205) 		     (match_operand:SHORT 2 "reg_or_0_operand")) ;; value for op
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 206)    (match_operand:SI 3 "const_int_operand")]			 ;; model
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 207)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 208) {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 209)   /* We have no QImode/HImode atomics, so form a mask, then use
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 210)      subword_atomic_fetch_strong_<mode> to implement a LR/SC version of the
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 211)      operation.  */
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 212) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 213)   /* Logic duplicated in gcc/libgcc/config/riscv/atomic.c for use when inlining
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 214)      is disabled.  */
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 215) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 216)   rtx old = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 217)   rtx mem = operands[1];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 218)   rtx value = operands[2];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 219)   rtx aligned_mem = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 220)   rtx shift = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 221)   rtx mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 222)   rtx not_mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 223) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 224)   riscv_subword_address (mem, &aligned_mem, &shift, &mask, &not_mask);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 225) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 226)   rtx shifted_value = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 227)   riscv_lshift_subword (<MODE>mode, value, shift, &shifted_value);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 228) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 229)   emit_insn (gen_subword_atomic_fetch_strong_<atomic_optab> (old, aligned_mem,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 230) 							     shifted_value,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 231) 							     mask, not_mask));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 232) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 233)   emit_move_insn (old, gen_rtx_ASHIFTRT (SImode, old,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 234) 					 gen_lowpart (QImode, shift)));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 235) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 236)   emit_move_insn (operands[0], gen_lowpart (<MODE>mode, old));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 237) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 238)   DONE;
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 239) })
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 240) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 241) (define_insn "atomic_exchange<mode>"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 242)   [(set (match_operand:GPR 0 "register_operand" "=&r")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 243) 	(unspec_volatile:GPR
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 244) 	  [(match_operand:GPR 1 "memory_operand" "+A")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 245) 	   (match_operand:SI 3 "const_int_operand")] ;; model
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 246) 	  UNSPEC_SYNC_EXCHANGE))
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 247)    (set (match_dup 1)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 248) 	(match_operand:GPR 2 "register_operand" "0"))]
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 249)   "TARGET_ATOMIC"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 250)   "%F3amoswap.<amo>%A3 %0,%z2,%1"
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800 251)   [(set_attr "type" "atomic")
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800 252)    (set (attr "length") (const_int 8))])
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 253) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 254) (define_expand "atomic_exchange<mode>"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 255)   [(match_operand:SHORT 0 "register_operand") ;; old value at mem
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 256)    (match_operand:SHORT 1 "memory_operand")   ;; mem location
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 257)    (match_operand:SHORT 2 "register_operand") ;; value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 258)    (match_operand:SI 3 "const_int_operand")]  ;; model
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 259)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 260) {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 261)   rtx old = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 262)   rtx mem = operands[1];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 263)   rtx value = operands[2];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 264)   rtx aligned_mem = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 265)   rtx shift = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 266)   rtx mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 267)   rtx not_mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 268) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 269)   riscv_subword_address (mem, &aligned_mem, &shift, &mask, &not_mask);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 270) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 271)   rtx shifted_value = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 272)   riscv_lshift_subword (<MODE>mode, value, shift, &shifted_value);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 273) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 274)   emit_insn (gen_subword_atomic_exchange_strong (old, aligned_mem,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 275) 						 shifted_value, not_mask));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 276) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 277)   emit_move_insn (old, gen_rtx_ASHIFTRT (SImode, old,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 278) 					 gen_lowpart (QImode, shift)));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 279) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 280)   emit_move_insn (operands[0], gen_lowpart (<MODE>mode, old));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 281)   DONE;
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 282) })
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 283) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 284) (define_insn "subword_atomic_exchange_strong"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 285)   [(set (match_operand:SI 0 "register_operand" "=&r")	 ;; old value at mem
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 286) 	(match_operand:SI 1 "memory_operand" "+A"))	 ;; mem location
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 287)    (set (match_dup 1)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 288) 	(unspec_volatile:SI
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 289) 	  [(match_operand:SI 2 "reg_or_0_operand" "rI")  ;; value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 290) 	   (match_operand:SI 3 "reg_or_0_operand" "rI")] ;; not_mask
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 291)       UNSPEC_SYNC_EXCHANGE_SUBWORD))
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 292)     (clobber (match_scratch:SI 4 "=&r"))]		 ;; tmp_1
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 293)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 294)   {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 295)     return "1:\;"
+4990cf84c460f (Patrick O'Neill 2023-04-21 13:11:35 -0700 296) 	   "lr.w.aqrl\t%0, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 297) 	   "and\t%4, %0, %3\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 298) 	   "or\t%4, %4, %2\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 299) 	   "sc.w.rl\t%4, %4, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 300) 	   "bnez\t%4, 1b";
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 301)   }
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 302)   [(set (attr "length") (const_int 20))])
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 303) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 304) (define_insn "atomic_cas_value_strong<mode>"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 305)   [(set (match_operand:GPR 0 "register_operand" "=&r")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 306) 	(match_operand:GPR 1 "memory_operand" "+A"))
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 307)    (set (match_dup 1)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 308) 	(unspec_volatile:GPR [(match_operand:GPR 2 "reg_or_0_operand" "rJ")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 309) 			      (match_operand:GPR 3 "reg_or_0_operand" "rJ")
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 310) 			      (match_operand:SI 4 "const_int_operand")  ;; mod_s
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 311) 			      (match_operand:SI 5 "const_int_operand")] ;; mod_f
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 312) 	 UNSPEC_COMPARE_AND_SWAP))
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 313)    (clobber (match_scratch:GPR 6 "=&r"))]
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 314)   "TARGET_ATOMIC"
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 315)   {
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 316)     return "1:\;"
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 317) 	   "lr.<amo>.aqrl\t%0,%1\;"
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 318) 	   "bne\t%0,%z2,1f\;"
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 319) 	   "sc.<amo>.rl\t%6,%z3,%1\;"
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 320) 	   "bnez\t%6,1b\;"
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 321) 	   "1:";
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 322)   }
+bdac4b47cbdac (Monk Chiang     2022-10-21 13:01:59 +0800 323)   [(set_attr "type" "atomic")
+d199d2e56da23 (Patrick O'Neill 2023-04-05 09:46:37 -0700 324)    (set (attr "length") (const_int 16))])
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 325) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 326) (define_expand "atomic_compare_and_swap<mode>"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 327)   [(match_operand:SI 0 "register_operand" "")   ;; bool output
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 328)    (match_operand:GPR 1 "register_operand" "")  ;; val output
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 329)    (match_operand:GPR 2 "memory_operand" "")    ;; memory
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 330)    (match_operand:GPR 3 "reg_or_0_operand" "")  ;; expected value
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 331)    (match_operand:GPR 4 "reg_or_0_operand" "")  ;; desired value
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 332)    (match_operand:SI 5 "const_int_operand" "")  ;; is_weak
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 333)    (match_operand:SI 6 "const_int_operand" "")  ;; mod_s
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 334)    (match_operand:SI 7 "const_int_operand" "")] ;; mod_f
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 335)   "TARGET_ATOMIC"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 336) {
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 337)   emit_insn (gen_atomic_cas_value_strong<mode> (operands[1], operands[2],
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 338) 						operands[3], operands[4],
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 339) 						operands[6], operands[7]));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 340) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 341)   rtx compare = operands[1];
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 342)   if (operands[3] != const0_rtx)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 343)     {
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 344)       rtx difference = gen_rtx_MINUS (<MODE>mode, operands[1], operands[3]);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 345)       compare = gen_reg_rtx (<MODE>mode);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 346)       emit_insn (gen_rtx_SET (compare, difference));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 347)     }
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 348) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 349)   if (word_mode != <MODE>mode)
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 350)     {
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 351)       rtx reg = gen_reg_rtx (word_mode);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 352)       emit_insn (gen_rtx_SET (reg, gen_rtx_SIGN_EXTEND (word_mode, compare)));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 353)       compare = reg;
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 354)     }
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 355) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 356)   emit_insn (gen_rtx_SET (operands[0], gen_rtx_EQ (SImode, compare, const0_rtx)));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 357)   DONE;
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 358) })
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 359) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 360) (define_expand "atomic_compare_and_swap<mode>"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 361)   [(match_operand:SI 0 "register_operand")    ;; bool output
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 362)    (match_operand:SHORT 1 "register_operand") ;; val output
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 363)    (match_operand:SHORT 2 "memory_operand")   ;; memory
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 364)    (match_operand:SHORT 3 "reg_or_0_operand") ;; expected value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 365)    (match_operand:SHORT 4 "reg_or_0_operand") ;; desired value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 366)    (match_operand:SI 5 "const_int_operand")   ;; is_weak
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 367)    (match_operand:SI 6 "const_int_operand")   ;; mod_s
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 368)    (match_operand:SI 7 "const_int_operand")]  ;; mod_f
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 369)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 370) {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 371)   emit_insn (gen_atomic_cas_value_strong<mode> (operands[1], operands[2],
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 372) 						operands[3], operands[4],
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 373) 						operands[6], operands[7]));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 374) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 375)   rtx val = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 376)   if (operands[1] != const0_rtx)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 377)     emit_move_insn (val, gen_rtx_SIGN_EXTEND (SImode, operands[1]));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 378)   else
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 379)     emit_move_insn (val, const0_rtx);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 380) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 381)   rtx exp = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 382)   if (operands[3] != const0_rtx)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 383)     emit_move_insn (exp, gen_rtx_SIGN_EXTEND (SImode, operands[3]));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 384)   else
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 385)     emit_move_insn (exp, const0_rtx);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 386) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 387)   rtx compare = val;
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 388)   if (exp != const0_rtx)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 389)     {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 390)       rtx difference = gen_rtx_MINUS (SImode, val, exp);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 391)       compare = gen_reg_rtx (SImode);
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 392)       emit_move_insn (compare, difference);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 393)     }
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 394) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 395)   if (word_mode != SImode)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 396)     {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 397)       rtx reg = gen_reg_rtx (word_mode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 398)       emit_move_insn (reg, gen_rtx_SIGN_EXTEND (word_mode, compare));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 399)       compare = reg;
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 400)     }
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 401) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 402)   emit_move_insn (operands[0], gen_rtx_EQ (SImode, compare, const0_rtx));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 403)   DONE;
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 404) })
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 405) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 406) (define_expand "atomic_cas_value_strong<mode>"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 407)   [(match_operand:SHORT 0 "register_operand") ;; val output
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 408)    (match_operand:SHORT 1 "memory_operand")   ;; memory
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 409)    (match_operand:SHORT 2 "reg_or_0_operand") ;; expected value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 410)    (match_operand:SHORT 3 "reg_or_0_operand") ;; desired value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 411)    (match_operand:SI 4 "const_int_operand")   ;; mod_s
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 412)    (match_operand:SI 5 "const_int_operand")   ;; mod_f
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 413)    (match_scratch:SHORT 6)]
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 414)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 415) {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 416)   /* We have no QImode/HImode atomics, so form a mask, then use
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 417)      subword_atomic_cas_strong<mode> to implement a LR/SC version of the
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 418)      operation.  */
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 419) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 420)   /* Logic duplicated in gcc/libgcc/config/riscv/atomic.c for use when inlining
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 421)      is disabled.  */
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 422) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 423)   rtx old = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 424)   rtx mem = operands[1];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 425)   rtx aligned_mem = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 426)   rtx shift = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 427)   rtx mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 428)   rtx not_mask = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 429) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 430)   riscv_subword_address (mem, &aligned_mem, &shift, &mask, &not_mask);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 431) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 432)   rtx o = operands[2];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 433)   rtx n = operands[3];
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 434)   rtx shifted_o = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 435)   rtx shifted_n = gen_reg_rtx (SImode);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 436) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 437)   riscv_lshift_subword (<MODE>mode, o, shift, &shifted_o);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 438)   riscv_lshift_subword (<MODE>mode, n, shift, &shifted_n);
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 439) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 440)   emit_move_insn (shifted_o, gen_rtx_AND (SImode, shifted_o, mask));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 441)   emit_move_insn (shifted_n, gen_rtx_AND (SImode, shifted_n, mask));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 442) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 443)   emit_insn (gen_subword_atomic_cas_strong (old, aligned_mem,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 444) 					    shifted_o, shifted_n,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 445) 					    mask, not_mask));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 446) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 447)   emit_move_insn (old, gen_rtx_ASHIFTRT (SImode, old,
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 448) 					 gen_lowpart (QImode, shift)));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 449) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 450)   emit_move_insn (operands[0], gen_lowpart (<MODE>mode, old));
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 451) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 452)   DONE;
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 453) })
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 454) 
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 455) (define_insn "subword_atomic_cas_strong"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 456)   [(set (match_operand:SI 0 "register_operand" "=&r")			   ;; old value at mem
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 457) 	(match_operand:SI 1 "memory_operand" "+A"))			   ;; mem location
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 458)    (set (match_dup 1)
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 459) 	(unspec_volatile:SI [(match_operand:SI 2 "reg_or_0_operand" "rJ")  ;; expected value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 460) 			     (match_operand:SI 3 "reg_or_0_operand" "rJ")] ;; desired value
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 461) 	 UNSPEC_COMPARE_AND_SWAP_SUBWORD))
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 462) 	(match_operand:SI 4 "register_operand" "rI")			   ;; mask
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 463) 	(match_operand:SI 5 "register_operand" "rI")			   ;; not_mask
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 464) 	(clobber (match_scratch:SI 6 "=&r"))]				   ;; tmp_1
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 465)   "TARGET_ATOMIC && TARGET_INLINE_SUBWORD_ATOMIC"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 466)   {
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 467)     return "1:\;"
+4990cf84c460f (Patrick O'Neill 2023-04-21 13:11:35 -0700 468) 	   "lr.w.aqrl\t%0, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 469) 	   "and\t%6, %0, %4\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 470) 	   "bne\t%6, %z2, 1f\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 471) 	   "and\t%6, %0, %5\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 472) 	   "or\t%6, %6, %3\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 473) 	   "sc.w.rl\t%6, %6, %1\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 474) 	   "bnez\t%6, 1b\;"
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 475) 	   "1:";
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 476)   }
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 477)   [(set (attr "length") (const_int 28))])
+f797260adaf52 (Patrick O'Neill 2023-04-18 14:33:13 -0700 478) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 479) (define_expand "atomic_test_and_set"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 480)   [(match_operand:QI 0 "register_operand" "")     ;; bool output
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 481)    (match_operand:QI 1 "memory_operand" "+A")    ;; memory
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 482)    (match_operand:SI 2 "const_int_operand" "")]   ;; model
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 483)   "TARGET_ATOMIC"
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 484) {
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 485)   /* We have no QImode atomics, so use the address LSBs to form a mask,
+2a26872984c10 (Patrick O'Neill 2023-04-26 14:13:19 -0700 486)      then use an aligned SImode atomic.  */
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 487)   rtx result = operands[0];
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 488)   rtx mem = operands[1];
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 489)   rtx model = operands[2];
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 490)   rtx addr = force_reg (Pmode, XEXP (mem, 0));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 491) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 492)   rtx aligned_addr = gen_reg_rtx (Pmode);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 493)   emit_move_insn (aligned_addr, gen_rtx_AND (Pmode, addr, GEN_INT (-4)));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 494) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 495)   rtx aligned_mem = change_address (mem, SImode, aligned_addr);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 496)   set_mem_alias_set (aligned_mem, 0);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 497) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 498)   rtx offset = gen_reg_rtx (SImode);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 499)   emit_move_insn (offset, gen_rtx_AND (SImode, gen_lowpart (SImode, addr),
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 500) 				       GEN_INT (3)));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 501) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 502)   rtx tmp = gen_reg_rtx (SImode);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 503)   emit_move_insn (tmp, GEN_INT (1));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 504) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 505)   rtx shmt = gen_reg_rtx (SImode);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 506)   emit_move_insn (shmt, gen_rtx_ASHIFT (SImode, offset, GEN_INT (3)));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 507) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 508)   rtx word = gen_reg_rtx (SImode);
+b7ef9225f7f99 (Jim Wilson      2018-04-02 22:37:21 +0000 509)   emit_move_insn (word, gen_rtx_ASHIFT (SImode, tmp,
+b7ef9225f7f99 (Jim Wilson      2018-04-02 22:37:21 +0000 510) 					gen_lowpart (QImode, shmt)));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 511) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 512)   tmp = gen_reg_rtx (SImode);
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 513)   emit_insn (gen_atomic_fetch_orsi (tmp, aligned_mem, word, model));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 514) 
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 515)   emit_move_insn (gen_lowpart (SImode, result),
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 516) 		  gen_rtx_LSHIFTRT (SImode, tmp,
+b7ef9225f7f99 (Jim Wilson      2018-04-02 22:37:21 +0000 517) 				    gen_lowpart (QImode, shmt)));
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 518)   DONE;
+09cae7507d9e8 (Palmer Dabbelt  2017-02-06 21:38:37 +0000 519) })
diff --git a/gcc/config/riscv/riscv-protos.h b/gcc/config/riscv/riscv-protos.h
index 539321ff95b8..b49732515352 100644
--- a/gcc/config/riscv/riscv-protos.h
+++ b/gcc/config/riscv/riscv-protos.h
@@ -143,6 +143,7 @@ extern void riscv_expand_sstrunc (rtx, rtx);
 extern int riscv_register_move_cost (machine_mode, reg_class_t, reg_class_t);
 extern bool synthesize_ior_xor (rtx_code, rtx [3]);
 extern bool synthesize_and (rtx [3]);
+extern bool synthesize_add (rtx [3]);
 
 #ifdef RTX_CODE
 extern void riscv_expand_int_scc (rtx, enum rtx_code, rtx, rtx, bool *invert_ptr = 0);
diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index e0d8904c1bf8..d9f25f88ac57 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -15441,6 +15441,97 @@ synthesize_and (rtx operands[3])
   return true;
 }
 
+/* Synthesize OPERANDS[0] = OPERANDS[1] + OPERANDS[2].
+
+    OPERANDS[0] and OPERANDS[1] will be a REG and may be the same
+    REG.
+
+    OPERANDS[2] is a CONST_INT.
+
+    Return TRUE if the operation was fully synthesized and the caller
+    need not generate additional code.  Return FALSE if the operation
+    was not synthesized and the caller is responsible for emitting the
+    proper sequence.  */
+
+bool 
+synthesize_add (rtx operands[3])
+{
+  /* Trivial cases that don't need synthesis.  */
+  if (SMALL_OPERAND(INTVAL(operands[2])))
+    return false;
+
+  int budget1 = riscv_const_insns (operands[2], true);
+  int budget2 = riscv_const_insns (GEN_INT (-INTVAL (operands[2])), true);
+
+  HOST_WIDE_INT ival = INTVAL (operands[2]);
+
+  /* If we can emit two addi insns then that's better than synthesizing
+     the constant into a temporary, then adding the temporary to the
+     other input.  The exception is when the constant can be loaded
+     in a single instruction which can issue whenever its convenient.  */
+  if (SUM_OF_TWO_S12 (ival) && budget1 >= 2)
+    {
+      HOST_WIDE_INT saturated = HOST_WIDE_INT_M1U << (IMM_BITS - 1);
+
+      if (ival >= 0)
+         saturated = ~saturated;
+
+      ival -= saturated;
+
+      rtx x = gen_rtx_PLUS (word_mode, operands[1], GEN_INT (saturated));
+      emit_insn (gen_rtx_SET (operands[0], x));
+      rtx output = gen_rtx_PLUS (word_mode, operands[0], GEN_INT (ival));
+      emit_insn (gen_rtx_SET (operands[0], output));
+      return true;
+    }
+
+  /* If we can shift the constant by 1, 2, or 3 bit positions
+     and the result is a cheaper constant, then do so.   */
+  ival = INTVAL (operands[2]);
+  if (TARGET_ZBA
+      && (((ival % 2) == 0 && budget1 > riscv_const_insns (GEN_INT (ival >> 1), true))
+           || ((ival % 4) == 0 && budget1 > riscv_const_insns (GEN_INT (ival >> 2), true))
+           || ((ival % 8) == 0 && budget1 > riscv_const_insns (GEN_INT (ival >> 3), true))))
+    {
+      // Load the shifted constant into a temporary
+      int shct = ctz_hwi (ival);
+
+      /* We can handle shifting up to 3 bit positions via shNadd.  */
+      if (shct > 3)
+        shct = 3;
+
+      /* The adjusted constant may still need synthesis, so do not copy
+	 it directly into register.  Let the expander handle it.  */
+      rtx tmp = force_reg (word_mode, GEN_INT (ival >> shct));
+
+      /* Generate shift-add of temporary and operands[1]
+	 into the final destination.  */
+      rtx x = gen_rtx_ASHIFT (word_mode, tmp, GEN_INT (shct));
+      rtx output = gen_rtx_PLUS (word_mode, x, operands[1]);
+      emit_insn (gen_rtx_SET (operands[0], output));
+      return true;
+    }
+
+  /* If the negated constant is cheaper than the original, then negate
+     the constant and use subi.  */
+  if (budget2 < budget1)
+    {
+      // load -INTVAL (operands[2]) into a temporary
+      rtx tmp = force_reg (word_mode, GEN_INT (-INTVAL (operands[2])));
+
+      // subtract operads[2] from operands[1]
+      rtx output = gen_rtx_MINUS (word_mode, operands[1], tmp);
+      emit_insn (gen_rtx_SET (operands[0], output));
+      return true;
+    }
+
+  /* No add synthesis was found.  Synthesize the constant into
+     a temporary and use that.  */
+  rtx x = force_reg (word_mode, operands[2]);
+  x = gen_rtx_PLUS (word_mode, operands[1], x);
+  emit_insn (gen_rtx_SET (operands[0], x));
+  return true; 
+}
 
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index 578dd43441e2..a72604e29218 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -712,14 +712,17 @@ (define_insn "*addsi3"
    (set_attr "mode" "SI")])
 
 (define_expand "addsi3"
-  [(set (match_operand:SI          0 "register_operand" "=r,r")
-	(plus:SI (match_operand:SI 1 "register_operand" " r,r")
-		 (match_operand:SI 2 "arith_operand"    " r,I")))]
+  [(set (match_operand:SI          0 "register_operand")
+	(plus:SI (match_operand:SI 1 "register_operand")
+		 (match_operand:SI 2 "reg_or_const_int_operand")))]
   ""
 {
   if (TARGET_64BIT)
     {
       rtx t = gen_reg_rtx (DImode);
+
+      if (CONST_INT_P (operands[2]) && !SMALL_OPERAND (operands[2]))
+	operands[2] = force_reg (SImode, operands[2]);
       emit_insn (gen_addsi3_extended (t, operands[1], operands[2]));
       t = gen_lowpart (SImode, t);
       SUBREG_PROMOTED_VAR_P (t) = 1;
@@ -727,9 +730,26 @@ (define_expand "addsi3"
       emit_move_insn (operands[0], t);
       DONE;
     }
+
+  /* We may be able to find a faster sequence, if so, then we are
+     done.  Otherwise let expansion continue normally.  */
+  if (CONST_INT_P (operands[2]) && synthesize_add (operands))
+    DONE;
+})
+
+(define_expand "adddi3"
+  [(set (match_operand:DI          0 "register_operand")
+	(plus:DI (match_operand:DI 1 "register_operand")
+		 (match_operand:DI 2 "reg_or_const_int_operand")))]
+  "TARGET_64BIT"
+{
+  /* We may be able to find a faster sequence, if so, then we are
+     done.  Otherwise let expansion continue normally.  */
+  if (CONST_INT_P (operands[2]) && synthesize_add (operands))
+    DONE;
 })
 
-(define_insn "adddi3"
+(define_insn "*adddi3"
   [(set (match_operand:DI          0 "register_operand" "=r,r")
 	(plus:DI (match_operand:DI 1 "register_operand" " r,r")
 		 (match_operand:DI 2 "arith_operand"    " r,I")))]
diff --git a/gcc/testsuite/gcc.target/riscv/add-synthesis-1.c b/gcc/testsuite/gcc.target/riscv/add-synthesis-1.c
new file mode 100644
index 000000000000..fb3bbeeffe74
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/add-synthesis-1.c
@@ -0,0 +1,36 @@
+/* { dg-options "-march=rv32gcb" { target { rv32 } } } */
+/* { dg-options "-march=rv64gcb" { target { rv64 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" } } */
+
+
+
+#if  __riscv_xlen == 64
+#define TYPE long
+#else
+#define TYPE int
+#endif
+
+#define T(C)  TYPE foo_##C (TYPE x) { return x + C; }
+#define TM(C)  TYPE foo_M##C (TYPE x) { return x + -C; }
+
+/* These cases were selected because they all can be synthesized
+   at expansion time without synthesizing the constant directly.
+
+   That makes the assembler scan testing simpler.  I've verified
+   by hand that cases that should synthesize the constant do in
+   fact still generate code that way.  */
+T (2050)
+T (4094)
+T (4100)
+T (8200)
+
+TM (2049)
+TM (4096)
+TM (4100)
+TM (8200)
+TM (0x200000000)
+
+/* We have 5 tests which should use shNadd insns and 4
+   which used paired addi insns.  */
+/* { dg-final { scan-assembler-times "sh.add\t" 5 } } */
+/* { dg-final { scan-assembler-times "addi\t" 8 } } */
