commit ff5067ecae18d6dd85965e35e4eb16a524b5ea7a
Author: Jeff Law <jlaw@ventanamicro.com>
Date:   Wed May 15 13:09:20 2024 -0600

    Revert "tree-optimization/114589 - remove profile based sink heuristics"
    
    This reverts commit 99b1daae18c095d6c94d32efb77442838e11cbfb.

diff --git a/gcc/tree-ssa-sink.cc b/gcc/tree-ssa-sink.cc
index 2188b7523c7..2f90acb7ef4 100644
--- a/gcc/tree-ssa-sink.cc
+++ b/gcc/tree-ssa-sink.cc
@@ -178,7 +178,15 @@ nearest_common_dominator_of_uses (def_operand_p def_p, bool *debug_stmts)
 
    We want the most control dependent block in the shallowest loop nest.
 
-   If the resulting block is in a shallower loop nest, then use it.  */
+   If the resulting block is in a shallower loop nest, then use it.  Else
+   only use the resulting block if it has significantly lower execution
+   frequency than EARLY_BB to avoid gratuitous statement movement.  We
+   consider statements with VOPS more desirable to move.
+
+   This pass would obviously benefit from PDO as it utilizes block
+   frequencies.  It would also benefit from recomputing frequencies
+   if profile data is not available since frequencies often get out
+   of sync with reality.  */
 
 static basic_block
 select_best_block (basic_block early_bb,
@@ -187,17 +195,18 @@ select_best_block (basic_block early_bb,
 {
   basic_block best_bb = late_bb;
   basic_block temp_bb = late_bb;
+  int threshold;
 
   while (temp_bb != early_bb)
     {
-      /* Walk up the dominator tree, hopefully we'll find a shallower
-	 loop nest.  */
-      temp_bb = get_immediate_dominator (CDI_DOMINATORS, temp_bb);
-
       /* If we've moved into a lower loop nest, then that becomes
 	 our best block.  */
       if (bb_loop_depth (temp_bb) < bb_loop_depth (best_bb))
 	best_bb = temp_bb;
+
+      /* Walk up the dominator tree, hopefully we'll find a shallower
+ 	 loop nest.  */
+      temp_bb = get_immediate_dominator (CDI_DOMINATORS, temp_bb);
     }
 
   /* Placing a statement before a setjmp-like function would be invalid
@@ -212,16 +221,6 @@ select_best_block (basic_block early_bb,
   if (bb_loop_depth (best_bb) < bb_loop_depth (early_bb))
     return best_bb;
 
-  /* Do not move stmts to post-dominating places on the same loop depth.  */
-  if (dominated_by_p (CDI_POST_DOMINATORS, early_bb, best_bb))
-    return early_bb;
-
-  /* If the latch block is empty, don't make it non-empty by sinking
-     something into it.  */
-  if (best_bb == early_bb->loop_father->latch
-      && empty_block_p (best_bb))
-    return early_bb;
-
   /* Avoid turning an unconditional read into a conditional one when we
      still might want to perform vectorization.  */
   if (best_bb->loop_father == early_bb->loop_father
@@ -234,7 +233,28 @@ select_best_block (basic_block early_bb,
       && !dominated_by_p (CDI_DOMINATORS, best_bb->loop_father->latch, best_bb))
     return early_bb;
 
-  return best_bb;
+  /* Get the sinking threshold.  If the statement to be moved has memory
+     operands, then increase the threshold by 7% as those are even more
+     profitable to avoid, clamping at 100%.  */
+  threshold = param_sink_frequency_threshold;
+  if (gimple_vuse (stmt) || gimple_vdef (stmt))
+    {
+      threshold += 7;
+      if (threshold > 100)
+	threshold = 100;
+    }
+
+  /* If BEST_BB is at the same nesting level, then require it to have
+     significantly lower execution frequency to avoid gratuitous movement.  */
+  if (bb_loop_depth (best_bb) == bb_loop_depth (early_bb)
+      /* If result of comparsion is unknown, prefer EARLY_BB.
+	 Thus use !(...>=..) rather than (...<...)  */
+      && !(best_bb->count * 100 >= early_bb->count * threshold))
+    return best_bb;
+
+  /* No better block found, so return EARLY_BB, which happens to be the
+     statement's original block.  */
+  return early_bb;
 }
 
 /* Given a statement (STMT) and the basic block it is currently in (FROMBB),
@@ -432,7 +452,13 @@ statement_sink_location (gimple *stmt, basic_block frombb,
     return false;
   
   sinkbb = select_best_block (frombb, sinkbb, stmt);
-  if (sinkbb == frombb)
+  if (!sinkbb || sinkbb == frombb)
+    return false;
+
+  /* If the latch block is empty, don't make it non-empty by sinking
+     something into it.  */
+  if (sinkbb == frombb->loop_father->latch
+      && empty_block_p (sinkbb))
     return false;
 
   *togsi = gsi_after_labels (sinkbb);
@@ -796,7 +822,6 @@ pass_sink_code::execute (function *fun)
   mark_dfs_back_edges (fun);
   memset (&sink_stats, 0, sizeof (sink_stats));
   calculate_dominance_info (CDI_DOMINATORS);
-  calculate_dominance_info (CDI_POST_DOMINATORS);
 
   virtual_operand_live vop_live;
 
@@ -808,7 +833,6 @@ pass_sink_code::execute (function *fun)
 
   statistics_counter_event (fun, "Sunk statements", sink_stats.sunk);
   statistics_counter_event (fun, "Commoned stores", sink_stats.commoned);
-  free_dominance_info (CDI_POST_DOMINATORS);
   remove_fake_exit_edges ();
   loop_optimizer_finalize ();
 
