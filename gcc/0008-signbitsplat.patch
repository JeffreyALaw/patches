diff --git a/gcc/config/riscv/bitmanip.md b/gcc/config/riscv/bitmanip.md
index 21426f496798..b38dbb5d9840 100644
--- a/gcc/config/riscv/bitmanip.md
+++ b/gcc/config/riscv/bitmanip.md
@@ -1351,3 +1351,53 @@ (define_split
    (set (match_dup 0) (zero_extract:X (match_dup 3)
 				      (const_int 1)
 				      (zero_extend:X (match_dup 2))))])
+
+;; If selecting between a constant with a single bit off and zero, that
+;; is a right arithmetic shift to splat the sign bit across the GPR
+;; then a bclr.
+(define_split
+  [(set (match_operand:X 0 "register_operand")
+	(if_then_else:X (lt:X (match_operand:X 1 "register_operand")
+			      (const_int 0))
+			(match_operand 2 "const_int_operand")
+			(const_int 0)))]
+  "TARGET_ZBS && popcount_hwi (~INTVAL (operands[2])) == 1"
+  [(set (match_dup 0) (ashiftrt:X (match_dup 1) (match_dup 3)))
+   (set (match_dup 0) (and:X (match_dup 0) (match_dup 2)))]
+  { operands[3] = GEN_INT (BITS_PER_WORD - 1); })
+
+;; Selecting between -1 and a single bit on is a right arithmetic shift
+;; of the sign bit to splat it across a GPR then a bset.
+(define_split
+  [(set (match_operand:X 0 "register_operand")
+	(plus:X (if_then_else:X (ge:X (match_operand:X 1 "register_operand")
+				      (const_int 0))
+				(match_operand 2 "const_int_operand")
+				(match_operand 3 "const_int_operand"))
+		(match_operand 4 "const_int_operand")))]
+  "(TARGET_ZBS
+    && INTVAL (operands[3]) + INTVAL (operands[4]) == HOST_WIDE_INT_C (-1)
+    && popcount_hwi (INTVAL (operands[2]) + INTVAL (operands[4])) == 1)"
+  [(set (match_dup 0) (ashiftrt:X (match_dup 1) (match_dup 3)))
+   (set (match_dup 0) (ior:X (match_dup 0) (match_dup 2)))]
+  { 
+    operands[2] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[4]));
+    operands[3] = GEN_INT (BITS_PER_WORD - 1);
+  })
+
+(define_split
+  [(set (match_operand:X 0 "register_operand")
+	(plus:X (if_then_else:X (lt:X (match_operand:X 1 "register_operand")
+				      (const_int 0))
+				(match_operand 2 "const_int_operand")
+				(match_operand 3 "const_int_operand"))
+		(match_operand 4 "const_int_operand")))]
+  "(TARGET_ZBS
+    && INTVAL (operands[3]) + INTVAL (operands[4]) == HOST_WIDE_INT_C (-1)
+    && popcount_hwi (INTVAL (operands[2]) + INTVAL (operands[4])) == 1)"
+  [(set (match_dup 0) (ashiftrt:X (match_dup 1) (match_dup 3)))
+   (set (match_dup 0) (ior:X (match_dup 0) (match_dup 2)))]
+  { 
+    operands[2] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[4]));
+    operands[3] = GEN_INT (BITS_PER_WORD - 1);
+  })
diff --git a/gcc/config/riscv/zicond.md b/gcc/config/riscv/zicond.md
index d170f6ab2628..72a2db593703 100644
--- a/gcc/config/riscv/zicond.md
+++ b/gcc/config/riscv/zicond.md
@@ -270,3 +270,15 @@ (define_split
   [(set (match_dup 0) (ashiftrt:X (match_dup 1) (match_dup 2)))
    (set (match_dup 0) (ior:X (match_dup 0) (const_int 1)))]
   { operands[2] = GEN_INT (GET_MODE_BITSIZE (word_mode) - 1); })
+
+(define_split
+  [(set (match_operand:X 0 "register_operand")
+	(and:X (neg:X (ge:X (match_operand:X 1 "register_operand")
+			    (const_int 0)))
+	       (match_operand:X 2 "register_operand")))]
+  "TARGET_ZICOND_LIKE || TARGET_XTHEADCONDMOV"
+  [(set (match_dup 0) (lt:X (match_dup 1) (const_int 0)))
+   (set (match_dup 0) (if_then_else:X (ne:X (match_dup 0) (const_int 0))
+				      (match_dup 2)
+				      (const_int 0)))])
+
diff --git a/gcc/testsuite/gcc.target/riscv/pr120553-1.c b/gcc/testsuite/gcc.target/riscv/pr120553-1.c
new file mode 100644
index 000000000000..a04de05e84b3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr120553-1.c
@@ -0,0 +1,93 @@
+/* { dg-do compile } */
+/* { dg-options "-march=rv64gcb_zicond -mbranch-cost=5 -mabi=lp64d" { target { rv64 } } } */
+/* { dg-options "-march=rv32gcb_zicond -mbranch-cost=5 -mabi=ilp32" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" } } */
+
+/* We need to adjust the constant so this works for rv32 and rv64.  */
+#if __riscv_xlen == 32
+#define ONE 1U
+#define TYPE int
+#else
+#define ONE 1ULL
+#define TYPE long
+#endif
+
+#define T1(N) TYPE test1_##N (TYPE c) { return c < 0 ? -ONE : (ONE << N); } \
+	      TYPE test2_##N (TYPE c) { return c >= 0 ? (ONE << N) : -ONE; } \
+
+T1(0)
+T1(1)
+T1(2)
+T1(3)
+T1(4)
+T1(5)
+T1(6)
+T1(7)
+T1(8)
+T1(9)
+T1(10)
+T1(11)
+T1(12)
+T1(13)
+T1(14)
+T1(15)
+T1(16)
+T1(17)
+T1(18)
+T1(19)
+T1(20)
+T1(21)
+T1(22)
+T1(23)
+T1(24)
+T1(25)
+T1(26)
+T1(27)
+T1(28)
+T1(29)
+T1(30)
+T1(31)
+#if __riscv_xlen == 64
+T1(32)
+T1(33)
+T1(34)
+T1(35)
+T1(36)
+T1(37)
+T1(38)
+T1(39)
+T1(40)
+T1(41)
+T1(42)
+T1(43)
+T1(44)
+T1(45)
+T1(46)
+T1(47)
+T1(48)
+T1(49)
+T1(50)
+T1(51)
+T1(52)
+T1(53)
+T1(54)
+T1(55)
+T1(56)
+T1(57)
+T1(58)
+T1(59)
+T1(60)
+T1(61)
+T1(62)
+T1(63)
+#endif
+
+/* We handled all these cases well for rv64 at branch-cost=5.  We should be
+   able to handle them for small branch costs too, but don't yet.  */
+/* { dg-final { scan-assembler-times "\\t(srai)" 128 { target rv64 } } } */
+/* { dg-final { scan-assembler-times "\\t(ori|bset)" 128 { target rv64 } } } */
+
+/* For rv32 the N=31 case isn't handled well.  */
+/* { dg-final { scan-assembler-times "\\t(srai)" 62 { target rv32 } } } */
+/* { dg-final { scan-assembler-times "\\t(ori|bset)" 62 { target rv32 } } } */
+
