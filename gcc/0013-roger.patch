


Hi Wilhelm (and Jeff),
Many thanks for your offer to test my revised patch for PR 109476 on AVR.
Any chance that I could ask you to please spin the attached patch?, that I've
confirmed now bootstraps and passes the regression tests on x86_64-pc-linux-gnu,
both 32 and 64 bit.  I've also added a new AVR specific test case.

Jeff, if it's not too much trouble, please could you also try it out on your farm/queue?
I'm not sure if the reviewers will consider this suitable for late stage 4, but I'd be more
confident if your automated testers gave this patch a clean bill of health.

Many thanks (and in advance) to you both for all your help.
Best regards,
Roger
--

> -----Original Message-----
> From: klaus.doldinger64 at googlemail dot com <gcc-bugzilla@gcc.gnu.org>
> Sent: 14 April 2023 08:46
> To: roger@nextmovesoftware.com
> Subject: [Bug rtl-optimization/109476] Missing optimization for 8bit/8bit
> multiplication / regression
>
> https://gcc.gnu.org/bugzilla/show_bug.cgi?id=109476
>
> --- Comment #16 from Wilhelm M <klaus.doldinger64 at googlemail dot com> ---
> (In reply to Roger Sayle from comment #14)
>> My apologies for the delay/issues.  My bootstrap and regression
>> testing of this patch (on x86_64-pc-linux-gnu) revealed an issue or
>> two (including the reported ICE).  My plan was to fix/resolve all
>> these before posting a concrete submission to gcc-patches.
>
> We all appreciate your great effort in this case! Please don't hesitate to send here
> some patches to test with. I'll be happy to test your patches!
>
> --
> You are receiving this mail because:
> You are on the CC list for the bug.

patchav.txt

diff --git a/gcc/lower-subreg.cc b/gcc/lower-subreg.cc
index 481e1e8..81fc5380 100644
--- a/gcc/lower-subreg.cc
+++ b/gcc/lower-subreg.cc
@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "cfgbuild.h"
 #include "dce.h"
 #include "expr.h"
+#include "explow.h"
 #include "tree-pass.h"
 #include "lower-subreg.h"
 #include "rtl-iter.h"
@@ -1299,11 +1300,12 @@ find_decomposable_shift_zext (rtx_insn *insn, bool speed_p)
 
 /* Decompose a more than word wide shift (in INSN) of a multiword
    pseudo or a multiword zero-extend of a wordmode pseudo into a move
-   and 'set to zero' insn.  Return a pointer to the new insn when a
-   replacement was done.  */
+   and 'set to zero' insn.  SPEED_P says whether we are optimizing
+   for speed or size, when checking if a ZERO_EXTEND is preferable.
+   Return a pointer to the new insn when a replacement was done.  */
 
 static rtx_insn *
-resolve_shift_zext (rtx_insn *insn)
+resolve_shift_zext (rtx_insn *insn, bool speed_p)
 {
   rtx set;
   rtx op;
@@ -1378,14 +1380,29 @@ resolve_shift_zext (rtx_insn *insn)
 				dest_reg, GET_CODE (op) != ASHIFTRT);
     }
 
-  if (dest_reg != src_reg)
-    emit_move_insn (dest_reg, src_reg);
-  if (GET_CODE (op) != ASHIFTRT)
-    emit_move_insn (dest_upper, CONST0_RTX (word_mode));
-  else if (INTVAL (XEXP (op, 1)) == 2 * BITS_PER_WORD - 1)
-    emit_move_insn (dest_upper, copy_rtx (src_reg));
+  /* Consider using ZERO_EXTEND instead of setting DEST_UPPER to zero
+     if this is considered reasonable.  */
+  if (GET_CODE (op) == LSHIFTRT
+      && GET_MODE (op) == twice_word_mode
+      && REG_P (SET_DEST (set))
+      && !choices[speed_p].splitting_zext)
+    {
+      rtx tmp = force_reg (word_mode, copy_rtx (src_reg));
+      tmp = simplify_gen_unary (ZERO_EXTEND, twice_word_mode, tmp, word_mode);
+      emit_move_insn (SET_DEST (set), tmp);
+    }
   else
-    emit_move_insn (dest_upper, upper_src);
+    {
+      if (dest_reg != src_reg)
+	emit_move_insn (dest_reg, src_reg);
+      if (GET_CODE (op) != ASHIFTRT)
+	emit_move_insn (dest_upper, CONST0_RTX (word_mode));
+      else if (INTVAL (XEXP (op, 1)) == 2 * BITS_PER_WORD - 1)
+	emit_move_insn (dest_upper, copy_rtx (src_reg));
+      else
+	emit_move_insn (dest_upper, upper_src);
+    }
+
   insns = get_insns ();
 
   end_sequence ();
@@ -1670,7 +1687,7 @@ decompose_multiword_subregs (bool decompose_copies)
 		    {
 		      rtx_insn *decomposed_shift;
 
-		      decomposed_shift = resolve_shift_zext (insn);
+		      decomposed_shift = resolve_shift_zext (insn, speed_p);
 		      if (decomposed_shift != NULL_RTX)
 			{
 			  insn = decomposed_shift;
diff --git a/gcc/config/stormy16/stormy16.cc b/gcc/config/stormy16/stormy16.cc
index 1ed619a2896..e6d6fbdaf80 100644
--- a/gcc/config/stormy16/stormy16.cc
+++ b/gcc/config/stormy16/stormy16.cc
@@ -72,19 +72,23 @@ static GTY(()) section *bss100_section;
    scanned.  In either case, *TOTAL contains the cost result.  */
 
 static bool
-xstormy16_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED,
+xstormy16_rtx_costs (rtx x, machine_mode mode,
 		     int outer_code ATTRIBUTE_UNUSED,
-		     int opno ATTRIBUTE_UNUSED, int *total,
-		     bool speed ATTRIBUTE_UNUSED)
+		     int opno ATTRIBUTE_UNUSED, int *total, bool speed_p)
 {
-  int code = GET_CODE (x);
+  rtx_code code = GET_CODE (x);
 
   switch (code)
     {
     case CONST_INT:
-      if (INTVAL (x) < 16 && INTVAL (x) >= 0)
-        *total = COSTS_N_INSNS (1) / 2;
-      else if (INTVAL (x) < 256 && INTVAL (x) >= 0)
+      if (mode == SImode)
+	{
+	  HOST_WIDE_INT lo_word = INTVAL (x) & 0xffff;
+	  HOST_WIDE_INT hi_word = INTVAL (x) >> 16;
+	  *total = COSTS_N_INSNS (IN_RANGE (lo_word, 0, 255) ? 1 : 2);
+	  *total += COSTS_N_INSNS (IN_RANGE (hi_word, 0, 255) ? 1 : 2);
+	}
+      else if (mode == QImode || IN_RANGE(INTVAL (x), 0, 255))
 	*total = COSTS_N_INSNS (1);
       else
 	*total = COSTS_N_INSNS (2);
@@ -97,12 +101,152 @@ xstormy16_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED,
       *total = COSTS_N_INSNS (2);
       return true;
 
+    case PLUS:
+    case MINUS:
+      if (mode == SImode)
+	{
+	  if (CONST_INT_P (XEXP (x, 1)))
+	    {
+	      HOST_WIDE_INT lo_word = INTVAL (XEXP (x, 1)) & 0xffff;
+	      HOST_WIDE_INT hi_word = INTVAL (XEXP (x, 1)) >> 16;
+	      if (IN_RANGE (lo_word, 0, 16))
+		*total = COSTS_N_INSNS (1);
+	      else
+		*total = COSTS_N_INSNS (2);
+	      if (IN_RANGE (hi_word, 0, 16))
+		*total += COSTS_N_INSNS (1);
+	      else
+		*total += COSTS_N_INSNS (2);
+	    }
+	  else
+	    {
+	      *total = COSTS_N_INSNS (2);
+	      *total += rtx_cost (XEXP (x, 1), mode, code, 0, speed_p);
+	    }
+	  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);
+	  return true;
+	}
+      else
+	{
+	  if (CONST_INT_P (XEXP (x, 1)))
+	    {
+	      if (IN_RANGE (INTVAL (XEXP (x, 1)), 0, 16))
+		*total = COSTS_N_INSNS (1);
+	      else
+		*total = COSTS_N_INSNS (2);
+	    }
+	  else
+	    {
+	      *total = COSTS_N_INSNS (1);
+	      *total += rtx_cost (XEXP (x, 1), mode, code, 0, speed_p);
+	    }
+	  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);
+	  return true;
+	}
+      return false;
+
     case MULT:
-      *total = COSTS_N_INSNS (35 + 6);
-      return true;
+      if (mode == QImode)
+        *total = COSTS_N_INSNS (speed_p ? 18 + 5 : 6);
+      else if (mode == SImode)
+	*total = COSTS_N_INSNS (speed_p ? 3 * 18 + 14 : 17);
+      else 
+        *total = COSTS_N_INSNS (speed_p ? 18 + 3 : 4);
+      return false;
+
     case DIV:
-      *total = COSTS_N_INSNS (51 - 6);
-      return true;
+    case MOD:
+      if (mode == QImode)
+        *total = COSTS_N_INSNS (speed_p ? 19 + 6 : 7);
+      else if (mode == SImode)
+	*total = COSTS_N_INSNS (speed_p ? 100 : 7);
+      else
+        *total = COSTS_N_INSNS (speed_p ? 19 + 3 : 4);
+      return false;
+
+    case UDIV:
+    case UMOD:
+      if (mode == QImode)
+        *total = COSTS_N_INSNS (speed_p ? 18 + 7 : 8);
+      else if (mode == SImode)
+	*total = COSTS_N_INSNS (speed_p ? 100 : 7);
+      else
+        *total = COSTS_N_INSNS (speed_p ? 18 + 3 : 4);
+      return false;
+
+    case ASHIFT:
+    case ASHIFTRT:
+    case LSHIFTRT:
+      if (REG_P (XEXP (x, 0))
+	  && CONST_INT_P (XEXP (x, 1)))
+	{
+	  if (mode == HImode)
+	    {
+	      /* asr/shl/shr.  */
+	      *total = COSTS_N_INSNS (1);
+	      return true;
+	    }
+	  else if (mode == QImode)
+	    {
+	      /* (shl+shr)+shr.  */
+	      *total = COSTS_N_INSNS (3);
+	      return true;
+	    }
+	  else if (mode == SImode)
+	    {
+	      if (IN_RANGE (INTVAL (XEXP (x, 1)), 16, 31))
+		*total = COSTS_N_INSNS (3);
+	      else
+	        *total = COSTS_N_INSNS (5);
+	      return true;
+	    }
+	}
+      return false;
+
+    case ZERO_EXTEND:
+      if (mode == HImode)
+	{
+	  if (GET_MODE (XEXP (x, 0)) == QImode)
+	    /* shl+shr.  */
+	    *total = COSTS_N_INSNS (2);
+	}
+      else if (mode == SImode)
+	{
+	  if (GET_MODE (XEXP (x, 0)) == HImode)
+	    /* mov+mov.  */
+	    *total = COSTS_N_INSNS (2);
+	  else if (GET_MODE (XEXP (x, 0)) == QImode)
+	    /* mov+shl+shr+mov.  */
+	    *total = COSTS_N_INSNS (4);
+	}
+      return false;
+
+    case SIGN_EXTEND:
+      if (mode == HImode)
+	{
+	  if (GET_MODE (XEXP (x, 0)) == QImode)
+	    /* cbw.  */
+	    *total = COSTS_N_INSNS (1);
+	}
+      else if (mode == SImode)
+	{
+	  if (GET_MODE (XEXP (x, 0)) == HImode)
+	    /* mov+asr.  */
+	    *total = COSTS_N_INSNS (2);
+	  else if (GET_MODE (XEXP (x, 0)) == QImode)
+	    /* mov+shl+shr+mov.  */
+	    *total = COSTS_N_INSNS (3);
+	}
+      return false;
+
+    case SET:
+      if (REG_P (XEXP (x, 0)))
+	{
+	  if (!REG_P (XEXP (x, 1)))
+	    *total = rtx_cost (XEXP (x, 1), mode, SET, 1, speed_p);
+	  return true;
+	}
+      return false;
 
     default:
       return false;
