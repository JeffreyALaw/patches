diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index c6ce62190bc..ac8ffe355cb 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -1218,6 +1218,9 @@ extern void aarch64_adjust_reg_alloc_order ();
 
 bool aarch64_optimize_mode_switching (aarch64_mode_entity);
 void aarch64_restore_za (rtx);
+void aarch64_expand_crc_using_pmull (scalar_mode, scalar_mode, rtx *);
+void aarch64_expand_reversed_crc_using_pmull (scalar_mode, scalar_mode, rtx *);
+
 
 extern bool aarch64_gcs_enabled ();
 
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
index cfe95bd4c31..c5d776e2cf0 100644
--- a/gcc/config/aarch64/aarch64-simd.md
+++ b/gcc/config/aarch64/aarch64-simd.md
@@ -4357,7 +4357,7 @@ (define_insn "*aarch64_get_lane_zero_extend<GPI:mode><VDQQH:mode>"
 ;; RTL uses GCC vector extension indices throughout so flip only for assembly.
 ;; Extracting lane zero is split into a simple move when it is between SIMD
 ;; registers or a store.
-(define_insn_and_split "aarch64_get_lane<mode>"
+(define_insn_and_split "@aarch64_get_lane<mode>"
   [(set (match_operand:<VEL> 0 "aarch64_simd_nonimmediate_operand" "=?r, w, Utv")
 	(vec_select:<VEL>
 	  (match_operand:VALL_F16 1 "register_operand" "w, w, w")
diff --git a/gcc/config/aarch64/aarch64.cc b/gcc/config/aarch64/aarch64.cc
index 91de13159cb..673feda5027 100644
--- a/gcc/config/aarch64/aarch64.cc
+++ b/gcc/config/aarch64/aarch64.cc
@@ -30944,6 +30944,137 @@ aarch64_retrieve_sysreg (const char *regname, bool write_p, bool is128op)
   return sysreg->encoding;
 }
 
+/* Generate assembly to calculate CRC
+   using carry-less multiplication instruction.
+   OPERANDS[1] is input CRC,
+   OPERANDS[2] is data (message),
+   OPERANDS[3] is the polynomial without the leading 1.  */
+
+void
+aarch64_expand_crc_using_pmull (scalar_mode crc_mode,
+				scalar_mode data_mode,
+				rtx *operands)
+{
+  /* Check and keep arguments.  */
+  gcc_assert (!CONST_INT_P (operands[0]));
+  gcc_assert (CONST_INT_P (operands[3]));
+  rtx crc = operands[1];
+  rtx data = operands[2];
+  rtx polynomial = operands[3];
+
+  unsigned HOST_WIDE_INT crc_size = GET_MODE_BITSIZE (crc_mode);
+  unsigned HOST_WIDE_INT data_size = GET_MODE_BITSIZE (data_mode);
+  gcc_assert (crc_size <= 32);
+  gcc_assert (data_size <= crc_size);
+
+  /* Calculate the quotient.  */
+  unsigned HOST_WIDE_INT
+      q = gf2n_poly_long_div_quotient (UINTVAL (polynomial), crc_size);
+  /* CRC calculation's main part.  */
+  if (crc_size > data_size)
+    crc = expand_shift (RSHIFT_EXPR, DImode, crc, crc_size - data_size,
+			NULL_RTX, 1);
+
+  rtx t0 = force_reg (DImode, gen_int_mode (q, DImode));
+  polynomial = simplify_gen_unary (ZERO_EXTEND, DImode, polynomial,
+				   GET_MODE (polynomial));
+  rtx t1 = force_reg (DImode, polynomial);
+
+  rtx a0 = expand_binop (DImode, xor_optab, crc, data, NULL_RTX, 1,
+			 OPTAB_WIDEN);
+
+  rtx pmull_res = gen_reg_rtx (TImode);
+  emit_insn (gen_aarch64_crypto_pmulldi (pmull_res, a0, t0));
+  a0 = gen_lowpart (DImode, pmull_res);
+
+  a0 = expand_shift (RSHIFT_EXPR, DImode, a0, crc_size, NULL_RTX, 1);
+
+  emit_insn (gen_aarch64_crypto_pmulldi (pmull_res, a0, t1));
+  a0 = gen_lowpart (DImode, pmull_res);
+
+  if (crc_size > data_size)
+    {
+      rtx crc_part = expand_shift (LSHIFT_EXPR, DImode, operands[1], data_size,
+				   NULL_RTX, 0);
+      a0 = expand_binop (DImode, xor_optab, a0, crc_part, NULL_RTX, 1,
+			 OPTAB_DIRECT);
+    }
+
+  aarch64_emit_move (operands[0], gen_lowpart (crc_mode, a0));
+}
+
+/* Generate assembly to calculate reversed CRC
+   using carry-less multiplication instruction.
+   OPERANDS[1] is input CRC,
+   OPERANDS[2] is data,
+   OPERANDS[3] is the polynomial without the leading 1.  */
+
+void
+aarch64_expand_reversed_crc_using_pmull (scalar_mode crc_mode,
+					 scalar_mode data_mode,
+					 rtx *operands)
+{
+  /* Check and keep arguments.  */
+  gcc_assert (!CONST_INT_P (operands[0]));
+  gcc_assert (CONST_INT_P (operands[3]));
+  rtx crc = operands[1];
+  rtx data = operands[2];
+  rtx polynomial = operands[3];
+
+  unsigned HOST_WIDE_INT crc_size = GET_MODE_BITSIZE (crc_mode);
+  unsigned HOST_WIDE_INT data_size = GET_MODE_BITSIZE (data_mode);
+  gcc_assert (crc_size <= 32);
+  gcc_assert (data_size <= crc_size);
+
+  /* Calculate the quotient.  */
+  unsigned HOST_WIDE_INT
+      q = gf2n_poly_long_div_quotient (UINTVAL (polynomial), crc_size);
+  /* Reflect the calculated quotient.  */
+  q = reflect_hwi (q, crc_size + 1);
+  rtx t0 = force_reg (DImode, gen_int_mode (q, DImode));
+
+  /* Reflect the polynomial.  */
+  unsigned HOST_WIDE_INT ref_polynomial = reflect_hwi (UINTVAL (polynomial),
+						       crc_size);
+  /* An unshifted multiplier would require the final result to be extracted
+     using a shift right by DATA_SIZE - 1 bits.  Shift the multiplier left
+     so that the shift right can be by CRC_SIZE bits instead.  */
+  ref_polynomial <<= crc_size - data_size + 1;
+  rtx t1 = force_reg (DImode, gen_int_mode (ref_polynomial, DImode));
+
+  /* CRC calculation's main part.  */
+  rtx a0 = expand_binop (DImode, xor_optab, crc, data, NULL_RTX, 1,
+			 OPTAB_WIDEN);
+
+  /* Perform carry-less multiplication and get low part.  */
+  rtx pmull_res = gen_reg_rtx (TImode);
+  emit_insn (gen_aarch64_crypto_pmulldi (pmull_res, a0, t0));
+  a0 = gen_lowpart (DImode, pmull_res);
+
+  a0 = expand_binop (DImode, and_optab, a0,
+		     gen_int_mode (GET_MODE_MASK (data_mode), DImode),
+		     NULL_RTX, 1, OPTAB_WIDEN);
+
+  /* Perform carry-less multiplication.  */
+  emit_insn (gen_aarch64_crypto_pmulldi (pmull_res, a0, t1));
+
+  /* Perform a shift right by CRC_SIZE as an extraction of lane 1.  */
+  machine_mode crc_vmode = aarch64_vq_mode (crc_mode).require ();
+  a0 = (crc_size > data_size ? gen_reg_rtx (crc_mode) : operands[0]);
+  emit_insn (gen_aarch64_get_lane (crc_vmode, a0,
+				   gen_lowpart (crc_vmode, pmull_res),
+				   aarch64_endian_lane_rtx (crc_vmode, 1)));
+
+  if (crc_size > data_size)
+    {
+      rtx crc_part = expand_shift (RSHIFT_EXPR, crc_mode, crc, data_size,
+				   NULL_RTX, 1);
+      a0 = expand_binop (crc_mode, xor_optab, a0, crc_part, operands[0], 1,
+			 OPTAB_WIDEN);
+      aarch64_emit_move (operands[0], a0);
+    }
+}
+
 /* Target-specific selftests.  */
 
 #if CHECKING_P
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 711e9adc757..d04ef49b26f 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -4672,6 +4672,63 @@ (define_insn "aarch64_<crc_variant>"
   [(set_attr "type" "crc")]
 )
 
+;; Reversed CRC
+(define_expand "crc_rev<ALLI:mode><ALLX:mode>4"
+  [;; return value (calculated CRC)
+   (match_operand:ALLX 0 "register_operand" "=r")
+   ;; initial CRC
+   (match_operand:ALLX 1 "register_operand" "r")
+   ;; data
+   (match_operand:ALLI 2 "register_operand" "r")
+   ;; polynomial without leading 1
+   (match_operand:ALLX 3)]
+  ""
+  {
+    /* If the polynomial is the same as the polynomial of crc32c* instruction,
+       put that instruction.  crc32c uses iSCSI polynomial.  */
+    if (TARGET_CRC32 && INTVAL (operands[3]) == 0x1EDC6F41
+	&& <ALLX:MODE>mode == SImode)
+      emit_insn (gen_aarch64_crc32c<ALLI:crc_data_type> (operands[0],
+							 operands[1],
+							 operands[2]));
+    /* If the polynomial is the same as the polynomial of crc32* instruction,
+	put that instruction.  crc32 uses HDLC etc.  polynomial.  */
+    else if (TARGET_CRC32 && INTVAL (operands[3]) == 0x04C11DB7
+	     && <ALLX:MODE>mode == SImode)
+      emit_insn (gen_aarch64_crc32<ALLI:crc_data_type> (operands[0],
+							operands[1],
+							operands[2]));
+    else if (TARGET_AES && <ALLI:sizen> <= <ALLX:sizen>)
+      aarch64_expand_reversed_crc_using_pmull (<ALLX:MODE>mode,
+					       <ALLI:MODE>mode,
+					       operands);
+    else
+      /* Otherwise, generate table-based CRC.  */
+      expand_reversed_crc_table_based (operands[0], operands[1], operands[2],
+				       operands[3], <ALLI:MODE>mode,
+				       generate_reflecting_code_standard);
+    DONE;
+  }
+)
+
+;; Bit-forward CRC
+(define_expand "crc<ALLI:mode><ALLX:mode>4"
+  [;; return value (calculated CRC)
+   (match_operand:ALLX 0 "register_operand" "=r")
+   ;; initial CRC
+   (match_operand:ALLX 1 "register_operand" "r")
+   ;; data
+   (match_operand:ALLI 2 "register_operand" "r")
+   ;; polynomial without leading 1
+   (match_operand:ALLX 3)]
+  "TARGET_AES && <ALLI:sizen> <= <ALLX:sizen>"
+  {
+    aarch64_expand_crc_using_pmull (<ALLX:MODE>mode, <ALLI:MODE>mode,
+				    operands);
+    DONE;
+  }
+)
+
 (define_insn "*csinc2<mode>_insn"
   [(set (match_operand:GPI 0 "register_operand" "=r")
         (plus:GPI (match_operand 2 "aarch64_comparison_operation" "")
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index 023893d35f3..86e909364b7 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -1346,6 +1346,10 @@ (define_mode_attr lconst2 [(SI "UsO") (DI "UsP")])
 ;; Map a mode to a specific constraint character.
 (define_mode_attr cmode [(QI "q") (HI "h") (SI "s") (DI "d")])
 
+;; Map a mode to a specific constraint character for calling
+;; appropriate version of crc.
+(define_mode_attr crc_data_type [(QI "b") (HI "h") (SI "w") (DI "x")])
+
 ;; Map modes to Usg and Usj constraints for SISD right shifts
 (define_mode_attr cmode_simd [(SI "g") (DI "j")])
 
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 78e72c50c6d..e954caec644 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -307,6 +307,8 @@ extern bool ix86_expand_vector_init_duplicate (bool, machine_mode, rtx,
 extern bool ix86_expand_vector_init_one_nonzero (bool, machine_mode, rtx,
 						 rtx, int);
 extern bool ix86_extract_perm_from_pool_constant (int*, rtx);
+extern void ix86_expand_crc_using_pclmul (rtx *);
+extern void ix86_expand_reversed_crc_using_pclmul (rtx *);
 
 /* In i386-c.cc  */
 extern void ix86_target_macros (void);
diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index b4d11dff4ee..0b81bba1462 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -26670,6 +26670,135 @@ ix86_run_selftests (void)
 
 } // namespace selftest
 
+/* Generate assembly to calculate CRC using pclmulqdq instruction.
+   OPERANDS[1] is input CRC,
+   OPERANDS[2] is data (message),
+   OPERANDS[3] is the polynomial without the leading 1.  */
+
+void
+ix86_expand_crc_using_pclmul (rtx *operands)
+{
+/* Check and keep arguments.  */
+  gcc_assert (!CONST_INT_P (operands[0]));
+  gcc_assert (CONST_INT_P (operands[3]));
+  rtx crc = operands[1];
+  rtx data = operands[2];
+  unsigned HOST_WIDE_INT crc_size = GET_MODE_BITSIZE (GET_MODE (operands[0]));
+  gcc_assert (crc_size <= 32);
+  unsigned HOST_WIDE_INT data_size = GET_MODE_BITSIZE (GET_MODE (data));
+  unsigned HOST_WIDE_INT DImode_size = GET_MODE_BITSIZE (DImode);
+
+  /* Calculate the quotient.  */
+  unsigned HOST_WIDE_INT
+      q = gf2n_poly_long_div_quotient (UINTVAL (operands[3]), crc_size);
+
+  if (crc_size > data_size)
+    crc = expand_shift (RSHIFT_EXPR, DImode, crc, crc_size - data_size,
+			NULL_RTX, 1);
+
+  /* Keep the quotient in V2DImode.  */
+  rtx q_v2di = gen_reg_rtx (V2DImode);
+  rtx quotient = gen_reg_rtx (DImode);
+  convert_move (quotient, gen_int_mode (q, DImode), 0);
+  emit_insn (gen_vec_concatv2di (q_v2di, quotient, const0_rtx));
+
+  /* crc ^ data and keep in V2DImode.  */
+  rtx cd_xor = expand_binop (DImode, xor_optab, crc, data, NULL_RTX, 1,
+			     OPTAB_WIDEN);
+  rtx res = gen_reg_rtx (V2DImode);
+  emit_insn (gen_vec_concatv2di (res, cd_xor, const0_rtx));
+  /* Perform carry-less multiplication.  */
+  emit_insn (gen_pclmulqdq (res, res, q_v2di, gen_int_mode (0, DImode)));
+
+  res = expand_shift (RSHIFT_EXPR, V2DImode, res, crc_size, NULL_RTX, 0);
+
+  /* Keep the polynomial in V2DImode.  */
+  rtx polynomial = gen_reg_rtx (DImode);
+  convert_move (polynomial, operands[3], 0);
+  rtx p_v2di = gen_reg_rtx (V2DImode);
+  emit_insn (gen_vec_concatv2di (p_v2di, polynomial, const0_rtx));
+
+  /* Perform carry-less multiplication and get low part.  */
+  emit_insn (gen_pclmulqdq (res, res, p_v2di, gen_int_mode (0, DImode)));
+  rtx crc_part = gen_reg_rtx (DImode);
+  emit_insn (gen_vec_extractv2didi (crc_part, res, const0_rtx));
+
+  if (crc_size > data_size)
+    {
+      rtx shift = expand_shift (LSHIFT_EXPR, DImode, operands[1], data_size,
+				NULL_RTX, 1);
+      crc_part = expand_binop (DImode, xor_optab, crc_part, shift, NULL_RTX, 1,
+			       OPTAB_DIRECT);
+    }
+  /* Zero upper bits beyond crc_size.  */
+  res = expand_shift (RSHIFT_EXPR, DImode, crc_part, DImode_size - crc_size,
+		      NULL_RTX, 1);
+  res = expand_shift (LSHIFT_EXPR, DImode, crc_part, DImode_size - crc_size,
+		      NULL_RTX, 0);
+  emit_move_insn (operands[0], gen_lowpart (GET_MODE (operands[0]), crc_part));
+}
+
+/* Generate assembly to calculate reversed CRC using pclmulqdq instruction.
+   OPERANDS[1] is input CRC,
+   OPERANDS[2] is data (message),
+   OPERANDS[3] is the polynomial without the leading 1.  */
+
+void
+ix86_expand_reversed_crc_using_pclmul (rtx *operands)
+{
+  /* Check and keep arguments.  */
+  gcc_assert (!CONST_INT_P (operands[0]));
+  gcc_assert (CONST_INT_P (operands[3]));
+  rtx crc = operands[1];
+  rtx data = operands[2];
+  unsigned HOST_WIDE_INT crc_size = GET_MODE_BITSIZE (GET_MODE (operands[0]));
+  gcc_assert (crc_size <= 32);
+  unsigned HOST_WIDE_INT data_size = GET_MODE_BITSIZE (GET_MODE (data));
+
+  /* Calculate the quotient.  */
+  unsigned HOST_WIDE_INT
+      q = gf2n_poly_long_div_quotient (UINTVAL (operands[3]), crc_size);
+
+  /* Reflect the calculated quotient.  */
+  q = reflect_hwi (q, crc_size + 1);
+  rtx q_v2di = gen_reg_rtx (V2DImode);
+  rtx quotient = gen_reg_rtx (DImode);
+  convert_move (quotient, gen_int_mode (q, DImode), 0);
+  emit_insn (gen_vec_concatv2di (q_v2di, quotient, const0_rtx));
+
+  /* crc ^ data and keep in V2DImode.  */
+  rtx cd_xor = expand_binop (DImode, xor_optab, crc, data, NULL_RTX, 1,
+			     OPTAB_WIDEN);
+
+  /* Perform carry-less multiplication.  */
+  rtx res = gen_reg_rtx (V2DImode);
+  emit_insn (gen_vec_concatv2di (res, cd_xor, const0_rtx));
+  emit_insn (gen_pclmulqdq (res, res, q_v2di, gen_int_mode (0, DImode)));
+
+  res = expand_shift (LSHIFT_EXPR, V2DImode, res, 64 - data_size, NULL_RTX, 0);
+
+  /* Reflect the polynomial and keep in V2DImode.  */
+  unsigned HOST_WIDE_INT reflected_op3 = reflect_hwi (UINTVAL (operands[3]),
+						       crc_size);
+  rtx ref_polynomial = gen_reg_rtx (DImode);
+  convert_move (ref_polynomial, gen_int_mode (reflected_op3 << 1, DImode), 0);
+  rtx p_v2di = gen_reg_rtx (V2DImode);
+  emit_insn (gen_vec_concatv2di (p_v2di, ref_polynomial, const0_rtx));
+
+  /* Perform carry-less multiplication and get high part.  */
+  emit_insn (gen_pclmulqdq (res, res, p_v2di, gen_int_mode (0, DImode)));
+  rtx res_high = gen_reg_rtx (DImode);
+  emit_insn (gen_vec_extractv2didi (res_high, res, const1_rtx));
+
+  if (crc_size > data_size)
+    {
+      rtx shift = expand_shift (RSHIFT_EXPR, DImode, crc, data_size,
+				NULL_RTX, 1);
+      res_high = expand_binop (DImode, xor_optab, res_high, shift, NULL_RTX, 1,
+			       OPTAB_DIRECT);
+    }
+  emit_move_insn (operands[0], gen_lowpart (GET_MODE (operands[0]), res_high));
+}
 #endif /* CHECKING_P */
 
 static const scoped_attribute_specs *const ix86_attribute_table[] =
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 1c1bf659fc2..51a6e10d1bb 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -191,6 +191,10 @@ (define_c_enum "unspec" [
   ;; For CRC32 support
   UNSPEC_CRC32
 
+  ;; For CRC support
+  UNSPEC_CRC
+  UNSPEC_CRC_REV
+
   ;; For LZCNT suppoprt
   UNSPEC_LZCNT
 
@@ -28699,6 +28703,61 @@ (define_insn "sse4_2_crc32di"
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
+
+;; Same as SWI124.  Added for different combinations.
+(define_mode_iterator SWI124dup [QI HI SI])
+
+;; CRC 8, 16, 32 for TARGET_64
+(define_expand "crc<SWI124dup:mode><SWI124:mode>4"
+	;; return value (calculated CRC)
+  [(set (match_operand:SWI124 0 "register_operand" "=r")
+		      ;; initial CRC
+	(unspec:SWI124 [(match_operand:SWI124 1 "register_operand" "r")
+		      ;; data
+		      (match_operand:SWI124dup 2 "register_operand" "r")
+		      ;; polynomial without leading 1
+		      (match_operand:SWI124 3)]
+		      UNSPEC_CRC))]
+  /* The case when data's size is bigger than CRC's size is not supported.  */
+  "TARGET_PCLMUL && TARGET_64BIT && <SWI124:MODE>mode >= <SWI124dup:MODE>mode"
+{
+   ix86_expand_crc_using_pclmul (operands);
+   DONE;
+})
+
+;; Reversed CRC 8, 16, 32 for TARGET_64
+(define_expand "crc_rev<SWI124dup:mode><SWI124:mode>4"
+	;; return value (calculated CRC)
+  [(set (match_operand:SWI124 0 "register_operand" "=r")
+		      ;; initial CRC
+	(unspec:SWI124 [(match_operand:SWI124 1 "register_operand" "r")
+		      ;; data
+		      (match_operand:SWI124dup 2 "register_operand" "r")
+		      ;; polynomial without leading 1
+		      (match_operand:SWI124 3)]
+		      UNSPEC_CRC_REV))]
+  /* The case when data's size is bigger than CRC's size is not supported.  */
+  "((TARGET_PCLMUL && TARGET_64BIT) || TARGET_CRC32)
+    && <SWI124:MODE>mode >= <SWI124dup:MODE>mode"
+{ /* If it is iSCSI polynomial (0x1EDC6F41), generate crc32 instruction.  */
+  if (TARGET_CRC32 && INTVAL (operands[3]) == 517762881)
+    {
+      rtx crc_part = gen_reg_rtx (SImode);
+      rtx crc = operands[1];
+      rtx data = operands[2];
+      emit_insn (gen_sse4_2_crc32<SWI124dup:mode> (crc_part, crc, data));
+      emit_move_insn (operands[0],
+		      gen_lowpart (GET_MODE (operands[0]), crc_part));
+    }
+  else if (TARGET_PCLMUL && TARGET_64BIT)
+    ix86_expand_reversed_crc_using_pclmul (operands);
+  else
+    expand_reversed_crc_table_based (operands[0], operands[1], operands[2],
+				     operands[3], GET_MODE (operands[2]),
+				     generate_reflecting_code_standard);
+  DONE;
+})
+
 (define_insn "rdpmc"
   [(set (match_operand:DI 0 "register_operand" "=A")
   	(unspec_volatile:DI [(match_operand:SI 1 "register_operand" "c")]
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-1-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-1-pmul.c
new file mode 100644
index 00000000000..4043251dbd8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-1-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+
+#include "../../gcc.dg/torture/crc-1.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-10-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-10-pmul.c
new file mode 100644
index 00000000000..0078eebe35c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-10-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-10.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-12-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-12-pmul.c
new file mode 100644
index 00000000000..16d901eeaef
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-12-pmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-12.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-13-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-13-pmul.c
new file mode 100644
index 00000000000..bd8f32e6924
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-13-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-13.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-14-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-14-pmul.c
new file mode 100644
index 00000000000..d35c1110c89
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-14-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-14.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-17-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-17-pmul.c
new file mode 100644
index 00000000000..99b84c8dde0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-17-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-17.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-18-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-18-pmul.c
new file mode 100644
index 00000000000..888c99a7dd7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-18-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-18.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-21-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-21-pmul.c
new file mode 100644
index 00000000000..4b92deceaac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-21-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-21.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-22-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-22-pmul.c
new file mode 100644
index 00000000000..b42b8525b24
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-22-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-22.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-23-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-23-pmul.c
new file mode 100644
index 00000000000..eb2efae0c41
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-23-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-23.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-4-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-4-pmul.c
new file mode 100644
index 00000000000..c7d50017fe8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-4-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-4.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-5-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-5-pmul.c
new file mode 100644
index 00000000000..2a4b87cc5d6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-5-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -w -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-5.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-6-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-6-pmul.c
new file mode 100644
index 00000000000..84604af525a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-6-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-6.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-7-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-7-pmul.c
new file mode 100644
index 00000000000..e1263fca91d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-7-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-7.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-8-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-8-pmul.c
new file mode 100644
index 00000000000..141b474578b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-8-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-9-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-9-pmul.c
new file mode 100644
index 00000000000..2fdcd425a3b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-9-pmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-9.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-CCIT-data16-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-CCIT-data16-pmul.c
new file mode 100644
index 00000000000..21520474564
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-CCIT-data16-pmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-w -march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-CCIT-data8-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-CCIT-data8-pmul.c
new file mode 100644
index 00000000000..3dcc92320f3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-CCIT-data8-pmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-w -march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto" } } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-builtin-pmul64.c b/gcc/testsuite/gcc.target/aarch64/crc-builtin-pmul64.c
new file mode 100644
index 00000000000..d8bb1724a65
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-builtin-pmul64.c
@@ -0,0 +1,61 @@
+/* { dg-options "-march=armv8-a+crypto" } */
+
+#include <stdint-gcc.h>
+int8_t crc8_data8 ()
+{
+  return __builtin_crc8_data8 ('a', 0xff, 0x12);
+}
+int16_t crc16_data8 ()
+{
+  return __builtin_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t crc16_data16 ()
+{
+  return __builtin_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t crc32_data8 ()
+{
+  return __builtin_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+int32_t crc32_data16 ()
+{
+  return __builtin_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t crc32_data32 ()
+{
+  return __builtin_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+}
+
+int8_t rev_crc8_data8 ()
+{
+  return __builtin_rev_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t rev_crc16_data8 ()
+{
+  return __builtin_rev_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t rev_crc16_data16 ()
+{
+  return __builtin_rev_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t rev_crc32_data8 ()
+{
+  return __builtin_rev_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+
+int32_t rev_crc32_data16 ()
+{
+  return __builtin_rev_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t rev_crc32_data32 ()
+{
+  return __builtin_rev_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+} 
+/* { dg-final { scan-assembler-times "pmull" 24 } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-coremark-16bitdata-pmul.c b/gcc/testsuite/gcc.target/aarch64/crc-coremark-16bitdata-pmul.c
new file mode 100644
index 00000000000..e5196aaafef
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-coremark-16bitdata-pmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-w -march=armv8-a+crypto -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-coremark16-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pmull" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-crc32-data16.c b/gcc/testsuite/gcc.target/aarch64/crc-crc32-data16.c
new file mode 100644
index 00000000000..e82cb04fcc3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-crc32-data16.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crc -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint16_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0xEDB88320;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint16_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0xEDB88320;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint16_t i = 0; i < 0xffff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	 abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pmull" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-crc32-data32.c b/gcc/testsuite/gcc.target/aarch64/crc-crc32-data32.c
new file mode 100644
index 00000000000..a7564a7e28a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-crc32-data32.c
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crc -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint32_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 32; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0xEDB88320;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint32_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 32; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0xEDB88320;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint8_t i = 0; i < 0xff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	 abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pmull" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-crc32-data8.c b/gcc/testsuite/gcc.target/aarch64/crc-crc32-data8.c
new file mode 100644
index 00000000000..c88cafadedc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-crc32-data8.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crc -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint8_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0xEDB88320;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint8_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0xEDB88320;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint8_t i = 0; i < 0xff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	 abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pmull" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data16.c b/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data16.c
new file mode 100644
index 00000000000..d82e6252603
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data16.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crc -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint16_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint16_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint16_t i = 0; i < 0xffff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	 abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32C" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pmull" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data32.c b/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data32.c
new file mode 100644
index 00000000000..7acb6fc239c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data32.c
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crc -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint32_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 32; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint32_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 32; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint8_t i = 0; i < 0xff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	 abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32C" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pmull" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data8.c b/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data8.c
new file mode 100644
index 00000000000..e8a8901e453
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/crc-crc32c-data8.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-march=armv8-a+crc -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint8_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint8_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint8_t i = 0; i < 0xff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	 abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32C" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pmull" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-1-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-1-pclmul.c
new file mode 100644
index 00000000000..21edf417f0c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-1-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+
+#include "../../gcc.dg/torture/crc-1.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/i386/crc-10-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-10-pclmul.c
new file mode 100644
index 00000000000..39bfd386d9c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-10-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-10.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-12-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-12-pclmul.c
new file mode 100644
index 00000000000..1ac9a6bf56d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-12-pclmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-12.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-13-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-13-pclmul.c
new file mode 100644
index 00000000000..c290539fad3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-13-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-13.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-14-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-14-pclmul.c
new file mode 100644
index 00000000000..cc62ee471c7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-14-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-14.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-17-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-17-pclmul.c
new file mode 100644
index 00000000000..660bff55e1b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-17-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-17.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-18-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-18-pclmul.c
new file mode 100644
index 00000000000..e54392b32a9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-18-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-18.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-21-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-21-pclmul.c
new file mode 100644
index 00000000000..4db1504cd49
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-21-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-21.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-22-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-22-pclmul.c
new file mode 100644
index 00000000000..d0f27d96069
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-22-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-22.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-23-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-23-pclmul.c
new file mode 100644
index 00000000000..666f3620597
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-23-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-23.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-4-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-4-pclmul.c
new file mode 100644
index 00000000000..398ecaa4aba
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-4-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-4.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-5-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-5-pclmul.c
new file mode 100644
index 00000000000..b80368e81bc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-5-pclmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -w -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-5.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/i386/crc-6-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-6-pclmul.c
new file mode 100644
index 00000000000..20b851e3596
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-6-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-6.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/i386/crc-7-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-7-pclmul.c
new file mode 100644
index 00000000000..3e5cc75338e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-7-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-7.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-8-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-8-pclmul.c
new file mode 100644
index 00000000000..4b1145553fc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-8-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-9-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-9-pclmul.c
new file mode 100644
index 00000000000..204d6c84d47
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-9-pclmul.c
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-options "-mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+
+#include "../../gcc.dg/torture/crc-9.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-CCIT-data16-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-CCIT-data16-pclmul.c
new file mode 100644
index 00000000000..ca728120858
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-CCIT-data16-pclmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-w -mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/i386/crc-CCIT-data8-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-CCIT-data8-pclmul.c
new file mode 100644
index 00000000000..816e0561d8f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-CCIT-data8-pclmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-w -mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto" } } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/i386/crc-coremark-16bitdata-pclmul.c b/gcc/testsuite/gcc.target/i386/crc-coremark-16bitdata-pclmul.c
new file mode 100644
index 00000000000..817d960b0aa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-coremark-16bitdata-pclmul.c
@@ -0,0 +1,9 @@
+/* { dg-do run } */
+/* { dg-options "-w -mpclmul -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-coremark16-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "pclmulqdq" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/i386/crc-crc32-data16.c b/gcc/testsuite/gcc.target/i386/crc-crc32-data16.c
new file mode 100644
index 00000000000..49ab5f31ef0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-crc32-data16.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-mcrc32 -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint16_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint16_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint16_t i = 0; i < 0xffff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pclmulqdq" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-crc32-data32.c b/gcc/testsuite/gcc.target/i386/crc-crc32-data32.c
new file mode 100644
index 00000000000..08d6c193a77
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-crc32-data32.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-mcrc32 -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint32_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 32; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint32_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 32; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint8_t i = 0; i < 0xff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pclmulqdq" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/i386/crc-crc32-data8.c b/gcc/testsuite/gcc.target/i386/crc-crc32-data8.c
new file mode 100644
index 00000000000..7a76b27fd28
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/crc-crc32-data8.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-mcrc32 -O2 -fdump-rtl-dfinish -fdump-tree-crc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+__attribute__ ((noinline,optimize(0)))
+uint32_t _crc32_O0 (uint32_t crc, uint8_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+uint32_t _crc32 (uint32_t crc, uint8_t data) {
+  int i;
+  crc = crc ^ data;
+
+  for (i = 0; i < 8; i++) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ 0x82F63B78;
+      else
+	crc = (crc >> 1);
+    }
+
+  return crc;
+}
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint8_t i = 0; i < 0xff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "UNSPEC_CRC32" "dfinish"} } */
+/* { dg-final { scan-rtl-dump-times "pclmulqdq" 0 "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c
new file mode 100644
index 00000000000..c16224d045a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-1.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-1-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-1-zbkc.c
new file mode 100644
index 00000000000..8c627c0431a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-1-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-1.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c
new file mode 100644
index 00000000000..7a69ae673e6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-10.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-10-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-10-zbkc.c
new file mode 100644
index 00000000000..c4e65f8f758
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-10-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-10.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c
new file mode 100644
index 00000000000..919796e4818
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-12.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-12-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-12-zbkc.c
new file mode 100644
index 00000000000..674edb39de2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-12-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-12.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c
new file mode 100644
index 00000000000..a6f131c1c49
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-13.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-13-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-13-zbkc.c
new file mode 100644
index 00000000000..c59c6ee5959
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-13-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-13.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c
new file mode 100644
index 00000000000..a4a1c948194
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-14.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-14-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-14-zbkc.c
new file mode 100644
index 00000000000..a7c1381eebe
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-14-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-14.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c
new file mode 100644
index 00000000000..244c22a6e86
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-17.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-17-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-17-zbkc.c
new file mode 100644
index 00000000000..879fc285330
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-17-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-17.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c
new file mode 100644
index 00000000000..b4e6aa3b063
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-18.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-18-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-18-zbkc.c
new file mode 100644
index 00000000000..6b4d2531678
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-18-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-18.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbc.c
new file mode 100644
index 00000000000..261fe701933
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbc.c
@@ -0,0 +1,9 @@
+/* { dg-do run { target { riscv64*-*-* } } } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -march=rv64gc_zbc" } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-21.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbkc.c
new file mode 100644
index 00000000000..0b5142640c6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbkc.c
@@ -0,0 +1,9 @@
+/* { dg-do run { target { riscv64*-*-* } } } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -march=rv64gc_zbkc" } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-21.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-22-zbc.c
new file mode 100644
index 00000000000..e7249b5132f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-22.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c
new file mode 100644
index 00000000000..f63ef4e8d9f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-22.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-22-zbkc.c
new file mode 100644
index 00000000000..7499d151557
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-22.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c
new file mode 100644
index 00000000000..2c2b91f8e3b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-23.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-23-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-23-zbkc.c
new file mode 100644
index 00000000000..59439ee6706
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-23-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-23.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c
new file mode 100644
index 00000000000..c7c859a16e4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-4.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c
new file mode 100644
index 00000000000..7017de9bec9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-4.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbkc.c
new file mode 100644
index 00000000000..3601af1ab81
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-4.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c
new file mode 100644
index 00000000000..54f8c6b2172
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-5.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c
new file mode 100644
index 00000000000..ee327064dce
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-5.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbkc.c
new file mode 100644
index 00000000000..956bdd417db
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-5.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c
new file mode 100644
index 00000000000..49e79397e4a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-6.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-6-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-6-zbkc.c
new file mode 100644
index 00000000000..e5316f4cfb3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-6-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-6.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c
new file mode 100644
index 00000000000..2be80ee467e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-7.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-7-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-7-zbkc.c
new file mode 100644
index 00000000000..5b9db3c5372
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-7-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-7.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c
new file mode 100644
index 00000000000..be3564050f9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c
new file mode 100644
index 00000000000..f9bd4945fbf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
+
+#include "../../gcc.dg/torture/crc-8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbkc.c
new file mode 100644
index 00000000000..e7a3520a3b0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c
new file mode 100644
index 00000000000..9b05264d149
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-9.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-9-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-9-zbkc.c
new file mode 100644
index 00000000000..30df5e695cf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-9-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-9.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c
new file mode 100644
index 00000000000..b21d7f07e0b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbkc.c
new file mode 100644
index 00000000000..5f66a9d405f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c
new file mode 100644
index 00000000000..0a7b83b35c4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbkc.c
new file mode 100644
index 00000000000..c68ee27c123
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-CCIT-data8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc32.c b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc32.c
new file mode 100644
index 00000000000..20d7d25f60e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc32.c
@@ -0,0 +1,21 @@
+/* { dg-do compile { target { riscv32*-*-* } } } */
+/* { dg-options "-march=rv32gc_zbc" } */
+
+#include <stdint-gcc.h>
+
+int8_t crc8_data8 ()
+{
+  return __builtin_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t crc16_data8 ()
+{
+  return __builtin_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t crc16_data16 ()
+{
+  return __builtin_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+/* { dg-final { scan-assembler-times "clmul\t" 6 } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc64.c b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc64.c
new file mode 100644
index 00000000000..c9509d56d01
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc64.c
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { riscv64*-*-* } } } */
+/* { dg-options "-march=rv64gc_zbc" } */
+
+#include <stdint-gcc.h>
+
+int8_t crc8_data8 ()
+{
+  return __builtin_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t crc16_data8 ()
+{
+  return __builtin_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t crc16_data16 ()
+{
+  return __builtin_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t crc32_data8 ()
+{
+  return __builtin_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+
+int32_t crc32_data16 ()
+{
+  return __builtin_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t crc32_data32 ()
+{
+  return __builtin_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+}
+
+int8_t rev_crc8_data8 ()
+{
+  return __builtin_rev_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t rev_crc16_data8 ()
+{
+  return __builtin_rev_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t rev_crc16_data16 ()
+{
+  return __builtin_rev_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t rev_crc32_data8 ()
+{
+  return __builtin_rev_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+
+int32_t rev_crc32_data16 ()
+{
+  return __builtin_rev_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t rev_crc32_data32 ()
+{
+  return __builtin_rev_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+}
+/* { dg-final { scan-assembler-times "clmul\t" 18 } } */
+/* { dg-final { scan-assembler-times "clmulh" 6 } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c
new file mode 100644
index 00000000000..20d1ad42813
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-coremark16-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbkc.c
new file mode 100644
index 00000000000..4da3e8b2543
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbkc.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
+/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
+
+#include "../../gcc.dg/torture/crc-coremark16-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
+/* { dg-final { scan-rtl-dump "clmul" "dfinish"} } */
\ No newline at end of file
diff --git a/gcc/timevar.def b/gcc/timevar.def
index 115b2039253..13310032b8a 100644
--- a/gcc/timevar.def
+++ b/gcc/timevar.def
@@ -314,6 +314,7 @@ DEFTIMEVAR (TV_INITIALIZE_RTL        , "initialize rtl")
 DEFTIMEVAR (TV_GIMPLE_LADDRESS       , "address lowering")
 DEFTIMEVAR (TV_TREE_LOOP_IFCVT       , "tree loop if-conversion")
 DEFTIMEVAR (TV_WARN_ACCESS           , "access analysis")
+DEFTIMEVAR (TV_GIMPLE_CRC_OPTIMIZATION, "crc optimization")
 DEFTIMEVAR (TV_EXT_DCE               , "ext dce")
 
 /* Everything else in rest_of_compilation not included above.  */
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index a928cbe4557..7c778f600b5 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -388,6 +388,7 @@ extern gimple_opt_pass *make_pass_graphite_transforms (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_if_conversion (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_if_to_switch (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_loop_distribution (gcc::context *ctxt);
+extern gimple_opt_pass *make_pass_crc_optimization (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_vectorize (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_simduid_cleanup (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_slp_vectorize (gcc::context *ctxt);
diff --git a/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c
index c16224d045a..46ef0b27a81 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-1.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-1-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-1-zbkc.c
index 8c627c0431a..ff7b0068de2 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-1-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-1-zbkc.c
@@ -1,7 +1,6 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-1.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c
index 7a69ae673e6..768080e618c 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-10.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-10-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-10-zbkc.c
index c4e65f8f758..1d9c07b2e2d 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-10-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-10-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-10.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c
index 919796e4818..3e3e43e90e4 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-12.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-12-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-12-zbkc.c
index 674edb39de2..a877274ebf1 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-12-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-12-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-12.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c
index a6f131c1c49..3be593c6ae8 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-13.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-13-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-13-zbkc.c
index c59c6ee5959..f5011507bff 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-13-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-13-zbkc.c
@@ -1,7 +1,6 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
+
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-13.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c
index a4a1c948194..454a6161d8e 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-14.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-14-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-14-zbkc.c
index a7c1381eebe..d9af892457a 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-14-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-14-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-14.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c
index 244c22a6e86..5f601232bf9 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-17.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-17-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-17-zbkc.c
index 879fc285330..685fc35b9fd 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-17-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-17-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-17.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c
index b4e6aa3b063..5de366d4742 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-18.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-18-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-18-zbkc.c
index 6b4d2531678..4842d5cae20 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-18-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-18-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-18.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbc.c
index 261fe701933..c7725d36dfe 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbc.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { riscv64*-*-* } } } */
+/* { dg-do run { target { riscv64*-*-* && riscv_zbc } } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -march=rv64gc_zbc" } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
diff --git a/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbkc.c
index 0b5142640c6..6851c6a54cd 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-21-rv64-zbkc.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { riscv64*-*-* } } } */
+/* { dg-do run { target { riscv64*-*-* && riscv_zbc } } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish  -march=rv64gc_zbkc" } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-22-zbc.c
index e7249b5132f..d5b272aa853 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-22-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-22.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c
index f63ef4e8d9f..b5055d7983c 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkb } } */
 /* { dg-options "-fdump-tree-crc-details" } */
-/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
 
 #include "../../gcc.dg/torture/crc-22.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-22-zbkc.c
index 7499d151557..b866c9391e1 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-22-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-22.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c
index 2c2b91f8e3b..8258fd6f070 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-23.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-23-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-23-zbkc.c
index 59439ee6706..ab2a31d44ef 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-23-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-23-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-23.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c
index c7c859a16e4..f81f303ea37 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-4.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c
index 7017de9bec9..fadfffaab7b 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkb } } */
 /* { dg-options "-fdump-tree-crc-details" } */
-/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
 
 #include "../../gcc.dg/torture/crc-4.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbkc.c
index 3601af1ab81..337f70b9e24 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-4-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-4.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c
index 54f8c6b2172..d82114d11fe 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-5.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c
index ee327064dce..c7441164557 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkb } } */
 /* { dg-options "-w -fdump-tree-crc-details" } */
-/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
 
 #include "../../gcc.dg/torture/crc-5.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbkc.c
index 956bdd417db..6ac165c00a2 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-5-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-5.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c
index 49e79397e4a..ac9271dc46d 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-6.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-6-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-6-zbkc.c
index e5316f4cfb3..8f5d7c376cb 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-6-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-6-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-6.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c
index 2be80ee467e..7d406a72966 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-7.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-7-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-7-zbkc.c
index 5b9db3c5372..70c78c3db77 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-7-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-7-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-7.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c
index be3564050f9..c660e9ce896 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-8.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c
index f9bd4945fbf..52a771dc652 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkb } } */
 /* { dg-options "-fdump-tree-crc-details" } */
-/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Os" "-Oz" "-Og" "-flto"} } */
 
 #include "../../gcc.dg/torture/crc-8.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbkc.c
index e7a3520a3b0..23553618248 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-8-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-8.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c
index 9b05264d149..8e74af289a8 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-9.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-9-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-9-zbkc.c
index 30df5e695cf..654edb06f6f 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-9-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-9-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-O3" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-9.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c
index b21d7f07e0b..be15dea2bc8 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-CCIT-data16.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbkc.c
index 5f66a9d405f..a8f76b5f73c 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-CCIT-data16.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c
index 0a7b83b35c4..da5e1f370e2 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-CCIT-data8.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbkc.c
index c68ee27c123..3bdbb015aa8 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-CCIT-data8.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c
index 20d1ad42813..307456da0ba 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-coremark16-data16.c"
diff --git a/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbkc.c b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbkc.c
index 4da3e8b2543..b31411e20ff 100644
--- a/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbkc.c
+++ b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbkc.c
@@ -1,7 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target riscv_zbkc } } */
 /* { dg-options "-w -fdump-tree-crc -fdump-rtl-dfinish " } */
-/* { dg-additional-options "-march=rv64gc_zbkc" { target { rv64 } } } */
-/* { dg-additional-options "-march=rv32gc_zbkc" { target { rv32 } } } */
 /* { dg-skip-if "" { *-*-* } { "-O0" "-O1" "-Og" } } */
 
 #include "../../gcc.dg/torture/crc-coremark16-data16.c"
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index d550f288a0f..215536ebf4f 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -2066,6 +2066,39 @@ proc check_effective_target_riscv_zvbb { } {
     }]
 }
 
+# Return 1 if the target arch supports the Zbc extension, 0 otherwise.
+# Cache the result.
+
+proc check_effective_target_riscv_zbc { } {
+    return [check_no_compiler_messages riscv_ext_zbc assembly {
+       #ifndef __riscv_zbc
+       #error "Not __riscv_zbc"
+       #endif
+    }]
+}
+
+# Return 1 if the target arch supports the Zbkb extension, 0 otherwise.
+# Cache the result.
+
+proc check_effective_target_riscv_zbkb { } {
+    return [check_no_compiler_messages riscv_ext_zbkb assembly {
+       #ifndef __riscv_zbkb
+       #error "Not __riscv_zbkb"
+       #endif
+    }]
+}
+
+# Return 1 if the target arch supports the Zbkc extension, 0 otherwise.
+# Cache the result.
+
+proc check_effective_target_riscv_zbkc { } {
+    return [check_no_compiler_messages riscv_ext_zbkc assembly {
+       #ifndef __riscv_zbkc
+       #error "Not __riscv_zbkc"
+       #endif
+    }]
+}
+
 # Return 1 if the target arch supports the XTheadVector extension, 0 otherwise.
 # Cache the result.
 
@@ -2154,6 +2187,77 @@ proc check_effective_target_riscv_zvfh_ok { } {
     return 0
 }
 
+# Return 1 if we can execute code when using dg-add-options riscv_zbc
+
+proc check_effective_target_riscv_zbc_ok { } {
+    # If the target already supports zbc without any added options,
+    # we may assume we can execute just fine.
+    if { [check_effective_target_riscv_zbc] } {
+	return 1
+    }
+
+    # check if we can execute zbc insns with the given hardware or
+    # simulator
+    set gcc_march [riscv_get_arch]
+    if { [check_runtime ${gcc_march}_zbc_exec {
+	int main()
+	{
+	    asm ("clmul a0,a0,a1");
+	    asm ("clmulh a0,a0,a1");
+	    return 0;
+	} } "-march=${gcc_march}"] } {
+	    return 1
+	}
+    return 0
+}
+
+# Return 1 if we can execute code when using dg-add-options riscv_zbkb
+
+proc check_effective_target_riscv_zbkb_ok { } {
+    # If the target already supports zbkb without any added options,
+    # we may assume we can execute just fine.
+    if { [check_effective_target_riscv_zbkb] } {
+	return 1
+    }
+
+    # check if we can execute zbkb insns with the given hardware or
+    # simulator
+    set gcc_march [riscv_get_arch]
+    if { [check_runtime ${gcc_march}_zbkb_exec {
+	int main()
+	{
+	    asm ("brev8 a0,a0");
+	    return 0;
+	} } "-march=${gcc_march}"] } {
+	    return 1
+	}
+    return 0
+}
+
+# Return 1 if we can execute code when using dg-add-options riscv_zbkc
+
+proc check_effective_target_riscv_zbkc_ok { } {
+    # If the target already supports zbkc without any added options,
+    # we may assume we can execute just fine.
+    if { [check_effective_target_riscv_zbkc] } {
+	return 1
+    }
+
+    # check if we can execute zbkc insns with the given hardware or
+    # simulator
+    set gcc_march [riscv_get_arch]
+    if { [check_runtime ${gcc_march}_zbkc_exec {
+	int main()
+	{
+	    asm ("clmul a0,a0,a1");
+	    asm ("clmulh a0,a0,a1");
+	    return 0;
+	} } "-march=${gcc_march}"] } {
+	    return 1
+	}
+    return 0
+}
+
 # Return 1 if we can execute code when using dg-add-options riscv_zvbb
 
 proc check_effective_target_riscv_zvbb_ok { } {
@@ -2207,7 +2311,7 @@ proc check_effective_target_riscv_v_misalign_ok { } {
 proc riscv_get_arch { } {
     set gcc_march ""
     # ??? do we neeed to add more extensions to the list below?
-    foreach ext { i e m a f d q c b v zicsr zifencei zfh zba zbb zbc zbs zvbb zvfh ztso zaamo zalrsc zabha zacas } {
+    foreach ext { i e m a f d q c b v zicsr zifencei zfh zba zbb zbc zbkb zbkc zbs zvbb zvfh ztso zaamo zalrsc zabha zacas } {
 	if { [check_no_compiler_messages  riscv_ext_$ext assembly [string map [list DEF __riscv_$ext] {
 		#ifndef DEF
 		#error "Not DEF"
