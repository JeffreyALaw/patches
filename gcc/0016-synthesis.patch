diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index 9c98b1da035..049f8f8cb9f 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -921,12 +921,12 @@ riscv_build_integer_1 (struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS],
 
       /* First handle any bits set by LUI.  Be careful of the
 	 SImode sign bit!.  */
-      if (value & 0x7ffff800)
+      if (value & 0x7ffff000)
 	{
 	  alt_codes[i].code = (i == 0 ? UNKNOWN : IOR);
-	  alt_codes[i].value = value & 0x7ffff800;
+	  alt_codes[i].value = value & 0x7ffff000;
 	  alt_codes[i].use_uw = false;
-	  value &= ~0x7ffff800;
+	  value &= ~0x7ffff000;
 	   i++;
 	}
 
diff --git a/gcc/testsuite/gcc.target/riscv/synthesis-4.c b/gcc/testsuite/gcc.target/riscv/synthesis-4.c
new file mode 100644
index 00000000000..328a55b9e6e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/synthesis-4.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* We aggressively skip as we really just need to test the basic synthesis
+   which shouldn't vary based on the optimization level.  -O1 seems to work
+   and eliminates the usual sources of extraneous dead code that would throw
+   off the counts.  */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-O2" "-O3" "-Os" "-Oz" "-flto" } } */
+/* { dg-options "-march=rv64gc_zba_zbb_zbs" } */
+
+/* Rather than test for a specific synthesis of all these constants or
+   having thousands of tests each testing one variant, we just test the
+   total number of instructions. 
+
+   This isn't expected to change much and any change is worthy of a look.  */
+/* { dg-final { scan-assembler-times "\\t(add|addi|bseti|li|ret|sh1add|sh2add|sh3add|slli)" 45 } } */
+
+
+unsigned long foo_0x60000400000800(void) { return 0x60000400000800UL; }
+
+unsigned long foo_0xc0000400000800(void) { return 0xc0000400000800UL; }
+
+unsigned long foo_0x180000400000800(void) { return 0x180000400000800UL; }
+
+unsigned long foo_0x300000400000800(void) { return 0x300000400000800UL; }
+
+unsigned long foo_0x600000400000800(void) { return 0x600000400000800UL; }
+
+unsigned long foo_0xc00000400000800(void) { return 0xc00000400000800UL; }
+
+unsigned long foo_0x1800000400000800(void) { return 0x1800000400000800UL; }
+
+unsigned long foo_0x3000000400000800(void) { return 0x3000000400000800UL; }
+
+unsigned long foo_0x6000000400000800(void) { return 0x6000000400000800UL; }
