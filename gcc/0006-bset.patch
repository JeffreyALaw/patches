diff --git a/gcc/config/riscv/bitmanip.md b/gcc/config/riscv/bitmanip.md
index f403ba8dbba..ff73fcc1cfb 100644
--- a/gcc/config/riscv/bitmanip.md
+++ b/gcc/config/riscv/bitmanip.md
@@ -611,6 +611,18 @@ (define_insn "*bsetdi_2"
   "bset\t%0,x0,%1"
   [(set_attr "type" "bitmanip")])
 
+;; Similar, but we have a narrowing SUBREG.  We're still using x0 as
+;; a source, so the result is still zero extended.
+(define_insn "*bsetdi_3"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(zero_extend:X
+	  (subreg:SHORT
+	    (ashift:X (const_int 1)
+		      (match_operand:QI 1 "register_operand" "r")) 0)))]
+  "TARGET_64BIT && TARGET_ZBS"
+  "bset\t%0,x0,%1"
+  [(set_attr "type" "bitmanip")])
+
 ;; These two splitters take advantage of the limited range of the
 ;; shift constant.  With the limited range we know the SImode sign
 ;; bit is never set, thus we can treat this as zero extending and
diff --git a/gcc/testsuite/gcc.target/riscv/zbs-bset-2.c b/gcc/testsuite/gcc.target/riscv/zbs-bset-2.c
new file mode 100644
index 00000000000..e8a574e9248
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/zbs-bset-2.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=rv64gc_zba_zbb_zbs -mabi=lp64d" { target { riscv64*-*-* } } } */
+
+typedef struct SHA {
+        unsigned char block[128];
+        unsigned int blockcnt;
+
+} SHA;
+
+#define BITSET(s, pos)    s[(pos) >> 3] &  (char)  (0x01 << (7 - (pos) % 8))
+#define SETBIT(s, pos)    s[(pos) >> 3] |= (char)  (0x01 << (7 - (pos) % 8))
+#define CLRBIT(s, pos)    s[(pos) >> 3] &= (char) ~(0x01 << (7 - (pos) % 8))
+
+#define ULNG        unsigned long
+
+void shabits(char *bitstr, long bitcnt, SHA *s, ULNG i)
+{
+  if (BITSET(bitstr, i))
+    SETBIT(s->block, s->blockcnt);
+  else
+    CLRBIT(s->block, s->blockcnt);
+}
+
+/* { dg-final { scan-assembler-times "bset\t\[a-x\]\[0-9\]+.x0" 2 } } */
+
