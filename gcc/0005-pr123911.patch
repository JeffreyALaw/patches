commit 45f9d4970c13314499aa53ba843873d095105d0f
Author: Jeff Law <jeffrey.law@oss.qualcomm.com>
Date:   Sun Feb 8 08:23:07 2026 -0700

    Patch for testing

diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index 25749af14366..3baf0a936b58 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -3912,9 +3912,16 @@ riscv_legitimize_move (machine_mode mode, rtx dest, rtx src)
 		}
 	    }
 
+	  /* If we are extracting a single element out of a vector and do
+	     not need an intermediate register, then the extraction will
+	     occur directly into RESULT.  RESULT is the same as DEST and
+	     INT_REG.  So we end up with a nop move.  That is not a major
+	     problem, except in this case it'll send us right back into
+	     this code and we recurse.  Given we put the value in RESULT
+	     already we can just elide the nop move here and be done.  */
 	  if (need_int_reg_p)
 	    emit_move_insn (dest, gen_lowpart (GET_MODE (dest), int_reg));
-	  else
+	  else if (!rtx_equal_p (dest, int_reg)) 
 	    emit_move_insn (dest, int_reg);
 	  return true;
 	}
diff --git a/gcc/testsuite/gcc.target/riscv/pr123911.c b/gcc/testsuite/gcc.target/riscv/pr123911.c
new file mode 100644
index 000000000000..30abe7ac76dd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr123911.c
@@ -0,0 +1,15 @@
+/* { dg-do compile */
+/* { dg-options "-march=rv64gv -mabi=lp64d" { target { rv64 } } } */
+/* { dg-options "-march=rv32gv -mabi=ilp32" { target { rv32 } } } */
+
+typedef __attribute__((__vector_size__(8))) char W;
+typedef __attribute__((__vector_size__(64))) short V;
+
+V
+foo(V v, W w)
+{
+  __builtin_memmove(30 + (char *)&v, &w, 1);
+  __builtin_memmove(&v, &w, 8);
+  return v;
+}
+
