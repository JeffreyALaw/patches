diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 95caa54a52b..dc13fc8c283 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1716,6 +1716,11 @@ OBJS = \
 	tree-iterator.o \
 	tree-logical-location.o \
 	tree-loop-distribution.o \
+	crc-verification.o \
+	gimple-crc-optimization.o \
+	sym-exec/expression.o \
+	sym-exec/state.o \
+	sym-exec/condition.o \
 	tree-nested.o \
 	tree-nrv.o \
 	tree-object-size.o \
diff --git a/gcc/builtin-types.def b/gcc/builtin-types.def
index c97d6bad1de..a0c4b8b9ca6 100644
--- a/gcc/builtin-types.def
+++ b/gcc/builtin-types.def
@@ -829,6 +829,26 @@ DEF_FUNCTION_TYPE_3 (BT_FN_PTR_SIZE_SIZE_PTRMODE,
 		     BT_PTR, BT_SIZE, BT_SIZE, BT_PTRMODE)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_UINT8_PTRMODE, BT_VOID, BT_PTR, BT_UINT8,
 		     BT_PTRMODE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT8_UINT8_UINT8_CONST_SIZE, BT_UINT8, BT_UINT8,
+		     BT_UINT8, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT16_UINT16_UINT8_CONST_SIZE, BT_UINT16, BT_UINT16,
+		     BT_UINT8, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT16_UINT16_UINT16_CONST_SIZE, BT_UINT16,
+		     BT_UINT16, BT_UINT16, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT32_UINT32_UINT8_CONST_SIZE, BT_UINT32, BT_UINT32,
+		     BT_UINT8, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT32_UINT32_UINT16_CONST_SIZE, BT_UINT32,
+		     BT_UINT32, BT_UINT16, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT32_UINT32_UINT32_CONST_SIZE, BT_UINT32,
+		     BT_UINT32, BT_UINT32, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT64_UINT64_UINT8_CONST_SIZE, BT_UINT64, BT_UINT64,
+		     BT_UINT8, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT64_UINT64_UINT16_CONST_SIZE, BT_UINT64,
+		     BT_UINT64, BT_UINT16, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT64_UINT64_UINT32_CONST_SIZE, BT_UINT64,
+		     BT_UINT64, BT_UINT32, BT_CONST_SIZE)
+DEF_FUNCTION_TYPE_3 (BT_FN_UINT64_UINT64_UINT64_CONST_SIZE, BT_UINT64,
+		     BT_UINT64, BT_UINT64, BT_CONST_SIZE)
 
 DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,
 		     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)
diff --git a/gcc/builtins.cc b/gcc/builtins.cc
index a0bd82c7981..3dba90e8246 100644
--- a/gcc/builtins.cc
+++ b/gcc/builtins.cc
@@ -2207,7 +2207,24 @@ associated_internal_fn (built_in_function fn, tree return_type)
       if (REAL_MODE_FORMAT (TYPE_MODE (return_type))->b == 2)
 	return IFN_LDEXP;
       return IFN_LAST;
-
+    case BUILT_IN_CRC8_DATA8:
+    case BUILT_IN_CRC16_DATA8:
+    case BUILT_IN_CRC16_DATA16:
+    case BUILT_IN_CRC32_DATA8:
+    case BUILT_IN_CRC32_DATA16:
+    case BUILT_IN_CRC32_DATA32:
+    case BUILT_IN_CRC64_DATA8:
+    case BUILT_IN_CRC64_DATA16:
+    case BUILT_IN_CRC64_DATA32:
+    case BUILT_IN_CRC64_DATA64:
+      return IFN_CRC;
+    case BUILT_IN_REV_CRC8_DATA8:
+    case BUILT_IN_REV_CRC16_DATA8:
+    case BUILT_IN_REV_CRC16_DATA16:
+    case BUILT_IN_REV_CRC32_DATA8:
+    case BUILT_IN_REV_CRC32_DATA16:
+    case BUILT_IN_REV_CRC32_DATA32:
+      return IFN_CRC_REV;
     default:
       return IFN_LAST;
     }
@@ -7752,6 +7769,37 @@ expand_speculation_safe_value (machine_mode mode, tree exp, rtx target,
   return targetm.speculation_safe_value (mode, target, val, failsafe);
 }
 
+/* Expand CRC* or REV_CRC* built-ins.  */
+
+rtx
+expand_builtin_crc_table_based (internal_fn fn, machine_mode data_mode,
+				machine_mode crc_mode, machine_mode mode,
+				tree exp, rtx target)
+{
+  tree rhs1 = CALL_EXPR_ARG (exp, 0); // crc
+  tree rhs2 = CALL_EXPR_ARG (exp, 1); // data
+  tree rhs3 = CALL_EXPR_ARG (exp, 2); // polynomial
+
+  gcc_assert (word_mode >= crc_mode);
+
+  if (!target || mode == VOIDmode)
+    target = gen_reg_rtx (crc_mode);
+
+  rtx op1 = expand_normal (rhs1);
+  rtx op2 = expand_normal (rhs2);
+  gcc_assert (TREE_CODE (rhs3) == INTEGER_CST);
+  rtx op3 = gen_rtx_CONST_INT (crc_mode, TREE_INT_CST_LOW (rhs3));
+
+  if (fn == IFN_CRC)
+    expand_crc_table_based (target, op1, op2, op3, data_mode);
+  else
+    /* If it's IFN_CRC_REV generate bit-reversed CRC.  */
+    expand_reversed_crc_table_based (target, op1, op2, op3,
+				     data_mode,
+				     generate_reflecting_code_standard);
+  return target;
+}
+
 /* Expand an expression EXP that calls a built-in function,
    with result going to TARGET if that's convenient
    (and in mode MODE if that's convenient).
@@ -8928,6 +8976,54 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,
       mode = get_builtin_sync_mode (fcode - BUILT_IN_SPECULATION_SAFE_VALUE_1);
       return expand_speculation_safe_value (mode, exp, target, ignore);
 
+      case BUILT_IN_CRC8_DATA8:
+	return expand_builtin_crc_table_based (IFN_CRC, QImode, QImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC16_DATA8:
+	return expand_builtin_crc_table_based (IFN_CRC, HImode, QImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC16_DATA16:
+	return expand_builtin_crc_table_based (IFN_CRC, HImode, HImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC32_DATA8:
+	return expand_builtin_crc_table_based (IFN_CRC, SImode, QImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC32_DATA16:
+	return expand_builtin_crc_table_based (IFN_CRC, SImode, HImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC32_DATA32:
+	return expand_builtin_crc_table_based (IFN_CRC, SImode, SImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC64_DATA8:
+	return expand_builtin_crc_table_based (IFN_CRC, DImode, QImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC64_DATA16:
+	return expand_builtin_crc_table_based (IFN_CRC, DImode, HImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC64_DATA32:
+	return expand_builtin_crc_table_based (IFN_CRC, DImode, SImode, mode,
+					       exp, target);
+      case BUILT_IN_CRC64_DATA64:
+	return expand_builtin_crc_table_based (IFN_CRC, DImode, DImode, mode,
+					       exp, target);
+      case BUILT_IN_REV_CRC8_DATA8:
+	return expand_builtin_crc_table_based (IFN_CRC_REV, QImode, QImode,
+					       mode, exp, target);
+      case BUILT_IN_REV_CRC16_DATA8:
+	return expand_builtin_crc_table_based (IFN_CRC_REV, HImode, QImode,
+					       mode, exp, target);
+      case BUILT_IN_REV_CRC16_DATA16:
+	return expand_builtin_crc_table_based (IFN_CRC_REV, HImode, HImode,
+					       mode, exp, target);
+      case BUILT_IN_REV_CRC32_DATA8:
+	return expand_builtin_crc_table_based (IFN_CRC_REV, SImode, QImode,
+					       mode, exp, target);
+      case BUILT_IN_REV_CRC32_DATA16:
+	return expand_builtin_crc_table_based (IFN_CRC_REV, SImode, HImode,
+					       mode, exp, target);
+      case BUILT_IN_REV_CRC32_DATA32:
+	return expand_builtin_crc_table_based (IFN_CRC_REV, SImode, SImode,
+					       mode, exp, target);
     default:	/* just do library call, if unknown builtin */
       break;
     }
diff --git a/gcc/builtins.def b/gcc/builtins.def
index f6f3e104f6a..e6188482750 100644
--- a/gcc/builtins.def
+++ b/gcc/builtins.def
@@ -704,7 +704,22 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_Y1L, "y1l", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_M
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_YN, "yn", BT_FN_DOUBLE_INT_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_YNF, "ynf", BT_FN_FLOAT_INT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_YNL, "ynl", BT_FN_LONGDOUBLE_INT_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)
-
+DEF_GCC_BUILTIN        (BUILT_IN_CRC8_DATA8, "crc8_data8", BT_FN_UINT8_UINT8_UINT8_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC16_DATA8, "crc16_data8", BT_FN_UINT16_UINT16_UINT8_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC16_DATA16, "crc16_data16", BT_FN_UINT16_UINT16_UINT16_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC32_DATA8, "crc32_data8", BT_FN_UINT32_UINT32_UINT8_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC32_DATA16, "crc32_data16", BT_FN_UINT32_UINT32_UINT16_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC32_DATA32, "crc32_data32", BT_FN_UINT32_UINT32_UINT32_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC64_DATA8, "crc64_data8", BT_FN_UINT64_UINT64_UINT8_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC64_DATA16, "crc64_data16", BT_FN_UINT64_UINT64_UINT16_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC64_DATA32, "crc64_data32", BT_FN_UINT64_UINT64_UINT32_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_CRC64_DATA64, "crc64_data64", BT_FN_UINT64_UINT64_UINT64_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_REV_CRC8_DATA8, "rev_crc8_data8", BT_FN_UINT8_UINT8_UINT8_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_REV_CRC16_DATA8, "rev_crc16_data8", BT_FN_UINT16_UINT16_UINT8_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_REV_CRC16_DATA16, "rev_crc16_data16", BT_FN_UINT16_UINT16_UINT16_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_REV_CRC32_DATA8, "rev_crc32_data8", BT_FN_UINT32_UINT32_UINT8_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_REV_CRC32_DATA16, "rev_crc32_data16", BT_FN_UINT32_UINT32_UINT16_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
+DEF_GCC_BUILTIN        (BUILT_IN_REV_CRC32_DATA32, "rev_crc32_data32", BT_FN_UINT32_UINT32_UINT32_CONST_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)
 /* Category: _Complex math builtins.  */
 DEF_C99_COMPL_BUILTIN        (BUILT_IN_CABS, "cabs", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)
 DEF_C99_COMPL_BUILTIN        (BUILT_IN_CABSF, "cabsf", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)
diff --git a/gcc/builtins.h b/gcc/builtins.h
index 8d93f75a9a4..e94dec68ed2 100644
--- a/gcc/builtins.h
+++ b/gcc/builtins.h
@@ -133,6 +133,9 @@ extern void expand_builtin_trap (void);
 extern void expand_ifn_atomic_bit_test_and (gcall *);
 extern void expand_ifn_atomic_compare_exchange (gcall *);
 extern void expand_ifn_atomic_op_fetch_cmp_0 (gcall *);
+extern rtx expand_builtin_crc_table_based (internal_fn, machine_mode,
+					   machine_mode, machine_mode,
+					   tree, rtx);
 extern rtx expand_builtin (tree, rtx, rtx, machine_mode, int);
 extern enum built_in_function builtin_mathfn_code (const_tree);
 extern tree fold_builtin_expect (location_t, tree, tree, tree, tree);
diff --git a/gcc/common.opt b/gcc/common.opt
index 51c4a17da83..ffd4f60e814 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -3130,6 +3130,10 @@ ftree-loop-distribute-patterns
 Common Var(flag_tree_loop_distribute_patterns) Optimization
 Enable loop distribution for patterns transformed into a library call.
 
+fgimple-crc-optimization
+Common Var(flag_gimple_crc_optimization) Optimization
+Enable crc optimization on trees.
+
 ftree-loop-im
 Common Var(flag_tree_loop_im) Init(1) Optimization
 Enable loop invariant motion on trees.
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 34b93773b69..80b51e8d283 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -289,6 +289,7 @@ extern void ix86_expand_sse2_mulvxdi3 (rtx, rtx, rtx);
 extern void ix86_expand_sse2_abs (rtx, rtx);
 extern bool ix86_expand_vector_init_duplicate (bool, machine_mode, rtx,
 					       rtx);
+extern void ix86_expand_crc_using_clmul (rtx *);
 extern bool ix86_extract_perm_from_pool_constant (int*, rtx);
 
 /* In i386-c.cc  */
diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index b3e7c74846e..5d90fb8daac 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -26115,6 +26115,92 @@ ix86_run_selftests (void)
 
 } // namespace selftest
 
+/*
+  Generate assembly to calculate CRC using clmul instruction.
+  The following code will be generated when the CRC and data sizes are equal:
+   li      a4,quotient
+   li      a5,polynomial
+   xor     a0,a1,a0
+   clmul   a0,a0,a4
+   srli    a0,a0,crc_size
+   clmul   a0,a0,a5
+   slli    a0,a0,word_mode_size - crc_size
+   srli    a0,a0,word_mode_size - crc_size
+   ret
+  crc_size may be 8, 16, 32.
+  Some instructions will be added for the cases when CRC's size is larger than
+  data's size.
+  OPERANDS[1] is CRC, OPERANDS[2] is data, OPERANDS[3] is the polynomial.
+*/
+
+void
+ix86_expand_crc_using_clmul (rtx *operands)
+{
+   /* Check and keep arguments.  */
+  gcc_assert (!CONST_INT_P (operands[0]));
+  gcc_assert (CONST_INT_P (operands[3]));
+  rtx crc = operands[1];
+ // rtx data = operands[2];
+  unsigned HOST_WIDE_INT
+     crc_size = GET_MODE_BITSIZE (GET_MODE (operands[0]));
+  gcc_assert (crc_size <= 32);
+ // signed HOST_WIDE_INT
+   // data_size = GET_MODE_BITSIZE (GET_MODE (data));
+//  unsigned HOST_WIDE_INT word_mode_size = GET_MODE_BITSIZE (word_mode);
+
+  /* Calculate the quotient.  */
+  unsigned HOST_WIDE_INT
+      q = gf2n_poly_long_div_quotient (UINTVAL (operands[3]), crc_size + 1);
+/*
+  if (crc_size > data_size)
+  crc = force_reg (V2DImode, gen_rtx_LSHIFTRT (word_mode, crc,
+						  gen_int_mode (crc_size
+						  - data_size, word_mode)));
+  rtx t0 = force_reg (V2DImode, gen_int_mode (q, word_mode));
+  rtx t1 = force_reg (V2DImode, operands[3]);
+  rtx a0 = force_reg (V2DImode, gen_rtx_XOR (word_mode, crc, data));
+    emit_insn (gen_pclmulqdq (a0, a0, t0, gen_int_mode (0, word_mode)));
+
+ rtx a1 = force_reg (V2DImode, gen_rtx_LSHIFTRT (word_mode, a0,
+					       gen_int_mode (crc_size,
+							     word_mode)));
+    emit_insn (gen_pclmulqdq (a1, a1, t1, gen_int_mode (0, word_mode)));
+*/
+ /* if (crc_size > data_size)
+    {
+      rtx crc_part = force_reg (word_mode,
+				gen_rtx_ASHIFT (word_mode, operands[1],
+						gen_int_mode (data_size,
+							      word_mode)));
+      a1 = force_reg (word_mode, gen_rtx_XOR (word_mode, a1, crc_part));
+
+    }
+  rtx num_shift = gen_int_mode (word_mode_size - crc_size, word_mode);
+  rtx a2 = gen_lowpart (V2DImode, a1);
+
+ rtx a2 = force_reg (V2DImode, gen_rtx_ASHIFT (word_mode, a1, num_shift));
+  a2 = force_reg (V2DImode, gen_rtx_LSHIFTRT (word_mode, a2, num_shift));*/
+ /* rtx tgt = simplify_gen_subreg (word_mode, operands[0],
+				 GET_MODE (operands[0]), 0);
+  emit_move_insn (tgt, a0);
+*/
+
+  rtx t0 = force_reg (V2DImode, gen_int_mode (q, word_mode));
+  rtx lo = gen_reg_rtx (word_mode);
+  convert_move (lo, crc, 0);
+  rtx tmp = gen_reg_rtx (V2DImode);
+  emit_insn (gen_vec_concatv2di (tmp, lo, gen_int_mode(0, word_mode)));
+  emit_insn (gen_pclmulqdq (tmp, tmp, t0, gen_int_mode(0, word_mode)));
+ // convert_move (operands[0], tmp, false);
+  //ix86_move_vector_high_sse_to_mmx (tmp);
+ // ix86_expand_vector_extract (false, operands[0], tmp, 0);
+  //emit_move_insn (operands[0], tmp);
+  /*rtx tgt = simplify_gen_subreg (word_mode, operands[0],
+  GET_MODE (operands[0]), 0);
+  emit_move_insn (tgt, gen_lowpart (word_mode, tmp));*/
+  emit_move_insn (operands [0], gen_lowpart (GET_MODE (operands[0]), tmp));
+}
+
 #endif /* CHECKING_P */
 
 static const scoped_attribute_specs *const ix86_attribute_table[] =
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index bac0a6ade67..5c492a9b98f 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -189,6 +189,9 @@ (define_c_enum "unspec" [
   ;; For CRC32 support
   UNSPEC_CRC32
 
+  ;; For CRC support
+  UNSPEC_CRC
+
   ;; For LZCNT suppoprt
   UNSPEC_LZCNT
 
@@ -1130,6 +1133,9 @@ (define_mode_iterator SWI24 [HI SI])
 ;; Single word integer modes.
 (define_mode_iterator SWI [QI HI SI (DI "TARGET_64BIT")])
 
+;; Single word integer modes without DImode.
+(define_mode_iterator SWI124o [QI HI (SI "TARGET_64BIT")])
+
 ;; Single word integer modes without QImode.
 (define_mode_iterator SWI248 [HI SI (DI "TARGET_64BIT")])
 
@@ -27170,6 +27176,28 @@ (define_insn "sse4_2_crc32di"
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
+
+;; Same as SWI124o. Added for different combinations.
+(define_mode_iterator SWI124o2 [QI HI (SI "TARGET_64BIT")])
+
+;; CRC 8, 16, (32 for TARGET_64)
+(define_expand "crc<SWI124o2:mode><SWI124o:mode>4"
+	;; return value (calculated CRC)
+  [(set (match_operand:SWI124o 0 "register_operand" "=r")
+		      ;; initial CRC
+	(unspec:SWI124o [(match_operand:SWI124o 1 "register_operand" "r")
+		      ;; data
+		      (match_operand:SWI124o2 2 "register_operand" "r")
+		      ;; polynomial without leading 1
+		      (match_operand:SWI124o 3)]
+		      UNSPEC_CRC))]
+/* We don't support the case when data's size is bigger than CRC's size.  */
+"<SWI124o:MODE>mode >= <SWI124o2:MODE>mode"
+{
+   ix86_expand_crc_using_clmul (operands);
+   DONE;
+})
+
 (define_insn "rdpmc"
   [(set (match_operand:DI 0 "register_operand" "=A")
   	(unspec_volatile:DI [(match_operand:SI 1 "register_operand" "c")]
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index acd10908d76..30d435a98b0 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -26371,10 +26371,10 @@ (define_insn "aeskeygenassist"
 (define_insn "pclmulqdq"
   [(set (match_operand:V2DI 0 "register_operand" "=x,x,v")
 	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "0,x,v")
-		      (match_operand:V2DI 2 "vector_operand" "xja,xm,vm")
+		      (match_operand:V2DI 2 "register_operand" "")
 		      (match_operand:SI 3 "const_0_to_255_operand")]
 		     UNSPEC_PCLMUL))]
-  "TARGET_PCLMUL"
+  ""
   "@
    pclmulqdq\t{%3, %2, %0|%0, %2, %3}
    vpclmulqdq\t{%3, %2, %1, %0|%0, %1, %2, %3}
diff --git a/gcc/config/riscv/bitmanip.md b/gcc/config/riscv/bitmanip.md
index ccda25c01c1..6627103c4d5 100644
--- a/gcc/config/riscv/bitmanip.md
+++ b/gcc/config/riscv/bitmanip.md
@@ -878,3 +878,66 @@ (define_insn "riscv_clmulr_<mode>"
   "TARGET_ZBC"
   "clmulr\t%0,%1,%2"
   [(set_attr "type" "clmul")])
+
+
+;; Iterator for hardware integer modes narrower than XLEN, same as SUBX
+(define_mode_iterator SUBX1 [QI HI (SI "TARGET_64BIT")])
+
+;; Iterator for hardware integer modes narrower than XLEN, same as SUBX
+(define_mode_iterator ANYI1 [QI HI SI (DI "TARGET_64BIT")])
+
+;; Reversed CRC 16, 32 for TARGET_64
+(define_expand "crc_rev<ANYI1:mode><ANYI:mode>4"
+	;; return value (calculated CRC)
+  [(set (match_operand:ANYI 0 "register_operand" "=r")
+		      ;; initial CRC
+	(unspec:ANYI [(match_operand:ANYI 1 "register_operand" "r")
+		      ;; data
+		      (match_operand:ANYI1 2 "register_operand" "r")
+		      ;; polynomial without leading 1
+		      (match_operand:ANYI 3)]
+		      UNSPEC_CRC_REV))]
+  /* We don't support the case when data's size is bigger than CRC's size.  */
+  "((TARGET_ZBC && <ANYI:MODE>mode < word_mode) || TARGET_ZBKB)
+   && <ANYI:MODE>mode >= <ANYI1:MODE>mode"
+  {
+	/* If we have the ZBC extension (ie, clmul) and
+	   it is possible to store the quotient within a single variable
+	   (E.g.  CRC64's quotient may need 65 bits,
+	   we can't keep it in 64 bit variable.)
+	   then use clmul instruction to implement the CRC,
+	   otherwise (TARGET_ZBKB) generate table based using brev.  */
+	if (TARGET_ZBC)
+	  expand_reversed_crc_using_clmul (operands);
+	else
+	 /* Generate table-based CRC.
+	    To reflect values use brev and bswap instructions.  */
+	  expand_reversed_crc_table_based (operands[0], operands[1],
+					   operands[2], operands[3],
+					   GET_MODE (operands[2]),
+					   generate_reflecting_code_using_brev);
+	DONE;
+  })
+
+;; CRC 8, 16, (32 for TARGET_64)
+(define_expand "crc<SUBX1:mode><SUBX:mode>4"
+	;; return value (calculated CRC)
+  [(set (match_operand:SUBX 0 "register_operand" "=r")
+		      ;; initial CRC
+	(unspec:SUBX [(match_operand:SUBX 1 "register_operand" "r")
+		      ;; data
+		      (match_operand:SUBX1 2 "register_operand" "r")
+		      ;; polynomial without leading 1
+		      (match_operand:SUBX 3)]
+		      UNSPEC_CRC))]
+/* We don't support the case when data's size is bigger than CRC's size.  */
+"TARGET_ZBC && <SUBX:MODE>mode >= <SUBX1:MODE>mode"
+{
+      /* If we have the ZBC extension (ie, clmul) and
+	 it is possible to store the quotient within a single variable
+	 (E.g.  CRC64's quotient may need 65 bits,
+	  we can't keep it in 64 bit variable.)
+	 then use clmul instruction to implement the CRC.  */
+      expand_crc_using_clmul (operands);
+      DONE;
+})
\ No newline at end of file
diff --git a/gcc/config/riscv/riscv-protos.h b/gcc/config/riscv/riscv-protos.h
index b3f0bdb9924..c9eedece1a9 100644
--- a/gcc/config/riscv/riscv-protos.h
+++ b/gcc/config/riscv/riscv-protos.h
@@ -164,6 +164,9 @@ extern bool riscv_shamt_matches_mask_p (int, HOST_WIDE_INT);
 extern void riscv_subword_address (rtx, rtx *, rtx *, rtx *, rtx *);
 extern void riscv_lshift_subword (machine_mode, rtx, rtx, rtx *);
 extern enum memmodel riscv_union_memmodels (enum memmodel, enum memmodel);
+extern void generate_reflecting_code_using_brev (rtx *, int);
+extern void expand_crc_using_clmul (rtx *);
+extern void expand_reversed_crc_using_clmul (rtx *);
 
 /* Routines implemented in riscv-c.cc.  */
 void riscv_cpu_cpp_builtins (cpp_reader *);
diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index 529ef5e84b7..c61b8e8aa5c 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -10578,6 +10578,7 @@ riscv_preferred_else_value (unsigned ifn, tree vectype, unsigned int nops,
   return default_preferred_else_value (ifn, vectype, nops, ops);
 }
 
+
 /* If MEM is in the form of "base+offset", extract the two parts
    of address and set to BASE and OFFSET, otherwise return false
    after clearing BASE and OFFSET.  */
@@ -10622,6 +10623,178 @@ riscv_vector_mode_supported_any_target_p (machine_mode)
   return true;
 }
 
+/* Reflect the VALUE.
+   If we have 0000 0000 0101 0111, we will get 1110 1010.  */
+
+unsigned HOST_WIDE_INT
+reflect (unsigned HOST_WIDE_INT value)
+{
+  unsigned HOST_WIDE_INT reflectedValue = 0;
+  /* Looping through each bit in the byte.  */
+  for (size_t i = 0; value || !(i == 8 || i == 16 || i == 32 || i == 64); i++)
+    {
+      reflectedValue <<= 1;
+      /* Add the least significant bit of the original value to the
+	reflected value.  */
+      reflectedValue |= (value & 1);
+      value >>= 1;
+    }
+  return reflectedValue;
+}
+
+/* Generate instruction sequence
+   which reflects the value of the OP using bswap and brev8 instructions.
+   OP's mode may be less than word_mode, to get the correct number,
+   after reflecting we shift right the value by SHIFT_VAL.
+   E.g. we have 1111 0001, after reflection (target 32-bit) we will get
+   1000 1111 0000 0000, if we shift-out 16 bits,
+   we will get the desired one: 1000 1111.  */
+
+void
+generate_reflecting_code_using_brev (rtx *op, int shift_val)
+{
+
+  *op = gen_rtx_BSWAP (word_mode, *op);
+  *op = gen_rtx_LSHIFTRT (word_mode, *op, gen_int_mode (shift_val, word_mode));
+  *op = force_reg (word_mode, *op);
+  if (TARGET_64BIT)
+    emit_insn (gen_riscv_brev8_di (*op, *op));
+  else
+    emit_insn (gen_riscv_brev8_si (*op, *op));
+}
+
+
+/*
+  Generate assembly to calculate CRC using clmul instruction.
+  The following code will be generated when the CRC and data sizes are equal:
+   li      a4,quotient
+   li      a5,polynomial
+   xor     a0,a1,a0
+   clmul   a0,a0,a4
+   srli    a0,a0,crc_size
+   clmul   a0,a0,a5
+   slli    a0,a0,word_mode_size - crc_size
+   srli    a0,a0,word_mode_size - crc_size
+   ret
+  crc_size may be 8, 16, 32.
+  Some instructions will be added for the cases when CRC's size is larger than
+  data's size.
+  OPERANDS[1] is CRC, OPERANDS[2] is data, OPERANDS[3] is the polynomial.
+*/
+
+void
+expand_crc_using_clmul (rtx *operands)
+{
+  /* Check and keep arguments.  */
+  gcc_assert (!CONST_INT_P (operands[0]));
+  gcc_assert (CONST_INT_P (operands[3]));
+  rtx crc = operands[1];
+  rtx data = operands[2];
+  unsigned HOST_WIDE_INT
+      crc_size = GET_MODE_BITSIZE (GET_MODE (operands[0])).to_constant ();
+  gcc_assert (crc_size <= 32);
+  unsigned HOST_WIDE_INT
+      data_size = GET_MODE_BITSIZE (GET_MODE (data)).to_constant ();
+  unsigned HOST_WIDE_INT word_mode_size = GET_MODE_BITSIZE (word_mode);
+
+  /* Calculate the quotient.  */
+  unsigned HOST_WIDE_INT
+      q = gf2n_poly_long_div_quotient (UINTVAL (operands[3]), crc_size + 1);
+
+  if (crc_size > data_size)
+    crc = force_reg (word_mode, gen_rtx_LSHIFTRT (word_mode, crc,
+						  gen_int_mode (crc_size
+						  - data_size, word_mode)));
+  rtx t0 = force_reg (word_mode, gen_int_mode (q, word_mode));
+  rtx t1 = force_reg (word_mode, operands[3]);
+  rtx a0 = force_reg (word_mode, gen_rtx_XOR (word_mode, crc, data));
+  if (TARGET_64BIT)
+    emit_insn (gen_riscv_clmul_di (a0, a0, t0));
+  else
+    emit_insn (gen_riscv_clmul_si (a0, a0, t0));
+
+  a0 = force_reg (word_mode, gen_rtx_LSHIFTRT (word_mode, a0,
+					       gen_int_mode (crc_size,
+							     word_mode)));
+  if (TARGET_64BIT)
+    emit_insn (gen_riscv_clmul_di (a0, a0, t1));
+  else
+    emit_insn (gen_riscv_clmul_si (a0, a0, t1));
+
+  if (crc_size > data_size)
+    {
+      rtx crc_part = force_reg (word_mode,
+				gen_rtx_ASHIFT (word_mode, operands[1],
+						gen_int_mode (data_size,
+							      word_mode)));
+      a0 = force_reg (word_mode, gen_rtx_XOR (word_mode, a0, crc_part));
+
+    }
+  rtx num_shift = gen_int_mode (word_mode_size - crc_size, word_mode);
+  a0 = force_reg (word_mode, gen_rtx_ASHIFT (word_mode, a0, num_shift));
+  a0 = force_reg (word_mode, gen_rtx_LSHIFTRT (word_mode, a0, num_shift));
+  rtx tgt = simplify_gen_subreg (word_mode, operands[0],
+				 GET_MODE (operands[0]), 0);
+  riscv_emit_move (tgt, a0);
+}
+
+/*
+  Generate assembly to calculate reversed CRC using clmul instruction.
+  OPERANDS[1] is CRC, OPERANDS[2] is data, OPERANDS[3] is the polynomial.
+*/
+
+void
+expand_reversed_crc_using_clmul (rtx *operands)
+{
+  /* Check and keep arguments.  */
+  gcc_assert (!CONST_INT_P (operands[0]));
+  gcc_assert (CONST_INT_P (operands[3]));
+  rtx crc = operands[1];
+  rtx data = operands[2];
+  unsigned HOST_WIDE_INT
+      crc_size = GET_MODE_BITSIZE (GET_MODE (operands[0])).to_constant ();
+  gcc_assert (crc_size <= 32);
+  unsigned HOST_WIDE_INT
+      data_size = GET_MODE_BITSIZE (GET_MODE (data)).to_constant ();
+
+  /* Calculate the quotient.  */
+  unsigned HOST_WIDE_INT
+      q = gf2n_poly_long_div_quotient (UINTVAL (operands[3]), crc_size + 1);
+  /* Reflect the calculated quotient.  */
+  q = reflect (q);
+
+  rtx t0 = force_reg (word_mode, gen_int_mode (q >> (data_size - 4),
+					       word_mode));
+  /* Reflect the polynomial.  */
+  unsigned HOST_WIDE_INT polynomial = reflect (UINTVAL (operands[3]));
+  rtx t1 = force_reg (word_mode, gen_int_mode (polynomial << 1, word_mode));
+  rtx a0 = force_reg (word_mode, gen_rtx_XOR (word_mode, crc, data));
+  if (TARGET_64BIT)
+    emit_insn (gen_riscv_clmul_di (a0, a0, t0));
+  else
+    emit_insn (gen_riscv_clmul_si (a0, a0, t0));
+  rtx num_shift = gen_int_mode (GET_MODE_BITSIZE (word_mode) - crc_size - 3,
+				word_mode);
+  a0 = force_reg (word_mode, gen_rtx_ASHIFT (word_mode, a0, num_shift));
+
+  if (TARGET_64BIT)
+    emit_insn (gen_riscv_clmulh_di (a0, a0, t1));
+  else
+    emit_insn (gen_riscv_clmulh_si (a0, a0, t1));
+
+  if (crc_size > data_size)
+    {
+      rtx data_size_shift = gen_int_mode (data_size, word_mode);
+      rtx crc_part = force_reg (word_mode,
+				gen_rtx_LSHIFTRT (word_mode, operands[1],
+						  data_size_shift));
+      a0 = force_reg (word_mode, gen_rtx_XOR (word_mode, a0, crc_part));
+    }
+  rtx tgt = simplify_gen_subreg (word_mode, operands[0],
+				 GET_MODE (operands[0]), 0);
+  riscv_emit_move (tgt, a0);
+}
+
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
 #define TARGET_ASM_ALIGNED_HI_OP "\t.half\t"
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index b320ad0210e..6125b3637df 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -90,9 +90,9 @@ (define_c_enum "unspec" [
   ;; Workaround for HFmode without hardware extension
   UNSPEC_FMV_SFP16_X
 
-  ;; XTheadFmv moves
-  UNSPEC_XTHEADFMV
-  UNSPEC_XTHEADFMV_HW
+  ;; CRC unspecs
+  UNSPEC_CRC
+  UNSPEC_CRC_REV
 ])
 
 (define_c_enum "unspecv" [
diff --git a/gcc/configure b/gcc/configure
index c83e09beea9..408fc491de0 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -36283,7 +36283,7 @@ $as_echo "$as_me: executing $ac_file commands" >&6;}
     "depdir":C) $SHELL $ac_aux_dir/mkinstalldirs $DEPDIR ;;
     "gccdepdir":C)
   ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/mkinstalldirs build/$DEPDIR
-  for lang in $subdirs c-family common analyzer text-art rtl-ssa
+  for lang in $subdirs c-family common analyzer text-art rtl-ssa sym-exec
   do
       ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/mkinstalldirs $lang/$DEPDIR
   done ;;
diff --git a/gcc/crc-verification.cc b/gcc/crc-verification.cc
new file mode 100644
index 00000000000..4d33c12c10b
--- /dev/null
+++ b/gcc/crc-verification.cc
@@ -0,0 +1,1326 @@
+/*
+   Execute symbolically all paths of the function.  Iterate loops only once․
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.   */
+
+#include "crc-verification.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "tree.h"
+#include "gimple.h"
+#include "ssa.h"
+#include "gimple-iterator.h"
+#include "tree-cfg.h"
+#include "cfganal.h"
+#include "tree-ssa-loop.h"
+
+/* Check whether defined variable is used outside the loop, only
+   CRC's definition is allowed to be used outside the loop.  */
+
+bool
+crc_symbolic_execution::is_used_outside_the_loop (tree def)
+{
+  imm_use_iterator imm_iter;
+  gimple *use_stmt;
+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)
+    {
+      if (!flow_bb_inside_loop_p (m_crc_loop, use_stmt->bb))
+	{
+	  if (is_a<gphi *> (use_stmt)
+	      && as_a<gphi *> (use_stmt) == m_output_crc)
+	    return false;
+	  if (dump_file)
+	    fprintf (dump_file, "Defined variable is used outside the loop.\n");
+	  return true;
+	}
+    }
+  return false;
+}
+
+/* Calculate value of the rhs operation of GS assigment statement
+   and assign it to lhs variable.  */
+
+bool
+crc_symbolic_execution::execute_assign_statement (const gassign *gs)
+{
+  enum tree_code rhs_code = gimple_assign_rhs_code (gs);
+  tree lhs = gimple_assign_lhs (gs);
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file, "lhs type : %s \n",
+	     get_tree_code_name (TREE_CODE (lhs)));
+
+  /* This will filter some normal cases too.  Ex.  usage of array.  */
+  if (TREE_CODE (lhs) != SSA_NAME)
+    return false;
+
+  /* Check uses only when m_output_crc is known.  */
+  if (m_output_crc)
+    if (is_used_outside_the_loop (lhs))
+      return false;
+
+  state *current_state = m_states.last ();
+
+  if (gimple_num_ops (gs) == 2)
+    {
+      tree op1 = gimple_assign_rhs1 (gs);
+      switch (rhs_code)
+	{
+	  case BIT_NOT_EXPR:
+	    return current_state->do_complement (op1, lhs);
+	  case NOP_EXPR:
+	  case SSA_NAME:
+	  case VAR_DECL:
+	  case INTEGER_CST:
+	    return current_state->do_assign (op1, lhs);
+	  default:
+	    {
+	      if (dump_file)
+		fprintf (dump_file,
+			 "Warning, encountered unsupported unary operation "
+			 "with %s code while executing assign statement!\n",
+			 get_tree_code_name (rhs_code));
+	      return false;
+	    }
+	}
+    }
+  else if (gimple_num_ops (gs) == 3)
+    {
+      tree op1 = gimple_assign_rhs1 (gs);
+      tree op2 = gimple_assign_rhs2 (gs);
+      switch (rhs_code)
+	{
+	  case LSHIFT_EXPR:
+	    return current_state->do_shift_left (op1, op2, lhs);
+	  case RSHIFT_EXPR:
+	    return current_state->do_shift_right (op1, op2, lhs);
+	  case BIT_AND_EXPR:
+	    return current_state->do_and (op1, op2, lhs);
+	  case BIT_IOR_EXPR:
+	    return current_state->do_or (op1, op2, lhs);
+	  case BIT_XOR_EXPR:
+	    return current_state->do_xor (op1, op2, lhs);
+	  case PLUS_EXPR:
+	    return current_state->do_add (op1, op2, lhs);
+	  case MINUS_EXPR:
+	    return current_state->do_sub (op1, op2, lhs);
+	  case MULT_EXPR:
+	    return current_state->do_mul (op1, op2, lhs);
+	  default:
+	    {
+	      if (dump_file)
+		fprintf (dump_file,
+			 "Warning, encountered unsupported binary operation "
+			 "with %s code while executing assign statement!\n",
+			 get_tree_code_name (rhs_code));
+	      return false;
+	    }
+	}
+    }
+  else
+    {
+      if (dump_file)
+	fprintf (dump_file,
+		 "Warning, encountered unsupported operation, "
+		 "with %s code while executing assign statement!\n",
+		 get_tree_code_name (rhs_code));
+      return false;
+    }
+  return true;
+}
+
+/* Add E edge into the STACK if it doesn't have an immediate
+   successor back edge.
+
+   When loop counter is checked in the if condition,
+   we mustn't continue on real path as we want to stop the execution before
+   the second iteration.  */
+
+bool
+crc_symbolic_execution::add_edge (edge e, auto_vec<edge> &stack)
+{
+  if (EDGE_COUNT (e->dest->succs) == 0)
+    return false;
+
+  edge next_bb_edge = EDGE_SUCC (e->dest, 0);
+  if (next_bb_edge && (next_bb_edge->flags & EDGE_DFS_BACK))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Won't iterate loop once more, yet.\n");
+      return keep_states ();
+    }
+  else
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Adding the edge into the stack.\n");
+
+      /* If the result of the condition is true/false,
+	 continue execution only by the true/false branch.  */
+      stack.quick_push (e);
+    }
+  return true;
+}
+
+/* Add next basic blocks of the conditional block COND_BB
+   for the execution path into the STACK.
+   If the condition depends on symbolic values, keep both edges.
+   If the condition is true, keep true edge, else - false edge.
+   Returns true if addition succeeds.  Otherwise - false.  */
+
+bool
+crc_symbolic_execution::add_next_bbs (basic_block cond_bb,
+				      state *new_branch_state,
+				      auto_vec<edge> &stack)
+{
+  edge true_edge;
+  edge false_edge;
+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);
+
+  /* When the condition depends on symbolic values.  */
+  if (new_branch_state->get_last_cond_status () == CS_SYM)
+    {
+      /* Supported CRC cases may have only two states.  */
+      if (m_states.length () == 2)
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, "Going to add a new state, "
+				"but there's already two states.\n");
+	  return false;
+	}
+      /* Add true branch's state into the states.
+	 False branch's state will be kept in the current state.  */
+      m_states.quick_push (new_branch_state);
+
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Adding true and false edges into the stack.\n");
+
+      /* Add outgoing edges to the stack.  */
+      stack.quick_push (false_edge);
+      stack.quick_push (true_edge);
+
+      return true;
+    }
+  /* When the condition evaluates to true.  */
+  else if (new_branch_state->get_last_cond_status () == CS_TRUE)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Condition is true.\n");
+      add_edge (true_edge, stack);
+    }
+  /* When the condition evaluates to false.  */
+  else if (new_branch_state->get_last_cond_status () == CS_FALSE)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Condition is false.\n");
+      add_edge (false_edge, stack);
+    }
+  else
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Something went wrong "
+			    "during handling conditional statement.\n");
+      return false;
+    }
+
+  /* When we continue execution of only one path,
+     there's no need of new state.  */
+  delete new_branch_state;
+  return true;
+}
+
+/* Add conditions depending on symbolic variables in the states.
+
+   Keep conditions of each branch execution in its state.
+     Ex.
+       if (a == 0)  // a's value is unknown
+
+       new_branch_state.keep (a==0)
+       current_state.keep (a!=0)
+
+     The condition is kept in the bit level.
+     For ex.
+     If a's size is 8 and its value is {symb_a, 0, 0, 0, 0, 0, 0, 0},
+     then for a == 0 we'll have symb_a == 0 condition.  */
+
+bool
+crc_symbolic_execution::add_condition (const gcond *cond,
+				       state *current_state,
+				       state *new_branch_state)
+{
+  tree lhs = gimple_cond_lhs (cond);
+  tree rhs = gimple_cond_rhs (cond);
+  switch (gimple_cond_code (cond))
+    {
+      case EQ_EXPR:
+	{
+	  new_branch_state->add_equal_cond (lhs, rhs);
+	  if (new_branch_state->get_last_cond_status () == CS_SYM)
+	    current_state->add_not_equal_cond (lhs, rhs);
+	  return true;
+	}
+      case NE_EXPR:
+	{
+	  new_branch_state->add_not_equal_cond (lhs, rhs);
+	  if (new_branch_state->get_last_cond_status () == CS_SYM)
+	    current_state->add_equal_cond (lhs, rhs);
+	  return true;
+	}
+      case GT_EXPR:
+	{
+	  new_branch_state->add_greater_than_cond (lhs, rhs);
+	  if (new_branch_state->get_last_cond_status () == CS_SYM)
+	    current_state->add_less_or_equal_cond (lhs, rhs);
+	  return true;
+	}
+      case LT_EXPR:
+	{
+	  new_branch_state->add_less_than_cond (lhs, rhs);
+	  if (new_branch_state->get_last_cond_status () == CS_SYM)
+	    current_state->add_greater_or_equal_cond (lhs, rhs);
+	  return true;
+	}
+      case GE_EXPR:
+	{
+	  new_branch_state->add_greater_or_equal_cond (lhs, rhs);
+	  if (new_branch_state->get_last_cond_status () == CS_SYM)
+	    current_state->add_less_than_cond (lhs, rhs);
+	  return true;
+	}
+      case LE_EXPR:
+	{
+	  new_branch_state->add_less_or_equal_cond (lhs, rhs);
+	  if (new_branch_state->get_last_cond_status () == CS_SYM)
+	    current_state->add_greater_than_cond (lhs, rhs);
+	  return true;
+	}
+      default:
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, "Unsupported condition.\n");
+	  return false;
+	}
+    }
+}
+
+/* Create new states for true and false branches.
+   Keep conditions in new created states.  */
+
+bool
+crc_symbolic_execution::resolve_condition (const gcond *cond,
+					   auto_vec<edge> &stack)
+{
+  state *current_state = m_states.last ();
+  state *new_branch_state = new state (*current_state);
+
+  /* Create new states and for true and false branches keep corresponding
+     conditions.  */
+  if (!add_condition (cond, current_state, new_branch_state))
+    return false;
+
+  /* Add true and false edges to the stack.  */
+  return add_next_bbs (cond->bb, new_branch_state, stack);
+}
+
+/* If final states are less than two, add new FINAL_STATE and return true.
+   Otherwise, return false.
+   Supported CRC cases may not have more than two final states.  */
+bool crc_symbolic_execution::add_final_state (state *final_state)
+{
+  if (m_final_states.length () < 2)
+      m_final_states.quick_push (final_state);
+  else
+    {
+      if (dump_file)
+	fprintf (dump_file,
+		 "There are already two final states\n");
+      return false;
+    }
+    return true;
+}
+
+/* Keep the state of the executed path in final states.  */
+
+bool crc_symbolic_execution::keep_states ()
+{
+  if (m_states.is_empty ())
+    return false;
+
+  if (!add_final_state (m_states.last ()))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Couldn't add final state.\n");
+      return false;
+    }
+
+  m_states.pop ();
+  return true;
+}
+
+/* Execute gimple statements of BB.
+   Keeping values of variables in the state.  */
+
+bool
+crc_symbolic_execution::execute_bb_gimple_statements (basic_block bb,
+						      auto_vec<edge> &stack)
+{
+  for (gimple_stmt_iterator bsi = gsi_start_bb (bb);
+       !gsi_end_p (bsi); gsi_next (&bsi))
+    {
+      gimple *gs = gsi_stmt (bsi);
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	{
+	  fprintf (dump_file, "Executing ");
+	  print_gimple_stmt (dump_file, gs, dump_flags);
+	}
+      switch (gimple_code (gs))
+	{
+	  case GIMPLE_ASSIGN:
+	    {
+	      if (!execute_assign_statement (as_a<const gassign *> (gs)))
+		return false;
+	      break;
+	    }
+	  case GIMPLE_COND:
+	    {
+	      return resolve_condition (as_a<const gcond *> (gs), stack);
+	    }
+	  /* Just skip debug statements.  */
+	  case GIMPLE_DEBUG:
+	    break;
+	  default:
+	    {
+	      if (dump_file)
+		fprintf (dump_file,
+			 "Warning, encountered unsupported statement, "
+			 "while executing gimple statements!\n");
+	      return false;
+	    }
+	}
+    }
+
+  /* Add each outgoing edge of the current block to the stack,
+     despite back edges.
+     This code isn't reachable if the last statement of the basic block
+     is a conditional statement or return statement.
+     Those cases are handled separately.
+     We mustn't encounter back edges here.  */
+
+  edge out_edge;
+  edge_iterator ei;
+  FOR_EACH_EDGE (out_edge, ei, bb->succs)
+    if (!(out_edge->flags & EDGE_DFS_BACK))
+      stack.quick_push (out_edge);
+    else
+      return false;
+
+  return true;
+}
+
+/* Assign values of phi instruction to its result.
+   Keep updated values in the state.  */
+
+bool
+crc_symbolic_execution::execute_bb_phi_statements (basic_block bb,
+						   edge incoming_edge)
+{
+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+      gphi *phi = gsi.phi ();
+      tree lhs = gimple_phi_result (phi);
+
+      /* Check uses only when m_output_crc is known.  */
+      if (m_output_crc)
+	if (is_used_outside_the_loop (lhs))
+	  return false;
+
+      /* Don't consider virtual operands.  */
+      if (virtual_operand_p (lhs))
+	continue;
+
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	{
+	  fprintf (dump_file, "Determining the value "
+			      "for the following phi.\n");
+	  print_gimple_stmt (dump_file, phi, dump_flags);
+	}
+
+      tree rhs = PHI_ARG_DEF_FROM_EDGE (phi, incoming_edge);
+
+      state *current_state = m_states.last ();
+      if (!current_state->do_assign (rhs, lhs))
+	return false;
+    }
+  return true;
+}
+
+/* Execute all statements of BB.
+   Keeping values of variables in the state.  */
+
+bool
+crc_symbolic_execution::execute_bb_statements (basic_block bb,
+					       edge incoming_edge,
+					       auto_vec<edge> &stack)
+{
+  if (!execute_bb_phi_statements (bb, incoming_edge))
+    return false;
+
+  return execute_bb_gimple_statements (bb, stack);
+}
+
+/* If the phi statements' result variables have initial constant value in the
+   beginning of the loop, initialize those variables.  */
+
+void
+assign_known_vals_to_header_phis (state *state, basic_block bb)
+{
+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+
+      gphi *phi = gsi.phi ();
+      tree lhs = gimple_phi_result (phi);
+
+      /* Don't consider virtual operands.  */
+      if (virtual_operand_p (lhs))
+	continue;
+
+      if (TREE_CODE (PHI_ARG_DEF (phi, phi->nargs - 1)) == INTEGER_CST)
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "First value of phi is a constant, "
+				  "assigning the number to ");
+	      print_generic_expr (dump_file, lhs, dump_flags);
+	      fprintf (dump_file, " variable.\n");
+	    }
+	  state->do_assign (PHI_ARG_DEF (phi, phi->nargs - 1), lhs);
+	}
+    }
+}
+
+/* If the phi statements' result variables have initial constant value in the
+   beginning of the loop, initialize those variables with
+   the value calculated during the previous iteration.  */
+
+bool
+assign_calc_vals_to_header_phis (const vec<state *> &prev_states,
+				 state *curr_state,
+				 basic_block bb)
+{
+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+      gphi *phi = gsi.phi ();
+      tree lhs = gimple_phi_result (phi);
+
+      /* Don't consider virtual operands.  */
+      if (virtual_operand_p (lhs))
+	continue;
+
+      if (TREE_CODE (PHI_ARG_DEF (phi, phi->nargs - 1)) == INTEGER_CST)
+	{
+	  tree input_tree = PHI_ARG_DEF (phi, 0);
+	  value * val_st1 = prev_states[0]->get_value (input_tree),
+	      *val_st2 = prev_states[1]->get_value (input_tree);
+	  if (!state::is_bit_vector (val_st1)
+	      || !state::is_bit_vector (val_st2))
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file, "The calculated values of  ");
+		  print_generic_expr (dump_file, input_tree, dump_flags);
+		  fprintf (dump_file, " variable is not constant.\n");
+		}
+	      return false;
+	    }
+	  else if (!state::check_const_value_equality (val_st1, val_st2))
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file, "The calculated values of  ");
+		  print_generic_expr (dump_file, input_tree, dump_flags);
+		  fprintf (dump_file, " variable is different in the previous "
+				      "iteration paths.\n");
+		}
+	      return false;
+	    }
+	  else
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file, "Assigning calculated number to ");
+		  print_generic_expr (dump_file, lhs, dump_flags);
+		  fprintf (dump_file, " variable.\n");
+		}
+	      unsigned HOST_WIDE_INT calc_number
+		  = state::make_number (val_st1);
+	      tree calc_num_tree = build_int_cstu (TREE_TYPE (lhs),
+						   calc_number);
+	      curr_state->do_assign (calc_num_tree, lhs);
+	    }
+	}
+    }
+  return true;
+}
+
+/* Create initial state of header BB variables which have constant values.
+   If it is the first iteration of the loop, initialise variables with the
+   initial values, otherwise initialise the variable with the value calculated
+   during the previous execution.  */
+
+state *
+crc_symbolic_execution::create_initial_state (basic_block bb)
+{
+  state *curr_state = new state;
+  if (!m_final_states.is_empty ())
+    {
+      if (!assign_calc_vals_to_header_phis (m_final_states, curr_state, bb))
+	return nullptr;
+      state::remove_states (&m_final_states);
+    }
+  else
+    assign_known_vals_to_header_phis (curr_state, bb);
+  return curr_state;
+}
+
+/* Symbolically execute the CRC loop, doing one iteration.  */
+
+bool
+crc_symbolic_execution::symb_execute_crc_loop ()
+{
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file, "\n\nExecuting the loop with symbolic values.\n\n");
+
+  basic_block header_bb = m_crc_loop->header;
+  state *curr_state = create_initial_state (header_bb);
+  if (!curr_state)
+    return false;
+
+  m_states.quick_push (curr_state);
+
+  auto_vec<edge> stack (m_crc_loop->num_nodes);
+
+  if (!execute_bb_gimple_statements (header_bb, stack))
+    return false;
+
+  /* Successor BB's are added into the stack
+     from the execute_bb_gimple_statements function.  */
+  while (!stack.is_empty ())
+    {
+      /* Look at the edge on the top of the stack.  */
+      edge e = stack.last ();
+      stack.pop ();
+
+      /* Get destination block of the edge.  */
+      basic_block dest_bb = e->dest;
+
+      /* Execute only basic blocks of the m_crc_loop.
+	 At the end of the execution path save states in final states.  */
+      if (!flow_bb_inside_loop_p (m_crc_loop, dest_bb))
+	{
+	  m_is_last_iteration = true;
+	  if (!keep_states ())
+	    return false;
+	  continue;
+	}
+
+      /* Execute statements.  */
+      if (!execute_bb_statements (dest_bb, e, stack))
+	return false;
+    }
+  return true;
+}
+
+/* Determine which bit of the DATA must be 1.
+   We assume that last bit must be 1.  */
+
+unsigned HOST_WIDE_INT
+determine_index (tree data, bool is_shift_left)
+{
+  if (is_shift_left)
+   /* This won't work correctly in the case when data's size is larger,
+      but MSB is checked for the middle bit.  */
+    return tree_to_uhwi (TYPE_SIZE (TREE_TYPE (data))) - 1;
+  return 0;
+}
+
+/* Assign appropriate values to data, CRC
+   and other phi results to calculate the polynomial.  */
+
+void
+assign_vals_to_header_phis (state *polynomial_state, basic_block bb,
+			    gphi *crc_phi, gphi *data_phi,
+			    bool is_shift_left)
+{
+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+
+      gphi *phi = gsi.phi ();
+      tree lhs = gimple_phi_result (phi);
+
+      /* Don't consider virtual operands.  */
+      if (virtual_operand_p (lhs))
+	continue;
+
+      if ((data_phi && phi == data_phi) || (!data_phi && phi == crc_phi))
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "Assigning the required value to ");
+	      print_generic_expr (dump_file, lhs, dump_flags);
+	      fprintf (dump_file, " variable.\n");
+	    }
+	  polynomial_state->do_assign_pow2 (lhs,
+					    determine_index (lhs,
+							     is_shift_left));
+	}
+      else if (phi == crc_phi)
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "Assigning 0 value to ");
+	      print_generic_expr (dump_file, lhs, dump_flags);
+	      fprintf (dump_file, " variable.\n");
+	    }
+	  polynomial_state->do_assign (build_zero_cst (TREE_TYPE (lhs)), lhs);
+	}
+      else if (TREE_CODE (PHI_ARG_DEF (phi, phi->nargs - 1)) == INTEGER_CST)
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "First value of phi is a constant, "
+				  "assigning the number to ");
+	      print_generic_expr (dump_file, lhs, dump_flags);
+	      fprintf (dump_file, " variable.\n");
+	    }
+	  polynomial_state->do_assign (PHI_ARG_DEF (phi, phi->nargs - 1), lhs);
+	}
+      else
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "First value of phi isn't constant, "
+				  "assigning to ");
+	      print_generic_expr (dump_file, lhs, dump_flags);
+	      fprintf (dump_file, " variable.\n");
+	    }
+	  polynomial_state->do_assign (build_zero_cst (TREE_TYPE (lhs)), lhs);
+	}
+    }
+}
+
+/* Execute the loop, which calculates CRC with initial values,
+   to calculate the polynomial.  */
+
+bool
+crc_symbolic_execution::execute_crc_loop (gphi *crc_phi,
+					  gphi *data_phi,
+					  bool is_shift_left)
+{
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file, "\n\nTrying to calculate the polynomial.\n\n");
+
+  m_states.quick_push (new state);
+
+  basic_block bb = m_crc_loop->header;
+  assign_vals_to_header_phis (m_states.last (), bb, crc_phi, data_phi,
+			      is_shift_left);
+
+  auto_vec<edge> stack (m_crc_loop->num_nodes);
+
+  if (!execute_bb_gimple_statements (bb, stack))
+    return false;
+
+  /* stack may not be empty.  Successor BB's are added into the stack
+     from the execute_bb_gimple_statements function.  */
+  while (!stack.is_empty ())
+    {
+      /* Look at the edge on the top of the stack.  */
+      edge e = stack.last ();
+      stack.pop ();
+
+      /* Get dest block of the edge.  */
+      basic_block bb = e->dest;
+
+      /* Execute only basic blocks of the m_crc_loop.  */
+      if (!flow_bb_inside_loop_p (m_crc_loop, bb))
+	continue;
+
+      /* Execute statements.  */
+      if (!execute_bb_statements (bb, e, stack))
+	return false;
+    }
+
+  if (m_final_states.length () != 1)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "The number of states is not one when executed "
+			    "the loop for calculating the polynomial.\n");
+      return false;
+    }
+  return true;
+}
+
+/* Return true if all bits of the POLYNOMIAL are constants (0 or 1).
+   Otherwise return false.  */
+
+bool
+polynomial_is_known (const value *polynomial)
+{
+  for (size_t i = 0; i < polynomial->length (); i++)
+    {
+      if (!is_a<bit *> ((*polynomial)[i]))
+	return false;
+    }
+  return true;
+}
+
+/* Execute the loop, which is expected to calculate CRC,
+   to extract polynomial, assigning real numbers to CRC and data.
+   Returns a pair, first value of the pair is the tree containing
+   the value of the polynomial, second is the calculated polynomial.
+   The pair may contain nullptr.  */
+
+std::pair <tree, value *>
+crc_symbolic_execution::extract_polynomial (gphi *crc_phi, gphi *data_phi,
+					    bool is_shift_left)
+{
+  if (!execute_crc_loop (crc_phi, data_phi, is_shift_left))
+    return std::make_pair (nullptr, nullptr);
+
+  if (m_final_states.length () != 1)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "The number of states isn't one "
+			    "after executing the loop.\n");
+      return std::make_pair (nullptr, nullptr);
+    }
+  state *polynomial_state = m_final_states.last ();
+
+  /* Get the tree which will contain the value of the polynomial
+     at the end of the loop.  */
+  tree calculated_crc = PHI_ARG_DEF (crc_phi, 0);
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+      fprintf (dump_file, "Getting the value of ");
+      print_generic_expr (dump_file, calculated_crc, dump_flags);
+      fprintf (dump_file, " variable.\n");
+    }
+
+  /* Get the value (bit vector) of the tree (it may be the polynomial).  */
+  value *polynomial = polynomial_state->get_value (calculated_crc);
+  if (!polynomial)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Polynomial's value is null.\n");
+      return std::make_pair (nullptr, nullptr);
+    }
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+      /* Note: It may not be the real polynomial.
+	 If it's a bit reflected CRC,
+	 then to get a real polynomial,
+	 it must be reflected and 1 bit added.  */
+      fprintf (dump_file, "Polynomial's value is ");
+      state::print_value (polynomial);
+    }
+
+  /* Check that polynomial's all bits are constants.  */
+  if (!polynomial_is_known (polynomial))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Polynomial's value is not constant.\n");
+      return std::make_pair (nullptr, nullptr);
+    }
+
+  return std::make_pair (calculated_crc, polynomial);
+}
+
+
+/**************************** LFSR MATCHING *********************************/
+
+
+/* Return true if CONST_BIT value equals to 1.
+   Otherwise, return false.  */
+
+bool
+is_one (value_bit *const_bit)
+{
+  return is_a<bit *> (const_bit)
+	 && (as_a<bit *> (const_bit))->get_val () == 1;
+}
+
+/* Return true if BIT is symbolic,
+   its index is same as LFSR bit's index (LFSR_BIT_INDEX)
+   and the origin is same as CRC_ORIGIN.  */
+
+bool
+is_a_valid_symb (value_bit *bit, tree crc_origin, size_t lfsr_bit_index)
+{
+  if (!is_a<symbolic_bit *> (bit))
+    return false;
+
+  symbolic_bit *sym_bit = as_a<symbolic_bit *> (bit);
+  bool is_correct_index = (sym_bit->get_index () == lfsr_bit_index);
+  bool is_same_crc_origin = (sym_bit->get_origin () == crc_origin);
+  return is_correct_index && is_same_crc_origin;
+}
+
+/* Return true if the BIT is a valid crc[LFSR_BIT_INDEX] ^ 1,
+   where i is a whole number and left part's origin is same as CRC_ORIGIN.
+   LFSR_BIT_INDEX is the index of the LFSR bit from the same position as in CRC.
+
+   If there is lfsr[8] at LFSR value vectors' 9-th bit,
+   when in the CRC vectors' 9-th bit's value must be
+   crc[8].
+
+   Otherwise, return false.  */
+
+bool
+is_a_valid_xor_one (value_bit *bit, tree crc_origin, size_t lfsr_bit_index)
+{
+  if (is_a<bit_xor_expression *> (bit))
+    {
+      bit_xor_expression *xor_exp = as_a<bit_xor_expression *> (bit);
+      if (is_one (xor_exp->get_right ()))
+	return is_a_valid_symb (xor_exp->get_left (), crc_origin,
+				lfsr_bit_index);
+      return false;
+    }
+  return false;
+}
+
+/* Return true, if CONDITION_EXP checks CRC's MSB/LSB value
+   (under which xor is/not done).
+   Otherwise, return false.  */
+
+bool
+may_be_xors_condition (tree crc_origin, value_bit *condition_exp,
+		       size_t sb_index)
+{
+  if (!crc_origin)
+    return false;
+
+  if (!condition_exp)
+    return false;
+
+  /* The CONDITION_EXP of CRC may be a symbolic bit, if CRC is xor-ed with
+     the data, and updated CRC's significant bit is checked.
+     So, the CONDITION_EXP will be CRC's condition if it's origin is the same as
+     CRC_ORIGIN, and it's index equals to checked significant bit's index.  */
+  if (is_a<symbolic_bit *> (condition_exp))
+    {
+      symbolic_bit *condition_symbolic = as_a<symbolic_bit *> (condition_exp);
+      return crc_origin == condition_symbolic->get_origin ()
+	     && sb_index == condition_symbolic->get_index ();
+    }
+    /* The CONDITION_EXP of CRC may be a bit_xor_expression,
+       if CRC and data are xor-ed only for significant bit's check.
+       I.e.  CONDITION_EXP in this case may be crc[]^data[].
+       So, the CONDITION_EXP will be CRC's condition if it's left or right
+       part's origin is the same as CRC_ORIGIN, and it's index equals to checked
+       significant bit's index.  */
+  else if (is_a<bit_xor_expression *> (condition_exp))
+    {
+      bit_xor_expression *condition_xor_exp = as_a<bit_xor_expression *>
+	  (condition_exp);
+      if (!(is_a<symbolic_bit *> (condition_xor_exp->get_left ())
+	    && is_a<symbolic_bit *> (condition_xor_exp->get_right ())))
+	return false;
+
+      symbolic_bit *cond_left
+	  = as_a<symbolic_bit *> (condition_xor_exp->get_left ());
+      symbolic_bit *cond_right
+	  = as_a<symbolic_bit *> (condition_xor_exp->get_right ());
+      bool cond_left_is_crc = (crc_origin == cond_left->get_origin ()
+			       && sb_index == cond_left->get_index ());
+      bool cond_right_is_crc = (crc_origin == cond_right->get_origin ()
+				&& sb_index == cond_right->get_index ());
+      return cond_left_is_crc || cond_right_is_crc;
+    }
+  return false;
+}
+
+/* Check whether the condition is checked for significant bit being 0 or 1.
+   If IS_ONE is 1, when check whether the significant bit is 1 (xor branch),
+   if 0, whether the significant bit is 0 (not xor branch).  */
+
+bool
+is_crc_xor_condition (tree crc_origin, unsigned char is_one,
+		      size_t sb_index, state *final_state)
+{
+  /* The CRC cases we detect must contain only one condition related to CRC.  */
+  if (final_state->get_conditions ().elements () != 1)
+    return false;
+
+  auto condition_iter = final_state->get_conditions ().begin ();
+  if (!is_a<bit_condition *> (*condition_iter))
+    return false;
+
+  /* If the condition is for checking MSB/LSB, then
+     if is_one is 1 and the condition is for checking MSB/LSB being one, or
+     if is_one is 0 and condition is for checking MSB/LSB being 0
+     return true, otherwise - false.  */
+  value_bit *cond_exp = (*condition_iter)->get_left ();
+  if (may_be_xors_condition (crc_origin, cond_exp, sb_index))
+    {
+      if (!is_a<bit *> ((*condition_iter)->get_right ()))
+	return false;
+
+      bit_condition *condition = as_a<bit_condition *> (*condition_iter);
+      unsigned char comparison_val
+	  = as_a<bit *> ((*condition_iter)->get_right ())->get_val ();
+      if (condition->get_code () == EQ_EXPR)
+	return comparison_val == is_one;
+      if (condition->get_code () == NE_EXPR)
+	return comparison_val != is_one;
+      return false;
+    }
+  return false;
+}
+
+/* Check whether LSB/MSB of LFSR and calculated (maybe)CRC match.
+   If MSB is checked in the CRC loop, then here we check LSB, or vice versa.
+   CHECKED_SB_VALUE indicates which state of CRC value is checked.
+   If the CHECKED_SB_VALUE is 1 - then xor-ed CRC value is checked,
+   otherwise, not xor-ed is checked.  */
+
+bool
+given_sb_match (value_bit *crc, value_bit *lfsr,
+		unsigned short checked_sb_value)
+{
+  /* If LFSR's MSB/LSB value is a constant (0 or 1),
+     then CRC's MSB/LSB must have the same value.  */
+  if (is_a<bit *> (lfsr))
+    {
+      if (!((is_a<bit *> (crc)
+	     && as_a<bit *> (crc)->get_val ()
+		== as_a<bit *> (lfsr)->get_val ())))
+	return false;
+      return true;
+    }
+    /* If LFSR's MSB/LSB value is a symbolic_bit
+       (that means MSB/LSB of the polynomial is 1),
+       then CRC's MSB/LSB must be equal to CHECKED_SB_VALUE.  */
+  else if (is_a<symbolic_bit *> (lfsr))
+    {
+      if (!(is_a<bit *> (crc)
+	    && (as_a<bit *> (crc)->get_val () == checked_sb_value)))
+	return false;
+      return true;
+    }
+  return false;
+}
+
+/* Check whether significant bit of LFSR and calculated (maybe)CRC match.  */
+
+bool
+sb_match (const value *lfsr, const value *crc_value, size_t sb_index,
+	  size_t it_end, unsigned short value)
+{
+  /* If it's bit-forward CRC, check 0 bit's value.  */
+  if (sb_index == it_end - 1)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Checking 0 bit.\n");
+
+      if (!given_sb_match ((*crc_value)[0], (*lfsr)[0], value))
+	return false;
+    }
+    /* If it's bit-reversed CRC, check last bit's value.  */
+  else if (sb_index == 0)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Checking %zu bit.\n", it_end);
+
+      if (!given_sb_match ((*crc_value)[it_end], (*lfsr)[it_end], value))
+	return false;
+    }
+  else
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Significant bit index is incorrect.\n");
+    }
+  return true;
+}
+
+/* Match the CRC to the LFSR, where CRC's all bit values are
+   symbolic_bit or symbolic_bit ^ 1, besides MSB/LSB (it may be constant).  */
+
+bool
+lfsr_and_crc_bits_match (const value *lfsr, const value *crc_state,
+			 tree crc_origin, size_t i, size_t it_end,
+			 size_t sb_index, unsigned short checked_sb_value)
+{
+
+  /* Check whether significant bits of LFSR and CRC match.  */
+  if (!sb_match (lfsr, crc_state, sb_index, it_end, checked_sb_value))
+    return false;
+
+  for (; i < it_end; i++)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Checking %zu bit.\n", i);
+
+      /* Check the case when in lfsr we have LFSR (i)^LFSR (SBi),
+	 where 0<i<LFSR_size and SBi is the index of MSB/LSB (LFSR_size-1/0).
+	 In that case in crc_state (resulting CRC)
+	 we must have crc (i) ^ 1 case, when condition is true
+	 and crc (i) when condition is false,
+	 (as CRC is xor-ed with the polynomial only if the LSB/MSB is one)
+	 where k is a whole number.  */
+      if (is_a<bit_xor_expression *> ((*lfsr)[i]))
+	{
+	  size_t index = (as_a<bit_xor_expression *> ((*lfsr)[i]))->get_left ()
+	      ->get_index ();
+	  /* Check CRC value of xor branch.  */
+	  if (checked_sb_value == 1)
+	    {
+	      if (!(is_a_valid_xor_one ((*crc_state)[i], crc_origin, index)))
+		return false;
+	    }
+	  else /* Check CRC value of not xor branch.  */
+	    {
+	      if (!(is_a_valid_symb ((*crc_state)[i], crc_origin, index)))
+		return false;
+	    }
+	}
+	/* Check the case when in LFSR we have LFSR (i), where 0<i<LFSR_size.
+	   In that case in resulting CRC we must have crc (i) case,
+	   when condition is true or condition is false.
+	   If we have just LFSR (i), that means polynomial's i +/- 1 bit is 0,
+	   so despite CRC is xor-ed or not, we will have crc (i).  */
+      else if (is_a<symbolic_bit *> ((*lfsr)[i]))
+	{
+	  size_t index = (as_a<symbolic_bit *> ((*lfsr)[i]))->get_index ();
+	  if (!(is_a_valid_symb ((*crc_state)[i], crc_origin, index)))
+	    return false;
+	}
+      else
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, "Not expected expression in LFSR.\n");
+	  return false;
+	}
+    }
+  return true;
+}
+
+/* Return origin of CRC_BIT.
+   The first tree in loop, from which CRC's calculation is started.  */
+
+tree
+get_origin_of_crc_from_symb_bit (value_bit *crc_bit)
+{
+  if (is_a<symbolic_bit *> (crc_bit))
+    return as_a<symbolic_bit *> (crc_bit)->get_origin ();
+  return nullptr;
+}
+
+/* Return origin of CRC_BIT.  The first tree in loop, from which CRC's
+   calculation is started.  If the CRC_BIT is symbolic value, return its origin,
+   otherwise return its left part's origin (right must be 1 if its CRC's
+   value). */
+
+tree
+get_origin_of_crc (value_bit *crc_bit)
+{
+  tree origin = get_origin_of_crc_from_symb_bit (crc_bit);
+  if (origin)
+    return origin;
+  else if (is_a<bit_xor_expression *> (crc_bit))
+    {
+      value_bit *crc_bit_left
+	  = as_a<bit_xor_expression *> (crc_bit)->get_left ();
+      return get_origin_of_crc_from_symb_bit (crc_bit_left);
+    }
+  return nullptr;
+}
+
+/* Determine and initialize significant bit index
+   (if MSB is checked for CRC, then it's LSB index, and vice versa)
+   and the remaining part's begin and end.
+   SB_INDEX is the significant bit index.
+   IT_BEG is the beginning of the remaining part.
+   IT_END is the end of the remaining part.  */
+
+void
+init_sb_index_and_other_part_begin_end (size_t &it_beg, size_t &it_end,
+					size_t &sb_index, size_t crc_size,
+					bool is_bit_forward)
+{
+  it_end = crc_size;
+  if (is_bit_forward)
+    {
+      sb_index = it_end - 1;
+      it_beg = 1;
+    }
+  else
+    {
+      it_beg = 0;
+      sb_index = 0;
+      --it_end;
+    }
+}
+
+/* Return true if CRC_STATE matches the LFSR, otherwise - false.
+   LFSR - is created LFSR value for the given polynomial and CRC size.
+   CRC_STATE - contains CRC's calculated value and execution path condition.
+   IT_BEG and IT_END - are the border indexes of the value to be matched.
+   SB_INDEX - is the significant bit index of the CRC value,
+	      which will be checked separately.
+	      IF MSB is checked for CRC, when sb_index will be the index of LSB.
+	      Otherwise, will be the index of MSB.
+   CHECKED_SB_VALUE - is the significant bit's value (used for CRC's condition).
+	      If CHECKED_SB_VALUE is 1, it indicates that CRC_STATE is
+	      xor-ed path's state.
+	      If CHECKED_SB_VALUE is 0, then CRC_STATE is the state of the
+	      not xor branch.  */
+
+bool
+lfsr_matches_crc_state (const value *lfsr, state *crc_state, value *crc_value,
+			size_t it_beg, size_t it_end, size_t sb_index,
+			unsigned short checked_sb_value)
+{
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+      fprintf (dump_file, "Starting to match the following CRC value: ");
+      state::print_value (crc_value);
+    }
+
+  /* Get the origin (name) of the calculated CRC value.
+     All bits must have the same origin.  */
+  tree crc_origin = get_origin_of_crc ((*crc_value)[it_beg]);
+  if (!crc_origin)
+    return false;
+
+  if (!is_crc_xor_condition (crc_origin, checked_sb_value, sb_index, crc_state))
+    return false;
+
+  /* Check whether CRC_VALUE and LFSR bits match.  */
+  return lfsr_and_crc_bits_match (lfsr, crc_value, crc_origin,
+				  it_beg, it_end, sb_index, checked_sb_value);
+}
+
+/* Return true if in the CRC_VALUE exists xor expression.
+   Otherwise, return false.  */
+
+bool
+is_xor_state (value *crc_value, size_t it_beg, size_t it_end)
+{
+   for (unsigned j = it_beg; j < it_end; ++j)
+     if ((*crc_value)[j]->get_type () == BIT_XOR_EXPRESSION)
+       return true;
+   return false;
+}
+
+/* Keep the value of calculated CRC.  */
+
+value *
+get_crc_val (const gphi *crc_phi, state *curr_state)
+{
+  tree calculated_crc = PHI_ARG_DEF (crc_phi, 0);
+
+  if (!calculated_crc)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Couldn't get the potential CRC variable.\n");
+      return nullptr;
+    }
+
+  /* When the calculated CRC is constant, it's not possible to determine
+     whether the CRC has been calculated.  */
+  if (TREE_CODE (calculated_crc) == INTEGER_CST)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Calculated CRC is a constant.\n");
+      return nullptr;
+    }
+
+  /* Get calculated return value.  */
+  value * crc_value = curr_state->get_value (calculated_crc);
+
+  if (!crc_value)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "CRC is not in the state.\n");
+      return nullptr;
+    }
+  return crc_value;
+}
+
+/* Return true if all states from the FINAL_STATES match the LFSR,
+   otherwise - false.  */
+
+bool
+all_states_match_lfsr (value *lfsr, bool is_bit_forward, gphi *output_crc,
+		       const vec<state *> &final_states)
+{
+  if (final_states.length () != 2)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "The final states count isn't two.\n");
+      return false;
+    }
+
+  value *crc_xor_value = get_crc_val (output_crc, final_states[0]);
+  value *crc_not_xor_value = get_crc_val (output_crc, final_states[1]);
+
+  /* LFSR's size must be equal to CRC's size.  */
+  if ((crc_xor_value->length () != lfsr->length ())
+      || (crc_not_xor_value->length () != lfsr->length ()))
+    return false;
+
+  /* Depending on whether it is bit-forward or reversed CRC,
+     determine in which significant bit new value is added,
+     to examine that bit separately.
+     If in the CRC algorithm MSB (sb_index) is checked to be one for xor,
+     then here we check LSB separately (marginal bit).
+     If LSB (sb_index) is checked, then we separate MSB (marginal bit).  */
+  size_t it_beg, it_end, sb_index;
+  init_sb_index_and_other_part_begin_end (it_beg, it_end, sb_index,
+					  crc_xor_value->length (),
+					  is_bit_forward);
+
+    size_t xor_st_index = 0, not_xor_st_index = 1;
+  /* If first is not xor's state,
+     then the second state is assumed to be xor's state.  */
+  if (!is_xor_state (crc_xor_value, it_beg, it_end))
+    {
+      std::swap (crc_xor_value, crc_not_xor_value);
+      xor_st_index = 1;
+      not_xor_st_index = 0;
+    }
+
+  /*  If xor-ed CRC value doesn't match the LFSR value, return false.  */
+  if (!lfsr_matches_crc_state (lfsr, final_states[xor_st_index], crc_xor_value,
+			       it_beg, it_end, sb_index, 1))
+    return false;
+
+  /*  If not xor-ed CRC value doesn't match the LFSR value, return false.  */
+  if (!lfsr_matches_crc_state (lfsr, final_states[not_xor_st_index],
+			       crc_not_xor_value, it_beg, it_end, sb_index, 0))
+    return false;
+
+  return true;
+}
\ No newline at end of file
diff --git a/gcc/crc-verification.h b/gcc/crc-verification.h
new file mode 100644
index 00000000000..b45eb242486
--- /dev/null
+++ b/gcc/crc-verification.h
@@ -0,0 +1,163 @@
+/*
+   Execute symbolically all paths of the loop, iterating the loop only once.
+   Calculate the value of the polynomial by executing loop with real values.
+   Check calculated that final states of return values match determined LFSR.
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.   */
+
+#ifndef GCC_CRC_VERIFICATION
+#define GCC_CRC_VERIFICATION
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "cfgloop.h"
+#include "sym-exec/state.h"
+
+class crc_symbolic_execution {
+
+ private:
+  /* A vector of states to keep the current state of each executed path.  */
+  vec<state *> m_states;
+
+  /* A vector of final states
+     to keep the returned_value and path conditions.  */
+  vec<state *> m_final_states;
+
+  /* Potential CRC loop, which must be executed symbolically,
+     to check whether it calculates CRC.  */
+  class loop *m_crc_loop;
+
+  /* Output CRC from the last block of the loop.  */
+  gphi *m_output_crc;
+
+  /* Indicates whether the loop execution brought to loop exit.
+     I.e. the condition of the loop is false.  */
+  bool m_is_last_iteration;
+
+  /* Returns true if the variable is used outside the loop.
+     Otherwise, returns false.  */
+  bool is_used_outside_the_loop (tree);
+
+  /* Add next basic blocks of the conditional block
+     for the execution path into the stack.
+     If the condition depends on symbolic values, keep both edges.
+     If the condition is true, keep true edge, else - false edge.
+     Returns true if addition succeed.  Otherwise - false.  */
+  bool add_next_bbs (basic_block, state *, auto_vec<edge> &);
+
+  /* Keep conditions depending on symbolic variables in the states.  */
+  static bool add_condition (const gcond *, state *, state *);
+
+  /* The function adds E edge into the STACK if it doesn't have an immediate
+     successor back edge.
+
+     When loop counter is checked in the if condition,
+     we mustn't continue on real path as we want to stop the execution before
+     the second iteration.  */
+  bool add_edge (edge, auto_vec<edge> &);
+
+  /* Create new state for true and false branch.
+     Keep conditions in new created states.  */
+  bool resolve_condition (const gcond *, auto_vec<edge> &);
+
+  /* If final states are less than two, adds new FINAL_STATE and returns true.
+   Otherwise, returns false.
+   In CRC cases we detect may not occur more than two final states.  */
+  bool add_final_state (state *);
+
+  /* Keep the state of the executed path in final states.  */
+  bool keep_states ();
+
+  bool execute_assign_statement (const gassign *);
+
+  /* Execute gimple statements of the basic block.
+     Keeping values of variables in the state.  */
+  bool execute_bb_gimple_statements (basic_block, auto_vec<edge> &);
+
+  /* Assign values of phi instruction to its result.
+     Keep updated values in the state.  */
+  bool execute_bb_phi_statements (basic_block, edge);
+
+  /* Execute all statements of the basic block.
+    Keeping values of variables in the state.  */
+  bool execute_bb_statements (basic_block, edge, auto_vec<edge> &);
+
+  /* Create initial state of header BB variables which have constant values.
+   If it is the first iteration of the loop, initialise variables with the
+   initial values, otherwise initialise the variable with the value calculated
+   during the previous execution.  */
+  state *create_initial_state (basic_block);
+
+/* Traverse function fun's all paths from the first basic block to the last.
+   Each time iterate loops only once.
+   Symbolically execute statements of each path.  */
+  bool traverse_function (function *);
+
+  /* Execute the loop, which calculates crc with initial values,
+   to calculate the polynomial.  */
+  bool execute_crc_loop (gphi *, gphi *, bool);
+
+ public:
+
+  /* Returns calculated polynomial by executing the loop
+     with concrete values.
+     First value of the pair is the tree containing the value of the polynomial,
+     second is the calculated polynomial.  The pair may contain nullptr.  */
+  std::pair <tree, value *>
+  extract_polynomial (gphi *, gphi *, bool);
+
+  /* Symbolically execute the CRC loop, doing one iteration.  */
+  bool symb_execute_crc_loop ();
+
+  const vec<state *> &get_final_states ()
+  {
+    return m_final_states;
+  }
+
+  bool is_last_iteration ()
+  {
+    return m_is_last_iteration;
+  }
+
+  crc_symbolic_execution (class loop *loop, gphi * output_crc) :
+      m_crc_loop (loop), m_output_crc (output_crc), m_is_last_iteration (false)
+  {
+    /* Reserve memory for the vectors of states.  */
+    int max_states = 2;
+    m_states.create (max_states);
+    m_final_states.create (max_states);
+  }
+
+  ~crc_symbolic_execution ()
+  {
+    /* Free memory.  */
+    state::clear_states (&m_states);
+    state::clear_states (&m_final_states);
+  }
+};
+
+
+/**************************** LFSR MATCHING *********************************/
+
+/* Returns true if all states match the LFSR, otherwise - false.  */
+bool all_states_match_lfsr (value *, bool, gphi *, const vec<state *> &);
+
+
+#endif //GCC_CRC_VERIFICATION
diff --git a/gcc/expr.cc b/gcc/expr.cc
index fc5e998e329..7f892c49217 100644
--- a/gcc/expr.cc
+++ b/gcc/expr.cc
@@ -66,7 +66,6 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-pretty-print.h"
 #include "flags.h"
 
-
 /* If this is nonzero, we do not bother generating VOLATILE
    around volatile memory references, and we are willing to
    output indirect addresses.  If cse is to follow, we reject
@@ -14063,3 +14062,394 @@ int_expr_size (const_tree exp)
 
   return tree_to_shwi (size);
 }
+
+/* Return the quotient of polynomial long division of x^2N by POLYNOMIAL
+   in GF (2^N).  */
+
+unsigned HOST_WIDE_INT
+gf2n_poly_long_div_quotient (unsigned HOST_WIDE_INT polynomial, size_t n)
+{
+  vec<short> x2n;
+  vec<bool> pol, q;
+  /* Create vector of bits, for the polynomial.  */
+  pol.create (n + 1);
+  for (size_t i = 0; i < n; i++)
+    {
+      pol.quick_push (polynomial & 1);
+      polynomial >>= 1;
+    }
+  pol.quick_push (1);
+
+  /* Create vector for x^2n polynomial.  */
+  x2n.create (2 * n - 1);
+  for (size_t i = 0; i < 2 * (n - 1); i++)
+    x2n.safe_push (0);
+  x2n.safe_push (1);
+
+  q.create (n);
+  for (size_t i = 0; i < n; i++)
+    q.quick_push (0);
+
+  /* Calculate the quotient of x^2n/polynomial.  */
+  for (int i = n - 1; i >= 0; i--)
+    {
+      int d = x2n[i + n - 1];
+      if (d == 0)
+	continue;
+      for (int j = i + n - 1; j >= i; j--)
+	x2n[j] ^= (pol[j - i]);
+      q[i] = 1;
+    }
+
+  /* Get the number from the vector of 0/1s.  */
+  unsigned HOST_WIDE_INT quotient = 0;
+  for (size_t i = 0; i < q.length (); i++)
+    {
+      quotient <<= 1;
+      quotient = quotient | q[q.length () - i - 1];
+    }
+  return quotient;
+}
+
+/* Calculate CRC for the initial CRC and given POLYNOMIAL.  */
+
+static unsigned HOST_WIDE_INT
+calculate_crc (unsigned HOST_WIDE_INT crc,
+	      unsigned HOST_WIDE_INT polynomial,
+	      unsigned crc_bits)
+{
+  crc = crc << (crc_bits - 8);
+  for (int i = 8; i > 0; --i)
+    {
+      if ((crc >> (crc_bits - 1)) & 1)
+	crc = (crc << 1) ^ polynomial;
+      else
+	crc <<= 1;
+    }
+
+  crc <<=  (sizeof (crc) * BITS_PER_UNIT - crc_bits);
+  crc >>=  (sizeof (crc) * BITS_PER_UNIT - crc_bits);
+
+  return crc;
+}
+
+/* Assemble CRC table with 256 elements for the given POLYNOM and CRC_BITS with
+   given ID.
+   ID is the identifier of the table, the name of the table is unique,
+   contains CRC size and the polynomial.
+   POLYNOM is the polynomial used to calculate the CRC table's elements.
+   CRC_BITS is the size of CRC, may be 8, 16, ... . */
+
+rtx
+assemble_crc_table (tree id, unsigned HOST_WIDE_INT polynom, unsigned crc_bits)
+{
+  unsigned table_el_n = 0x100;
+  tree ar = build_array_type (make_unsigned_type (crc_bits),
+			      build_index_type (size_int (table_el_n - 1)));
+  tree decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, id, ar);
+  SET_DECL_ASSEMBLER_NAME (decl, id);
+  DECL_ARTIFICIAL (decl) = 1;
+  rtx tab = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));
+  TREE_ASM_WRITTEN (decl) = 0;
+
+  /* Initialize table.  */
+  vec<tree, va_gc> *initial_values;
+  vec_alloc (initial_values, table_el_n);
+  for (size_t i = 0; i < table_el_n; ++i)
+    {
+      unsigned HOST_WIDE_INT crc = calculate_crc (i, polynom, crc_bits);
+      tree element = build_int_cstu (make_unsigned_type (crc_bits), crc);
+      vec_safe_push (initial_values, element);
+    }
+  DECL_INITIAL (decl) = build_constructor_from_vec (ar, initial_values);
+
+  TREE_READONLY (decl) = 1;
+  TREE_STATIC (decl) = 1;
+
+  if (TREE_PUBLIC (id))
+    {
+      TREE_PUBLIC (decl) = 1;
+      make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));
+    }
+
+  mark_decl_referenced (decl);
+  varpool_node::finalize_decl (decl);
+
+  return tab;
+}
+
+/* Generate CRC lookup table by calculating CRC for all possible
+   8-bit data values.  The table is stored with a specific name in the read-only
+   data section.
+   POLYNOM is the polynomial used to calculate the CRC table's elements.
+   CRC_BITS is the size of CRC, may be 8, 16, ... .  */
+
+rtx
+generate_crc_table (unsigned HOST_WIDE_INT polynom, unsigned crc_bits)
+{
+  gcc_assert (crc_bits <= 64);
+
+  /* Buf size - 24 letters + 6 '_'
+     + 20 numbers (2 for crc bit size + 2 for 0x + 16 for 64 bit polynomial)
+     + 1 for \0.  */
+  char buf[51];
+  sprintf (buf, "crc_table_for_crc_%u_polynomial_" HOST_WIDE_INT_PRINT_HEX,
+	   crc_bits, polynom);
+
+  tree id = maybe_get_identifier (buf);
+  if (id)
+    return gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));
+
+  id = get_identifier (buf);
+  return assemble_crc_table (id, polynom, crc_bits);
+}
+
+/* Generate table-based CRC code for the given CRC, INPUT_DATA AND the
+   POLYNOMIAL (without leading 1).
+
+   First, using POLYNOMIAL's value generates CRC table of 256 elements,
+   then generates the assembly for the following code,
+   where crc_size and data_size may be 8, 16, 32, 64, depending on CRC:
+
+     for (int i = 0; i < data_size / 8; i++)
+       crc = (crc << 8) ^ crc_table[(crc >> (crc_size - 8))
+				^ (data >> (data_size - (i + 1) * 8) & 0xFF))];
+
+   So to take values from the table, we need 8-bit data.
+   If input data size is not 8, when first we extract upper 8 bits,
+   then the other 8 bits and so on.  */
+
+void
+calculate_table_based_CRC (rtx *crc,
+			   const rtx &input_data, const rtx &polynomial,
+			   machine_mode crc_mode, machine_mode data_mode)
+{
+  unsigned HOST_WIDE_INT crc_size = GET_MODE_BITSIZE (crc_mode).to_constant ();
+  rtx tab = generate_crc_table (UINTVAL (polynomial),crc_size);
+
+  rtx wide_crc = gen_reg_rtx (word_mode);
+  convert_move (wide_crc, *crc, 0);
+  for (int i = 0; i < GET_MODE_SIZE (data_mode).to_constant (); i++)
+    {
+      /* crc >> (crc_size - 8).  */
+      rtx op1 = expand_shift (RSHIFT_EXPR, word_mode, wide_crc, crc_size - 8,
+			      NULL_RTX, 1);
+
+      /* data >> (8 * (GET_MODE_SIZE (data_mode).to_constant () - i - 1)).  */
+      unsigned range_8 = 8 * (GET_MODE_SIZE (data_mode).to_constant () - i - 1);
+      rtx data = expand_shift (RSHIFT_EXPR, word_mode, input_data, range_8,
+			       NULL_RTX, 1);
+
+      /* data >> (8 * (GET_MODE_SIZE (data_mode)
+					.to_constant () - i - 1)) & 0xFF.  */
+      rtx data_final = expand_and (word_mode, data,
+				   gen_int_mode (255, data_mode), NULL_RTX);
+
+      /* (crc >> (crc_size - 8)) ^ data_8bit.  */
+      rtx in = expand_binop (Pmode, xor_optab, op1, data_final, NULL_RTX, 1,
+			     OPTAB_WIDEN);
+
+      /* ((crc >> (crc_size - 8)) ^ data_8bit) & 0xFF.  */
+      rtx index = expand_and (Pmode, in, gen_int_mode (255, word_mode),
+			      NULL_RTX);
+      int log_crc_size = exact_log2 (GET_MODE_SIZE (crc_mode).to_constant ());
+      index = expand_shift (LSHIFT_EXPR, Pmode, index, log_crc_size,
+			    NULL_RTX, 0);
+
+      index = expand_binop (Pmode, add_optab, index, tab, NULL_RTX, 0,
+			    OPTAB_DIRECT);
+
+      /* crc_table[(crc >> (crc_size - 8)) ^ data_8bit]  */
+      rtx tab_el = validize_mem (gen_rtx_MEM (crc_mode, index));
+
+      /* (crc << 8) if CRC is larger than 8, otherwise crc = 0.  */
+      rtx high = NULL_RTX;
+      if (GET_MODE_BITSIZE (crc_mode).to_constant () != 8)
+	{
+	   high = expand_shift (LSHIFT_EXPR, word_mode, wide_crc, 8, NULL_RTX,
+				0);
+	   if (crc_mode != word_mode)
+	     {
+	       rtx crc_mode_mask = gen_int_mode (GET_MODE_MASK (crc_mode),
+						 word_mode);
+	       high = expand_and (word_mode, high, crc_mode_mask, NULL_RTX);
+	     }
+	}
+      else
+	high = gen_int_mode (0, word_mode);
+
+      /* crc = (crc << 8) ^ crc_table[(crc >> (crc_size - 8)) ^ data_8bit];  */
+      wide_crc = expand_binop (word_mode, xor_optab, tab_el, high, NULL_RTX, 1,
+			   OPTAB_DIRECT);
+    }
+  *crc = wide_crc;
+}
+
+/* Generate table-based CRC code for the given CRC, INPUT_DATA AND the
+   POLYNOMIAL (without leading 1).
+
+   CRC is OP1, data is OP2 and the polynomial is OP3.
+   This must generate a CRC table and an assembly for the following code,
+   where crc_size and data_size may be 8, 16, 32, 64:
+   uint_crc_size_t
+   crc_crc_size (uint_crc_size_t crc_init, uint_data_size_t data, size_t size)
+   {
+     uint_crc_size_t crc = crc_init;
+     for (int i = 0; i < data_size / 8; i++)
+       crc = (crc << 8)
+       ^ crc_table[(crc >> (crc_size - 8))
+			^ (data >> (data_size - (i + 1) * 8) & 0xFF))];
+     return crc;
+   }  */
+
+void
+expand_crc_table_based (rtx op0, rtx op1, rtx op2, rtx op3,
+			machine_mode data_mode)
+{
+  gcc_assert (!CONST_INT_P (op0));
+  gcc_assert (CONST_INT_P (op3));
+  machine_mode crc_mode = GET_MODE (op0);
+  rtx crc = op1;
+  calculate_table_based_CRC (&crc, op2, op3,
+			     crc_mode, data_mode);
+  emit_move_insn (op0, gen_lowpart (crc_mode, crc));
+}
+
+/* Generate the common operation for reflecting values:
+   *OP = (*OP & AND1_VALUE) << SHIFT_VAL | (*OP & AND2_VALUE) >> SHIFT_VAL;  */
+
+void
+gen_common_operation_to_reflect (rtx *op,
+				 unsigned HOST_WIDE_INT and1_value,
+				 unsigned HOST_WIDE_INT and2_value,
+				 unsigned shift_val)
+{
+  rtx op1 = expand_and (word_mode, *op, gen_int_mode (and1_value, word_mode),
+			NULL_RTX);
+  op1 = expand_shift (LSHIFT_EXPR, word_mode, op1, shift_val, op1, 0);
+  rtx op2 = expand_and (word_mode, *op, gen_int_mode (and2_value, word_mode),
+			NULL_RTX);
+  op2 = expand_shift (RSHIFT_EXPR, word_mode, op2, shift_val, op2, 1);
+  *op = expand_binop (word_mode, ior_optab, op1, op2, *op, 0, OPTAB_DIRECT);
+}
+
+/* Reflect 64-bit value for the 64-bit target.  */
+
+void
+reflect_64_bit_value (rtx *op)
+{
+  gen_common_operation_to_reflect (op, 0x00000000FFFFFFFF, 0xFFFFFFFF00000000,
+				   32);
+  gen_common_operation_to_reflect (op, 0x0000FFFF0000FFFF, 0xFFFF0000FFFF0000,
+				   16);
+  gen_common_operation_to_reflect (op, 0x00FF00FF00FF00FF, 0xFF00FF00FF00FF00,
+				   8);
+  gen_common_operation_to_reflect (op, 0x0F0F0F0F0F0F0F0F, 0xF0F0F0F0F0F0F0F0,
+				   4);
+  gen_common_operation_to_reflect (op, 0x3333333333333333, 0xCCCCCCCCCCCCCCCC,
+				   2);
+  gen_common_operation_to_reflect (op, 0x5555555555555555, 0xAAAAAAAAAAAAAAAA,
+				   1);
+}
+
+/* Reflect 32-bit value for the 32-bit target.  */
+
+void
+reflect_32_bit_value (rtx *op)
+{
+  gen_common_operation_to_reflect (op, 0x0000FFFF, 0xFFFF0000, 16);
+  gen_common_operation_to_reflect (op, 0x00FF00FF, 0xFF00FF00, 8);
+  gen_common_operation_to_reflect (op, 0x0F0F0F0F, 0xF0F0F0F0, 4);
+  gen_common_operation_to_reflect (op, 0x33333333, 0xCCCCCCCC, 2);
+  gen_common_operation_to_reflect (op, 0x55555555, 0xAAAAAAAA, 1);
+}
+
+/* Reflect 16-bit value for the 16-bit target.  */
+
+void
+reflect_16_bit_value (rtx *op)
+{
+  gen_common_operation_to_reflect (op, 0x00FF, 0xFF00, 8);
+  gen_common_operation_to_reflect (op, 0x0F0F, 0xF0F0, 4);
+  gen_common_operation_to_reflect (op, 0x3333, 0xCCCC, 2);
+  gen_common_operation_to_reflect (op, 0x5555, 0xAAAA, 1);
+}
+
+/* Reflect 8-bit value for the 8-bit target.  */
+
+void
+reflect_8_bit_value (rtx *op)
+{
+  gen_common_operation_to_reflect (op, 0x0F, 0xF0, 4);
+  gen_common_operation_to_reflect (op, 0x33, 0xCC, 2);
+  gen_common_operation_to_reflect (op, 0x55, 0xAA, 1);
+}
+
+/* Generate instruction sequence
+   which reflects the value of the OP using shift, and, or.
+   OP's mode may be less than word_mode, to get the correct number,
+   after reflecting we shift right the value by SHIFT_VAL.
+   E.g. we have 1111 0001, after reflection (target 32-bit) we will get
+   1000 1111 0000 0000, if we shift-out 16 bits,
+   we will get the desired one: 1000 1111.  */
+
+void
+generate_reflecting_code_standard (rtx *op, int shift_val)
+{
+  gcc_assert (BITS_PER_WORD >= 8 && BITS_PER_WORD <= 64);
+
+  if (BITS_PER_WORD == 64)
+    reflect_64_bit_value (op);
+  else if (BITS_PER_WORD == 32)
+    reflect_32_bit_value (op);
+  else if (BITS_PER_WORD == 16)
+    reflect_16_bit_value (op);
+  else
+    reflect_8_bit_value (op);
+
+  *op = expand_shift (RSHIFT_EXPR, word_mode, *op, shift_val, *op, 1);
+}
+
+/* Generate table-based reversed CRC code for the given CRC, INPUT_DATA AND
+   the POLYNOMIAL (without leading 1).
+
+   CRC is OP1, data is OP2 and the polynomial is OP3.
+   This must generate CRC table and assembly for the following code,
+   where crc_size and data_size may be 8, 16, 32, 64:
+   uint_crc_size_t
+   crc_crc_size (uint_crc_size_t crc_init, uint_data_size_t data, size_t size)
+   {
+     reflect (crc_init)
+     uint_crc_size_t crc = crc_init;
+     reflect (data);
+     for (int i = 0; i < data_size / 8; i++)
+       crc = (crc << 8)
+       ^ crc_table[(crc >> (crc_size - 8))
+			^ (data >> (data_size - (i + 1) * 8) & 0xFF))];
+     reflect (crc);
+     return crc;
+   }  */
+
+void
+expand_reversed_crc_table_based (rtx op0, rtx op1, rtx op2, rtx op3,
+				 machine_mode data_mode,
+				 void (*gen_reflecting_code) (rtx *op,
+							      int shift_val))
+{
+  gcc_assert (!CONST_INT_P (op0));
+  gcc_assert (CONST_INT_P (op3));
+  machine_mode crc_mode = GET_MODE (op0);
+
+  unsigned HOST_WIDE_INT crc_size = GET_MODE_BITSIZE (crc_mode).to_constant ();
+  unsigned HOST_WIDE_INT data_size = GET_MODE_BITSIZE (data_mode)
+      .to_constant ();
+  rtx crc = op1;
+  gen_reflecting_code (&crc, GET_MODE_BITSIZE (word_mode) - crc_size);
+  rtx data = op2;
+  gen_reflecting_code (&data, GET_MODE_BITSIZE (word_mode) - data_size);
+
+  calculate_table_based_CRC (&crc, data, op3, crc_mode, data_mode);
+
+  gen_reflecting_code (&crc, GET_MODE_BITSIZE (word_mode) - crc_size);
+  emit_move_insn (op0, gen_lowpart (crc_mode, crc));
+}
diff --git a/gcc/expr.h b/gcc/expr.h
index 64956f63029..7aaaeb59c97 100644
--- a/gcc/expr.h
+++ b/gcc/expr.h
@@ -369,4 +369,15 @@ extern rtx expr_size (tree);
 extern bool mem_ref_refers_to_non_mem_p (tree);
 extern bool non_mem_decl_p (tree);
 
+/* Return the quotient of polynomial long division of x^2N by POLYNOMIAL
+   in GF (2^N).  */
+unsigned HOST_WIDE_INT
+gf2n_poly_long_div_quotient (unsigned HOST_WIDE_INT polynomial, size_t n);
+
+/* Generate table-based CRC.  */
+extern void generate_reflecting_code_standard (rtx *, int);
+extern void expand_crc_table_based (rtx, rtx, rtx, rtx, machine_mode);
+extern void expand_reversed_crc_table_based (rtx, rtx, rtx, rtx, machine_mode,
+					     void (*) (rtx *, int));
+
 #endif /* GCC_EXPR_H */
diff --git a/gcc/gimple-crc-optimization.cc b/gcc/gimple-crc-optimization.cc
new file mode 100644
index 00000000000..b32a5d0e0ac
--- /dev/null
+++ b/gcc/gimple-crc-optimization.cc
@@ -0,0 +1,1358 @@
+/* CRC optimization.
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+   Contributed by Mariam Arutunian <mariamarutunian@gmail.com>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.   */
+
+/* This pass performs CRC optimization.  */
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "tree.h"
+#include "gimple.h"
+#include "tree-pass.h"
+#include "ssa.h"
+#include "gimple-iterator.h"
+#include "tree-cfg.h"
+#include "tree-ssa-loop-niter.h"
+#include "cfgloop.h"
+#include "gimple-range.h"
+#include "tree-scalar-evolution.h"
+#include "hwint.h"
+#include "crc-verification.h"
+#include "internal-fn.h"
+#include "tree-into-ssa.h"
+#include "tree-ssa-loop-manip.h"
+#include "predict.h"
+#include "cfghooks.h"
+#include "tree-ssa.h"
+#include "tree-ssa-live.h"
+#include "tree-dfa.h"
+#include "dominance.h"
+#include "tree-ssa-dce.h"
+#include "tree-cfgcleanup.h"
+#include "tree.h"
+
+class crc_optimization {
+ private:
+  /* The statement doing shift 1 operation before/after xor operation.  */
+  gimple *m_shift_stmt;
+
+  /* Phi statement from the head of the loop for CRC.  */
+  gphi *m_phi_for_crc;
+
+  /* Phi statement for the data from the head of the loop if exists,
+     otherwise - nullptr.  */
+  gphi *m_phi_for_data;
+
+  /* The loop, which probably calculates CRC.  */
+  class loop *m_crc_loop;
+
+  /* Depending on the value of M_IS_BIT_FORWARD, may be forward or reversed CRC.
+     If M_IS_BIT_FORWARD, then it is bit-forward implementation,
+     otherwise bit-reversed.  */
+  bool m_is_bit_forward;
+
+  /* Sets initial values for CRC analyses.  */
+  void set_initial_values ();
+
+  /* This is the main function that checks whether the given LOOP
+     calculates CRC and extracts details of the CRC calculation.
+
+     The main idea is to find the innermost loop with 8, 16, 24, 32, 64
+     iterations and xor instruction (xor is the key operation for naive CRC
+     calculation). Then, checks that the variable is shifted by one before/after
+     being used in xor.
+     Xor must be done under the condition of MSB/LSB being 1.  */
+  bool loop_may_calculate_crc (class loop *loop);
+
+  /* Symbolically executes the loop and checks that LFSR and resulting states
+     match.
+     Returns true if it is verified that the loop calculates CRC.
+     Otherwise, return false.
+     OUTPUT_CRC is the phi statement which will hold the calculated CRC value
+     after the loop exit.  */
+  bool loop_calculates_crc (gphi *output_crc,
+			    std::pair<tree, value *> calc_polynom);
+
+  /* Returns true if there is only two conditional blocks in the loop
+     (one may be for the CRC bit check and the other for the loop counter).
+     This may filter out some real CRCs, where more than one condition
+     is checked for the CRC calculation.  */
+  static bool loop_contains_two_conditional_bb (basic_block *loop_bbs,
+						unsigned loop_num_nodes);
+
+  /* Checks the FUNC_LOOP loop's iteration number.
+     The loop for CRC calculation may do 8, 16, 24, 32, 64 iterations.  */
+  bool satisfies_crc_loop_iteration_count (class loop *func_loop);
+
+  /* Checks whether found XOR_STMT is for calculating CRC.
+     The function CRC_FUN calculates CRC only if there is a shift operation
+     in the crc loop.  */
+  bool xor_calculates_crc (function *crc_fun, basic_block *loop_bbs,
+			   const gimple *xor_stmt);
+
+  /* Returns true if we can get definition of the VARIABLE, and the definition
+     it's not outside the loop.  Otherwise, returns false.  */
+  bool passes_checks_for_def_chain (tree variable);
+
+  /* This function goes up through the def-use chains of the parameter NAME.
+     Gathers all the statements within the loop,
+     from which the variable depends on and adds to the USE_DEFS.
+     Returns false, if there is a statement that may not exist in the CRC
+     loop.  Otherwise, returns true.  */
+  bool set_defs (tree name, auto_vec<gimple *>& use_defs,
+		 bool keep_only_header_phis);
+
+  /* Set M_PHI_FOR_CRC and M_PHI_FOR_DATA fields.
+     Returns false if there are more than two (as in CRC calculation only CRC's
+     and data's phi may exist) or no phi statements in STMTS (at least there
+     must be CRC's phi).
+     Otherwise, returns true.  */
+  bool set_crc_and_data_phi (auto_vec<gimple *>& stmts);
+
+  /*  Returns true if the variable checked in the condition depends on possible
+      CRC value.  Otherwise, returns false.  */
+  bool cond_depends_on_crc (auto_vec<gimple *>& stmts);
+
+
+  /* Checks that the condition is for checking CRC.
+     Returns true if xor is done under the condition of MSB/LSB being 1, and
+     the condition's variable and xor-ed variable depend on the same variable.
+     Otherwise, returns false.
+     XOR_BB is the basic block, where the xor operation is done.
+     PRED_BB is the predecessor basic block of the XOR_BB, it is assumed that
+     the last stmt of PRED_BB checks the condition under which xor is done.  */
+  bool crc_cond (basic_block pred_bb, basic_block xor_bb,
+		 basic_block *loop_bbs);
+
+  /* Returns true if xor is done in case the MSB/LSB is 1.
+     Otherwise, returns false.
+     In CRC calculation algorithms CRC is xor-ed with the polynomial only
+     if MSB/LSB is 1.
+
+     PRED_BB is the block containing the condition for the xor.
+     XOR_BB is the one of the successor blocks of PRED_BB, it is assumed that
+     CRC is xor-ed with the polynomial in XOR_BB.
+     COND is the condition, which is checked to satisfy the CRC condition.  */
+  bool is_crc_satisfiable_cond (basic_block pred_bb, basic_block xor_bb,
+				gcond *cond);
+
+  /* Checks that the variable used in the condition COND is the assumed CRC
+     (or depends on the assumed CRC).
+     Also sets data member m_phi_for_data if it isn't set and exists.  */
+  bool is_crc_checked (gcond *cond, basic_block *loop_bbs);
+
+  /* Returns true if condition COND checks MSB/LSB bit is 1.
+     Otherwise, return false.  */
+  static bool cond_true_is_checked_for_bit_one (const gcond *cond);
+
+  /* Returns opposite block of the XOR_BB from PRED_BB's dest blocks.  */
+  static basic_block get_xor_bb_opposite (basic_block pred_bb,
+					  basic_block xor_bb);
+
+  /* Checks whether the pair of xor's shift exists in the opposite
+     basic block (OPPOSITE_BB).
+     If there is a shift and xor in the same block,
+     then in the opposite block must be another shift.  */
+  bool exists_shift_for_opp_xor_shift (basic_block opposite_bb);
+
+  /* Goes down by def-use chain (within the CRC loop) and returns the statement
+     where variable (dependent on xor-ed variable) is shifted with 1.
+     Between xor and shift operations only phi statements are allowed.
+     Otherwise, returns nullptr.  */
+  gimple *find_shift_after_xor (tree xored_crc);
+
+  /* Returns the statement which does shift 1 operation.
+     If there is no such statement, returns nullptr.
+     STMTS - are the statements within the loop before xor operation on
+     which possible CRC variable depends.  */
+  gimple *find_shift_before_xor (const auto_vec <gimple *> &stmts);
+
+  /* Returns true if ASSIGN_STMT does shift with 1.
+     Otherwise, returns false.  */
+  bool can_be_crc_shift (gimple *assign_stmt);
+
+  /* Returns true if the operation done in ASSIGN_STMT can occur during CRC
+     calculation.  Otherwise, returns false.  */
+  bool can_not_be_crc_stmt (gimple *assign_stmt);
+
+  /* Returns true if the statement with STMT_CODE may occur in CRC calculation.
+     Otherwise, returns false.  */
+  static bool is_acceptable_stmt_code (const tree_code &stmt_code);
+
+  /* Prints extracted details of CRC calculation.  */
+  void dump_crc_information ();
+
+  /* Returns true if OUTPUT_CRC's result is the input of m_phi_for_crc.
+     Otherwise, returns false.  */
+  bool is_output_crc (gphi *output_crc);
+
+  /* Swaps m_phi_for_crc and m_phi_for_data if they are mixed.  */
+  void swap_crc_and_data_if_needed (gphi *output_crc);
+
+  /* Returns phi statement which may hold the calculated CRC.  */
+  gphi *get_output_phi ();
+
+  /* Returns data argument to pass to the CRC IFN.
+     If there is data from the code - use it (this is the case,
+     when data isn't xor-ed with CRC before the loop).
+     Otherwise, generate a new variable for the data with 0 value
+     (the case, when data is xor-ed with CRC before the loop).
+     For the CRC calculation, it doesn't matter CRC is calculated for the
+     (CRC^data, 0) or (CRC, data).  */
+  tree get_data ();
+
+  /* Replaces CRC calculation loop with CRC_IFN call.
+     Returns true if replacement is succeeded, otherwise false.  */
+  bool faster_crc_code_generation (function *fun, value *polynomial,
+				   gphi *output_crc);
+
+  /* Build tree for the POLYNOMIAL (from its binary representation)
+   without the leading 1.  */
+  tree build_polynomial_without_1 (tree crc_arg, value *polynomial);
+
+ public:
+  unsigned int execute (function *fun);
+};
+
+/* Prints extracted details of CRC calculation.  */
+
+void
+crc_optimization::dump_crc_information ()
+{
+  if (dump_file)
+    {
+      fprintf (dump_file,
+	       "Loop iteration number is " HOST_WIDE_INT_PRINT_UNSIGNED ".\n",
+	       tree_to_uhwi (m_crc_loop->nb_iterations));
+      if (m_is_bit_forward)
+	fprintf (dump_file, "Bit forward.\n");
+      else
+	fprintf (dump_file, "Bit reversed.\n");
+    }
+}
+
+/* Goes down by def-use chain (within the CRC loop) and returns the statement
+   where variable (dependent on xor-ed variable) is shifted with 1.
+   Between xor and shift operations only phi statements are allowed.
+   Otherwise, returns nullptr.  */
+
+gimple *
+crc_optimization::find_shift_after_xor (tree xored_crc)
+{
+  imm_use_iterator imm_iter;
+  use_operand_p use_p;
+
+  if (TREE_CODE (xored_crc) != SSA_NAME)
+    return nullptr;
+
+  /* Iterate through the immediate uses of the XORED_CRC.
+     If there is a shift return true,
+     if before shift there is other instruction (besides phi) return false.  */
+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, xored_crc)
+    {
+      gimple *stmt = USE_STMT (use_p);
+      if (gimple_visited_p (stmt))
+	return nullptr;
+      gimple_set_visited (stmt, true);
+      // Consider only statements within the loop
+      if (!flow_bb_inside_loop_p (m_crc_loop, gimple_bb (stmt)))
+	return nullptr;
+
+      /* If encountered phi statement, check immediate use of its result.
+	 Otherwise, if encountered assign statement, check whether it does shift
+	 (some other operations are allowed to be between shift and xor).  */
+      if (gimple_code (stmt) == GIMPLE_PHI)
+	{
+	  /* Don't continue searching if encountered the loop's beginning.  */
+	  if (bb_loop_header_p (gimple_bb (stmt)))
+	    return nullptr;
+
+	  return find_shift_after_xor (gimple_phi_result (stmt));
+	}
+      else if (is_gimple_assign (stmt))
+	{
+	  /* Check that stmt does shift by 1.
+	     There are no other statements between
+	     xor and shift, in CRC cases we detect.  */
+	  if (can_be_crc_shift (stmt))
+	    return stmt;
+	  return nullptr;
+	}
+    }
+    return nullptr;
+}
+
+/* Returns opposite block of the XOR_BB from PRED_BB's dest blocks.  */
+
+basic_block
+crc_optimization::get_xor_bb_opposite (basic_block pred_bb, basic_block xor_bb)
+{
+  if (EDGE_COUNT (pred_bb->succs) != 2)
+    return nullptr;
+
+  if (EDGE_SUCC (pred_bb, 0)->dest != xor_bb)
+    return EDGE_SUCC (pred_bb, 0)->dest;
+  return EDGE_SUCC (pred_bb, 1)->dest;
+}
+
+/* Checks whether the pair of xor's shift exists in the opposite
+   basic block (OPPOSITE_BB).
+   If there is a shift and xor in the same block,
+   then in the opposite block must be another shift.  */
+
+bool
+crc_optimization::exists_shift_for_opp_xor_shift (basic_block opposite_bb)
+{
+  if (!opposite_bb)
+    return false;
+
+  /* Walk through the instructions of given basic block.  */
+  for (gimple_stmt_iterator bsi = gsi_start_nondebug_bb (opposite_bb);
+       !gsi_end_p (bsi); gsi_next_nondebug (&bsi))
+    {
+      gimple *stmt = gsi_stmt (bsi);
+      /* Find assignment statement with shift operation.
+	 Check that shift's direction is same with the shift done
+	 on the path with xor, and it is a shift by one.  */
+      if (is_gimple_assign (stmt))
+	{
+	  if (gimple_assign_rhs_code (stmt)
+	      == gimple_assign_rhs_code (m_shift_stmt)
+	      && integer_onep (gimple_assign_rhs2 (stmt)))
+	    return true;
+	}
+    }
+  /* If there is no shift, return false.  */
+  return false;
+}
+
+/* Returns true if condition COND checks MSB/LSB bit is 1.
+   Otherwise, return false.  */
+
+bool
+crc_optimization::cond_true_is_checked_for_bit_one (const gcond *cond)
+{
+  if (!cond)
+    return false;
+
+  tree rhs = gimple_cond_rhs (cond);
+  enum tree_code code = gimple_cond_code (cond);
+
+  /* If the condition is something == 1 -> return true.  */
+  if (integer_onep (rhs) && code == EQ_EXPR)
+    return true;
+
+  /* If the condition is something != 0  or something < 0 -> return true.  */
+  if (integer_zerop (rhs) && (code == NE_EXPR || code == LT_EXPR))
+    return true;
+
+  return false;
+}
+
+/* Returns true if xor is done in case the MSB/LSB is 1.
+   Otherwise, returns false.
+   In CRC calculation algorithms CRC is xor-ed with the polynomial only
+   if MSB/LSB is 1.
+
+   PRED_BB is the block containing the condition for the xor.
+   XOR_BB is the one of the successor blocks of PRED_BB, it is assumed that CRC
+   is xor-ed with the polynomial in XOR_BB.
+   COND is the condition, which is checked to satisfy the CRC condition.  */
+
+bool
+crc_optimization::is_crc_satisfiable_cond (basic_block pred_bb,
+					   basic_block xor_bb,
+					   gcond *cond)
+{
+  edge true_edge;
+  edge false_edge;
+  extract_true_false_edges_from_block (pred_bb, &true_edge, &false_edge);
+  bool cond_is_checked_for_bit_one = cond_true_is_checked_for_bit_one (cond);
+  /* Check that xor is done in case the MSB/LSB is 1.  */
+  if (cond_is_checked_for_bit_one && true_edge->dest == xor_bb)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Xor is done on true branch.\n");
+    }
+  else if (!cond_is_checked_for_bit_one && false_edge->dest == xor_bb)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Xor is done on false branch.\n");
+    }
+  else
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file,
+		 "Xor is done if MSB/LSB is not one, not CRC.\n");
+      return false;
+    }
+  return true;
+}
+
+/* Checks that the variable used in the condition COND is the assumed CRC
+  (or depends on the assumed CRC).
+  Also sets data member m_phi_for_data if it isn't set and exists.  */
+
+bool
+crc_optimization::is_crc_checked (gcond *cond, basic_block *loop_bbs)
+{
+  tree lhs = gimple_cond_lhs (cond);
+  set_bbs_stmts_not_visited (loop_bbs, m_crc_loop->num_nodes);
+
+  /* As conditions are in canonical form, only left part must be an
+    SSA_NAME.  */
+  if (TREE_CODE (lhs) == SSA_NAME)
+    {
+      /* Return whether there is a dependence between if condition's variable
+	 and xor-ed variable.  Also set phi statement of data if it is not
+	 determined earlier and is used in the loop.  */
+      auto_vec<gimple *> cond_dep_stmts (m_crc_loop->num_nodes);
+      if (!set_defs (lhs, cond_dep_stmts, true))
+	return false;
+      return cond_depends_on_crc (cond_dep_stmts);
+    }
+
+  /* Return false if there is no dependence between if condition's variable
+     and xor-ed variable.  */
+  return false;
+}
+
+/* Checks that the condition is for checking CRC.
+   Returns true if xor is done under the condition of MSB/LSB being 1, and
+   the condition's variable and xor-ed variable depend on the same variable.
+   Otherwise, returns false.
+   XOR_BB is the basic block, where the xor operation is done.
+   PRED_BB is the predecessor basic block of the XOR_BB, it is assumed that
+   the last stmt of PRED_BB checks the condition under which xor is done.  */
+
+bool
+crc_optimization::crc_cond (basic_block pred_bb, basic_block xor_bb,
+			    basic_block *loop_bbs)
+{
+  /* Check whether PRED_BB contains condition.  We will consider only those
+     cases when xor is done immediately under the condition.  */
+  gcond *cond = safe_dyn_cast<gcond *> (*gsi_last_bb (pred_bb));
+  if (!cond)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "No condition.\n");
+      return false;
+    }
+
+  /* Check that xor is done in case the MSB/LSB is 1.  */
+  if (!is_crc_satisfiable_cond (pred_bb, xor_bb, cond))
+    return false;
+
+  /* Check that CRC's MSB/LSB is checked in the condition.
+     Set data member if not set and exists.  */
+  if (!is_crc_checked (cond, loop_bbs))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "The condition is not related to the CRC check.\n");
+      return false;
+    }
+  return true;
+}
+
+/* Returns true if the statement with STMT_CODE may occur in CRC calculation.
+   Otherwise, returns false.  */
+
+bool
+crc_optimization::is_acceptable_stmt_code (const tree_code &stmt_code)
+{
+  return stmt_code == BIT_IOR_EXPR
+	 || stmt_code == BIT_AND_EXPR
+	 || stmt_code == BIT_XOR_EXPR
+	 || stmt_code == MINUS_EXPR
+	 || stmt_code == PLUS_EXPR
+	 || stmt_code == RSHIFT_EXPR
+	 || stmt_code == LSHIFT_EXPR
+	 || TREE_CODE_CLASS (stmt_code) == tcc_unary;
+}
+
+/* Returns true if ASSIGN_STMT does shift with 1.  Otherwise, returns false.  */
+
+bool
+crc_optimization::can_be_crc_shift (gimple *assign_stmt)
+{
+  tree_code stmt_code = gimple_assign_rhs_code (assign_stmt);
+  if (stmt_code == LSHIFT_EXPR || stmt_code == RSHIFT_EXPR)
+    {
+      m_is_bit_forward = (stmt_code == LSHIFT_EXPR);
+      /* Check that shift one is done, keep shift statement.  */
+      if (integer_onep (gimple_assign_rhs2 (assign_stmt)))
+	{
+	  if (m_shift_stmt)
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file,
+			 "Already there is one shift.\n");
+	      return false;
+	    }
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file,
+		     "Found <<1 or >>1.\n");
+	  return true;
+	}
+      /* This filters out cases, when xor-ed variable is shifted by values
+	 other than 1.  */
+    }
+    return false;
+}
+
+/* Returns true if the operation done in ASSIGN_STMT can occur during CRC
+   calculation.  Otherwise, returns false.  */
+
+bool
+crc_optimization::can_not_be_crc_stmt (gimple *assign_stmt)
+{
+  tree_code stmt_code = gimple_assign_rhs_code (assign_stmt);
+  if (!is_acceptable_stmt_code (stmt_code))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file,
+		 "\nStmt with the following operation "
+		 "code %s between xor and shift, "
+		 "may not be CRC.\n", get_tree_code_name (stmt_code));
+
+      return true;
+    }
+  return false;
+}
+
+/* Returns true if we can get definition of the VARIABLE, and the definition
+   is not outside the loop.  Otherwise, returns false.  */
+
+bool
+crc_optimization::passes_checks_for_def_chain (tree variable)
+{
+  if (!(variable && TREE_CODE (variable) == SSA_NAME))
+    return false;
+
+  /* No definition chain for default defs.  */
+  if (SSA_NAME_IS_DEFAULT_DEF (variable))
+    return false;
+
+  gimple *stmt = SSA_NAME_DEF_STMT (variable);
+
+  if (!stmt)
+    return false;
+
+  /* Don't go outside the loop.  */
+  if (!flow_bb_inside_loop_p (m_crc_loop, gimple_bb (stmt)))
+    return false;
+
+  return true;
+}
+
+/* This function goes up through the def-use chains of the parameter NAME.
+   Gathers all the statements within the loop,
+   from which the variable depends on and adds to the USE_DEFS.
+   Returns false, if there is a statement that may not exist in the CRC
+   loop.  Otherwise, returns true.  */
+
+bool
+crc_optimization::set_defs (tree name, auto_vec<gimple *> &use_defs,
+			    bool keep_only_header_phis = false)
+{
+  if (!passes_checks_for_def_chain (name))
+    return true;
+
+  gimple *stmt = SSA_NAME_DEF_STMT (name);
+
+  /* Don't consider already visited statement.  */
+  if (gimple_visited_p (stmt))
+    return true;
+  gimple_set_visited (stmt, true);
+
+  /* If it's not specified to keep only header phi's,
+     then keep all statements.  */
+  if (!keep_only_header_phis)
+    use_defs.safe_push (stmt);
+
+  /* If it is an assignment statement,
+     get and check def-use chain for the first and second operands.  */
+  if (is_a<gassign *> (stmt))
+    {
+      if (can_not_be_crc_stmt (stmt))
+	return false;
+
+      tree ssa1 = gimple_assign_rhs1 (stmt);
+      tree ssa2 = gimple_assign_rhs2 (stmt);
+      if (!set_defs (ssa1, use_defs, keep_only_header_phis))
+	return false;
+      if (!set_defs (ssa2, use_defs, keep_only_header_phis))
+	return false;
+      return true;
+    }
+  /* If it's a phi statement, not declared in loop's header,
+     get and check def-use chain for its values.  For the one declared in loop's
+     header just return true and keep it, if keep_only_header_phis is true.  */
+  else if (is_a<gphi *> (stmt))
+    {
+      if (bb_loop_header_p (gimple_bb (stmt)))
+	{
+	  /* If it's specified to keep only header phi's, keep it.  */
+	  if (keep_only_header_phis)
+	    use_defs.safe_push (stmt);
+	}
+      else
+	{
+	  for (unsigned i = 0; i < gimple_phi_num_args (stmt); i++)
+	    {
+	      tree val = gimple_phi_arg_def (stmt, i);
+	      if (!set_defs (val, use_defs, keep_only_header_phis))
+		return false;
+	    }
+	}
+      return true;
+    }
+
+  /* Return false for other than assigment and phi statement.  */
+  return false;
+}
+
+/* Returns the statement which does shift 1 operation.
+   If there is no such statement, returns nullptr.
+   STMTS - are the statements within the loop before xor operation on
+   which possible CRC variable depends.  */
+
+gimple *
+crc_optimization::find_shift_before_xor (const auto_vec<gimple *> &stmts)
+{
+  for (auto stmt_it = stmts.begin (); stmt_it != stmts.end (); stmt_it++)
+    {
+      /* If it is an assignment statement, check that is does shift 1.  */
+      if (is_a<gassign *> (*stmt_it))
+	{
+	  if (can_be_crc_shift (*stmt_it))
+	    return *stmt_it;
+	}
+    }
+  return nullptr;
+}
+
+/* Set M_PHI_FOR_CRC and M_PHI_FOR_DATA fields.
+   Returns false if there are more than two (as in CRC calculation only CRC's
+   and data's phi may exist) or no phi statements in STMTS (at least there must
+   be CRC's phi).
+   Otherwise, returns true.  */
+
+bool
+crc_optimization::set_crc_and_data_phi (auto_vec<gimple *> &stmts)
+{
+  for (auto stmt_it = stmts.begin (); stmt_it != stmts.end (); stmt_it++)
+    {
+      if (is_a<gphi *> (*stmt_it) && bb_loop_header_p (gimple_bb (*stmt_it)))
+	{
+	  if (!m_phi_for_crc)
+	    m_phi_for_crc = as_a<gphi *> (*stmt_it);
+	  else if (!m_phi_for_data)
+	    m_phi_for_data = as_a<gphi *> (*stmt_it);
+	  else
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file, "Xor-ed variable depends on more than 2 "
+				    "phis.\n");
+	      return false;
+	    }
+	}
+    }
+  return m_phi_for_crc;
+}
+
+/*  Returns true if the variable checked in the condition depends on possible
+    CRC value.  Otherwise, returns false.  */
+
+bool
+crc_optimization::cond_depends_on_crc (auto_vec<gimple *>& stmts)
+{
+  bool con_depends_on_crc = false;
+
+  /* The condition may depend maximum on data and CRC phi's.  */
+  if (stmts.length () > 2)
+    return false;
+
+  for (auto stmt_it = stmts.begin (); stmt_it != stmts.end (); stmt_it++)
+    {
+      if (is_a<gphi *> (*stmt_it) && bb_loop_header_p (gimple_bb (*stmt_it)))
+	{
+	  /* Check whether variable checked in the condition depends on
+	     M_PHI_FOR_CRC.
+	     Here don't stop the check, to set data if needed.  */
+	  if (m_phi_for_crc == (*stmt_it))
+	    con_depends_on_crc = true;
+	  else if (m_phi_for_data && m_phi_for_data == (*stmt_it))
+	    return true;
+	  /* If M_PHI_FOR_DATA isn't determined, the phi statement maybe for the
+	     data.  Just set it.  */
+	  else if (!m_phi_for_data)
+	    m_phi_for_data = as_a<gphi *> (*stmt_it);
+	}
+    }
+  return con_depends_on_crc;
+}
+
+/* Sets initial values for the CRC analysis.
+   This function is used multiple times during the analyses.  */
+
+void
+crc_optimization::set_initial_values ()
+{
+  m_shift_stmt = nullptr;
+  m_phi_for_crc = nullptr;
+  m_phi_for_data = nullptr;
+  m_is_bit_forward = false;
+}
+
+/* Check whether found XOR_STMT is for calculating CRC.
+   The function CRC_FUN calculates CRC only if there is a shift operation
+   in the crc loop.  */
+
+bool
+crc_optimization::xor_calculates_crc (function *crc_fun, basic_block *loop_bbs,
+				      const gimple *xor_stmt)
+{
+  tree crc_var = gimple_assign_lhs (xor_stmt);
+  set_initial_values ();
+  set_bbs_stmts_not_visited (loop_bbs, m_crc_loop->num_nodes);
+  tree ssa1 = gimple_assign_rhs1 (xor_stmt);
+  tree ssa2 = gimple_assign_rhs2 (xor_stmt);
+  if (TREE_CODE (ssa2) != INTEGER_CST)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Second operand of the "
+			    "xor statement isn't an integer constant.\n");
+      return false;
+    }
+
+  /* Get the statements within the loop on which xor-ed variable depends.  */
+  auto_vec<gimple *> xor_dep_stmts (m_crc_loop->num_nodes);
+  if (!set_defs (ssa1, xor_dep_stmts))
+    {
+      xor_dep_stmts.release ();
+      return false;
+    }
+
+  m_shift_stmt = find_shift_before_xor (xor_dep_stmts);
+
+  if (!set_crc_and_data_phi (xor_dep_stmts))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Xor isn't used for CRC calculation.\n");
+      return false;
+    }
+
+  /* Check the case when shift is done after xor.  */
+  if (!m_shift_stmt)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "No shift before xor, trying to find after xor.\n");
+
+      set_bbs_stmts_not_visited (loop_bbs, m_crc_loop->num_nodes);
+
+      m_shift_stmt = find_shift_after_xor (crc_var);
+      if (!m_shift_stmt)
+	return false;
+    }
+
+  /* Get the basic block where xor operation is done.  */
+  basic_block xor_bb = gimple_bb (xor_stmt);
+
+  /* Get the predecessor basic block of xor's block.  */
+  if (!single_pred_p (xor_bb))
+    return false;
+  basic_block block_of_condition = single_pred (xor_bb);
+
+
+  /* If the found shift operation is in the same block as the xor operation,
+     verify whether another shift exists in the opposite branch of the
+     conditional statements.  */
+  if (m_shift_stmt && gimple_bb (m_shift_stmt) == xor_bb)
+    {
+      basic_block opposite_block = get_xor_bb_opposite (block_of_condition,
+							xor_bb);
+      if (!exists_shift_for_opp_xor_shift (opposite_block))
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file,
+		     "Opposite block doesn't contain shift's pair.\n");
+	  return false;
+	}
+    }
+
+  /* Check that xor is done if MSB/LSB is one.
+     If all checks succeed, then it may be a CRC.*/
+  if (crc_cond (block_of_condition, xor_bb, loop_bbs))
+    {
+      if (dump_file)
+	fprintf (dump_file,
+		 "\n%s function maybe contains CRC calculation.\n",
+		 function_name (crc_fun));
+      return true;
+    }
+
+  return false;
+}
+
+/* Returns true if there is only two conditional blocks in the loop,
+   one may be for the CRC bit check and the other for the loop counter.
+   This may filter out some real CRCs, where more than one condition
+   is checked for the CRC calculation and branch-less CRCs.  */
+
+bool
+crc_optimization::loop_contains_two_conditional_bb (basic_block *loop_bbs,
+						    unsigned loop_num_nodes)
+{
+  unsigned conditional_bb_count = 0;
+  /* Iterate through the loop until the conditional branches count
+     is below 3.  */
+  for (unsigned i = 0; i < loop_num_nodes && conditional_bb_count <= 2; i++)
+    {
+      basic_block bb = loop_bbs[i];
+      if (!single_succ_p (bb))
+	conditional_bb_count++;
+    }
+  return conditional_bb_count == 2;
+}
+
+/* Checks the FUNC_LOOP loop's iteration number.
+   The loop for CRC calculation may do 8, 16, 24, 32, 64 iterations.  */
+
+bool
+crc_optimization::satisfies_crc_loop_iteration_count (class loop *func_loop)
+{
+  /* Calculate the number of times the latch of the loop is executed.
+     The function sets NB_ITERATIONS field of the loop.  */
+  number_of_latch_executions (func_loop);
+  tree n_inters = func_loop->nb_iterations;
+  if (n_inters == NULL_TREE || n_inters == chrec_dont_know)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file,
+		 "Loop iteration number is chrec_dont_know.\n");
+      return false;
+
+    }
+  else if (tree_fits_uhwi_p (n_inters))
+    {
+      unsigned HOST_WIDE_INT
+      loop_iteration_number = tree_to_uhwi (n_inters);
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Loop iteration number is "
+		 HOST_WIDE_INT_PRINT_UNSIGNED ".\n", loop_iteration_number);
+
+      if ((loop_iteration_number == 7 || loop_iteration_number == 15
+	   || loop_iteration_number == 23 || loop_iteration_number == 31
+	   || loop_iteration_number == 63))
+	return true;
+    }
+  if (stderr && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file, "Loop iteration number isn't a constant.\n");
+  return false;
+}
+
+/* This is the main function that checks whether the given LOOP
+   calculates CRC and extracts details of the CRC calculation.
+
+   The main idea is to find the innermost loop with 8, 16, 24, 32, 64
+   iterations and xor instruction (xor is the key operation for naive CRC
+   calculation). Then, checks that the variable is shifted by one before/after
+   being used in xor.
+   Xor must be done under the condition of MSB/LSB being 1.  */
+
+bool
+crc_optimization::loop_may_calculate_crc (class loop *loop)
+{
+  /* Only examine innermost loops.  */
+  if (!loop || loop->inner)
+    return false;
+
+  if (!satisfies_crc_loop_iteration_count (loop))
+    return false;
+
+  m_crc_loop = loop;
+  basic_block *loop_bbs = get_loop_body_in_dom_order (m_crc_loop);
+
+  /* Filter out the cases, which don't have exactly two conditions in the loop.
+     One for the CRC bit check, the other for the loop counter.  */
+  if (!loop_contains_two_conditional_bb (loop_bbs, m_crc_loop->num_nodes))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file,
+		 "The number of conditional "
+		 "branches in the loop isn't 2.\n");
+      return false;
+    }
+
+  /* Walk bbs of the loop.  */
+  for (unsigned int i = 0; i < m_crc_loop->num_nodes; i++)
+    {
+      basic_block bb = loop_bbs[i];
+      /* Walk instructions of the bb.  */
+      for (gimple_stmt_iterator bsi = gsi_start_nondebug_bb (bb);
+	   !gsi_end_p (bsi); gsi_next_nondebug (&bsi))
+	{
+	  gimple *stmt = gsi_stmt (bsi);
+	  /* If there is an xor instruction,
+	     check that it is calculating CRC.  */
+	  if (is_gimple_assign (stmt)
+	      && gimple_assign_rhs_code (stmt) == BIT_XOR_EXPR)
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file,
+			 "Found xor, "
+			 "checking whether it is for CRC calculation.\n");
+
+	      if (xor_calculates_crc (cfun, loop_bbs, stmt))
+		{
+		  dump_crc_information ();
+		  free (loop_bbs);
+		  return true;
+		}
+	    }
+	}
+    }
+  free (loop_bbs);
+  return false;
+}
+
+/* Symbolically executes the loop and checks that LFSR and resulting states
+   match.
+   Returns true if it is verified that the loop calculates CRC.
+   Otherwise, return false.
+   OUTPUT_CRC is the phi statement which will hold the calculated CRC value
+   after the loop exit.  */
+
+bool
+crc_optimization::loop_calculates_crc (gphi *output_crc,
+				       std::pair<tree, value *> calc_polynom)
+{
+  /* Create LFSR state using extracted polynomial.  */
+  value * lfsr = state::create_lfsr (calc_polynom.first, calc_polynom.second,
+				     m_is_bit_forward);
+  if (!lfsr)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Couldn't create LFSR!\n");
+      return false;
+    }
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+      fprintf (dump_file, "\nLFSR value is \n");
+      state::print_value (lfsr);
+    }
+
+  /* Execute the loop with symbolic values
+     (symbolic value is assigned to the variable when its value isn't known)
+     to keep states, for further comparison.  */
+  bool is_crc = true;
+  crc_symbolic_execution loop_executor (m_crc_loop, output_crc);
+  while (!loop_executor.is_last_iteration ())
+    {
+      if (!loop_executor.symb_execute_crc_loop ())
+	{
+	  if (dump_file)
+	    fprintf (dump_file, "\nCRC verification didn't succeed "
+				"during symbolic execution!\n");
+	  is_crc = false;
+	  break;
+	}
+
+      /* Check whether LFSR and obtained states are same.  */
+      if (!all_states_match_lfsr (lfsr, m_is_bit_forward, output_crc,
+				 loop_executor.get_final_states ()))
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, "Returned state and LFSR differ.\n");
+	  is_crc = false;
+	  break;
+	}
+    }
+  delete lfsr;
+  return is_crc;
+}
+
+/* Returns true if OUTPUT_CRC's result is the input of M_PHI_FOR_CRC.
+  Otherwise, returns false.  */
+
+bool
+crc_optimization::is_output_crc (gphi *output_crc)
+{
+  if (PHI_ARG_DEF (output_crc, 0) == PHI_ARG_DEF (m_phi_for_crc, 0))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	{
+	  fprintf (dump_file, "Output CRC is ");
+	  print_gimple_expr (dump_file, (gimple *) output_crc, dump_flags);
+	}
+      return true;
+    }
+  else
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Output CRC and determined input CRC "
+			    "differ.\n");
+      return false;
+    }
+}
+
+/* Swaps M_PHI_FOR_CRC and M_PHI_FOR_DATA if they are mixed.  */
+
+void
+crc_optimization::swap_crc_and_data_if_needed (gphi *output_crc)
+{
+  if (PHI_ARG_DEF (output_crc, 0) != PHI_ARG_DEF (m_phi_for_crc, 0))
+    {
+      if (m_phi_for_data
+	  && PHI_ARG_DEF (output_crc, 0) == PHI_ARG_DEF (m_phi_for_data, 0))
+	{
+	  std::swap (m_phi_for_crc, m_phi_for_data);
+	}
+    }
+}
+
+/* Returns phi statement which may hold the calculated CRC.  */
+
+gphi *
+crc_optimization::get_output_phi ()
+{
+  edge loop_exit = single_exit (m_crc_loop);
+  if (!loop_exit)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "The loop doesn't have single exit.\n");
+      return nullptr;
+    }
+  basic_block bb = loop_exit->dest;
+  gphi *output_crc = nullptr;
+  int phi_count = 0;
+
+  /* We are only interested in cases when there is only one phi at the
+   loop exit, and that phi can potentially represent the CRC.
+   If there are other phis present, it indicates that additional values are
+   being calculated within the loop that are used outside it.  */
+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+      tree phi_result = gimple_phi_result (gsi.phi ());
+
+      /* Don't consider virtual operands.  */
+      if (!virtual_operand_p (phi_result))
+	{
+	  if (phi_count < 1)
+	    {
+	      output_crc = gsi.phi ();
+	      phi_count++;
+	    }
+	  else
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file, "There is more than one output phi.\n");
+	      return nullptr;
+	    }
+	}
+    }
+
+  if (output_crc)
+    {
+      if (gimple_phi_num_args (output_crc) == 1)
+	return output_crc;
+    }
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file, "Couldn't determine output CRC.\n");
+  return nullptr;
+}
+
+/* Build tree for the POLYNOMIAL (from its binary representation)
+   without the leading 1.  */
+
+tree
+crc_optimization::build_polynomial_without_1 (tree crc_arg, value *polynomial)
+{
+  unsigned HOST_WIDE_INT cst_polynomial = 0;
+  for (size_t i = 0; i < (*polynomial).length (); i++)
+    {
+      value_bit *const_bit;
+      if (m_is_bit_forward)
+	const_bit = (*polynomial)[(*polynomial).length () - 1 - i];
+      else
+	const_bit = (*polynomial)[i];
+      cst_polynomial <<= 1;
+      cst_polynomial ^= (as_a<bit *> (const_bit))->get_val () ? 1 : 0;
+    }
+  return build_int_cstu (TREE_TYPE (crc_arg), cst_polynomial);
+}
+
+/* Returns data argument to pass to the CRC IFN.
+   If there is data from the code - use it (this is the case,
+   when data isn't xor-ed with CRC before the loop).
+   Otherwise, generate a new variable for the data with 0 value
+   (the case, when data is xor-ed with CRC before the loop).
+   For the CRC calculation, it doesn't matter CRC is calculated for the
+   (CRC^data, 0) or (CRC, data).  */
+
+tree
+crc_optimization::get_data ()
+{
+  unsigned HOST_WIDE_INT
+  data_size = tree_to_uhwi (m_crc_loop->nb_iterations) + 1;
+
+  /* If we have the data, use it.  */
+  if (m_phi_for_data)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file,
+		 "Data and CRC are xor-ed in the for loop.  Initializing data "
+		 "with its value.\n");
+      tree data_arg = PHI_ARG_DEF (m_phi_for_data, 1);
+      if (TYPE_PRECISION (TREE_TYPE (data_arg)) == data_size)
+	return data_arg;
+      else
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file,
+		     "Loop iteration number and data's size differ.\n");
+	  return nullptr;
+	}
+    }
+
+  /* Create a new variable for the data.  */
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file,
+	     "Data and CRC are xor-ed before for loop.  Initializing data "
+	     "with 0.\n");
+  tree type = nullptr;
+  /* Determine the data's size with the loop iteration count.
+     We assume that loop iteration count depends on the data's size.  */
+  if (data_size == TYPE_PRECISION (intQI_type_node))
+    type = intQI_type_node;
+  else if (data_size == TYPE_PRECISION (intHI_type_node))
+    type = intHI_type_node;
+  else if (data_size == TYPE_PRECISION (intSI_type_node))
+    type = intSI_type_node;
+  else if (data_size == TYPE_PRECISION (intDI_type_node))
+    type = intDI_type_node;
+  else if (data_size == TYPE_PRECISION (intTI_type_node))
+    type = intTI_type_node;
+  else
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Couldn't determine the data's size.\n");
+      return nullptr;
+    }
+  return build_int_cstu (type, 0);
+
+}
+
+/* Replaces CRC calculation loop with CRC_IFN call.
+   Returns true if replacement is succeeded, otherwise false.
+
+   First the function determines CRC, data and the polynomial
+   and depending on the CRC type, instead of the loop generates:
+   output_crc = IFN_CRC(_REV) (CRC, data, polynomial);  */
+
+bool
+crc_optimization::faster_crc_code_generation (function *fun,
+					      value *polynomial,
+					      gphi *output_crc)
+{
+  if (!output_crc)
+    {
+      if (dump_file)
+	fprintf (dump_file, "Couldn't determine output CRC.\n");
+      return false;
+    }
+
+  gcc_assert (m_phi_for_crc);
+
+  tree crc_arg = PHI_ARG_DEF (m_phi_for_crc, 1);
+  if (TYPE_MODE (TREE_TYPE (crc_arg)) > word_mode)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "word_mode is less than CRC mode.\n");
+      return false;
+    }
+
+  tree data_arg = get_data ();
+  tree polynomial_arg = build_polynomial_without_1 (crc_arg, polynomial);
+
+  if (!crc_arg || !data_arg || !polynomial_arg)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "crc_arg, data_arg or polynomial_arg is null.\n");
+      return false;
+    }
+
+  /* We don't support the case where data is larger than the CRC.  */
+  if (TYPE_PRECISION (TREE_TYPE (crc_arg))
+      < TYPE_PRECISION (TREE_TYPE (data_arg)))
+    return false;
+
+  internal_fn ifn;
+  if (m_is_bit_forward)
+    ifn = IFN_CRC;
+  else
+    ifn = IFN_CRC_REV;
+
+  tree phi_result = gimple_phi_result (output_crc);
+  location_t loc;
+  loc = EXPR_LOCATION (phi_result);
+
+  /* Add IFN call and return the value.  */
+  gcall *call
+      = gimple_build_call_internal (ifn, 3,
+				    crc_arg,
+				    data_arg,
+				    polynomial_arg);
+
+  gimple_call_set_lhs (call, phi_result);
+  gimple_set_location (call, loc);
+  gimple_stmt_iterator si = gsi_start_bb (output_crc->bb);
+  gsi_insert_before (&si, call, GSI_SAME_STMT);
+  use_operand_p imm_use_p;
+  destroy_loop (m_crc_loop);
+
+  gimple_stmt_iterator gsi = gsi_start_phis (output_crc->bb);
+  gsi_remove (&gsi, true);
+
+  imm_use_iterator iterator;
+  gimple *stmt;
+  FOR_EACH_IMM_USE_STMT (stmt, iterator, phi_result)
+    {
+      FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)
+	SET_USE (imm_use_p, phi_result);
+      update_stmt (stmt);
+    }
+
+  /* Fix up CFG.  */
+  remove_unused_locals ();
+  scev_reset ();
+  mark_virtual_operands_for_renaming (fun);
+  free_dominance_info (fun, CDI_DOMINATORS);
+  calculate_dominance_info (CDI_DOMINATORS);
+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);
+  return true;
+}
+
+unsigned int
+crc_optimization::execute (function *fun)
+{
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file, "\nExamining %s function.\n",
+	     function_name (fun));
+
+  if (number_of_loops (fun) <= 1)
+    return 0;
+
+  /* Get loops of the function.  */
+  auto loop_list = loops_list (fun, LI_ONLY_INNERMOST);
+  for (auto loop: loop_list)
+    {
+      /* Perform initial checks to filter out non-CRCs.  */
+      if (loop_may_calculate_crc (loop))
+	{
+	  /* Get the phi which will hold the calculated CRC.  */
+	  gphi *output_crc = get_output_phi ();
+	  if (!output_crc)
+	    return 0;
+
+	  swap_crc_and_data_if_needed (output_crc);
+	  if (!is_output_crc (output_crc))
+	    return 0;
+
+	  crc_symbolic_execution execute_loop (m_crc_loop, nullptr);
+	  /* Execute the loop assigning specific values to CRC and data
+	     for extracting the polynomial.  */
+	  std::pair <tree, value *>
+	      calc_polynom = execute_loop.extract_polynomial (m_phi_for_crc,
+							      m_phi_for_data,
+							      m_is_bit_forward);
+
+	  value *polynom_value = calc_polynom.second;
+	  /* Stop analysis if we couldn't get the polynomial's value.  */
+	  if (!polynom_value)
+	    return 0;
+
+	  if (!loop_calculates_crc (output_crc, calc_polynom))
+	    return 0;
+
+	  if (dump_file)
+	    fprintf (dump_file, "The loop with %d header BB index "
+				"calculates CRC!\n", m_crc_loop->header->index);
+
+	  if (!faster_crc_code_generation (fun, polynom_value, output_crc))
+	    {
+	      if (dump_file)
+		fprintf (dump_file, "Couldn't generate faster CRC code.\n");
+	    }
+	}
+    }
+  return 0;
+}
+
+namespace
+{
+
+    const pass_data pass_data_crc_optimization
+	= {
+	    GIMPLE_PASS, /* type */
+	    "crc", /* name */
+	    OPTGROUP_NONE, /* optinfo_flags */
+	    TV_GIMPLE_CRC_OPTIMIZATION, /* tv_id */
+	    (PROP_cfg | PROP_ssa), /* properties_required */
+	    0, /* properties_provided */
+	    0, /* properties_destroyed */
+	    0, /* todo_flags_start */
+	    0, /* todo_flags_finish */
+	};
+
+    class pass_crc_optimization : public gimple_opt_pass {
+     public:
+      pass_crc_optimization (gcc::context *ctxt)
+	  : gimple_opt_pass (pass_data_crc_optimization, ctxt)
+      {}
+
+      /* opt_pass methods: */
+      virtual bool gate (function *)
+      {
+	return flag_gimple_crc_optimization;
+      }
+
+      virtual unsigned int execute (function *);
+
+    }; // class pass_crc_optimization
+
+    unsigned int
+    pass_crc_optimization::execute (function *fun)
+    {
+      return crc_optimization ().execute (fun);
+    }
+
+} // anon namespace
+
+gimple_opt_pass *
+make_pass_crc_optimization (gcc::context *ctxt)
+{
+  return new pass_crc_optimization (ctxt);
+}
diff --git a/gcc/gimple.cc b/gcc/gimple.cc
index a9f968cb038..76518d8897d 100644
--- a/gcc/gimple.cc
+++ b/gcc/gimple.cc
@@ -3426,6 +3426,44 @@ gimple_or_expr_nonartificial_location (gimple *stmt, tree expr)
   return expansion_point_location_if_in_system_header (loc);
 }
 
+/* Set GIMPLE_PHI statements of the BB not visited.  */
+
+void
+set_phi_stmts_not_visited (basic_block bb)
+{
+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+      gphi *stmt = gsi.phi ();
+      gimple_set_visited (stmt, false);
+    }
+}
+
+/* Set GIMPLE statements of the BB not visited.  */
+
+void
+set_gimple_stmts_not_visited (basic_block bb)
+{
+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+      gimple *stmt = gsi_stmt (gsi);
+      gimple_set_visited (stmt, false);
+    }
+}
+
+/* Set GIMPLE_PHI and GIMPLE statements of BBS not visited.  */
+
+void
+set_bbs_stmts_not_visited (const basic_block *bbs, unsigned bb_num)
+{
+  for (unsigned int i = 0; i < bb_num; i++)
+    {
+      basic_block bb = bbs[i];
+      set_phi_stmts_not_visited (bb);
+      set_gimple_stmts_not_visited (bb);
+    }
+}
 
 #if CHECKING_P
 
diff --git a/gcc/gimple.h b/gcc/gimple.h
index 8a8ca109bbf..d782cb7b9c7 100644
--- a/gcc/gimple.h
+++ b/gcc/gimple.h
@@ -1673,6 +1673,9 @@ extern void maybe_remove_unused_call_args (struct function *, gimple *);
 extern bool gimple_inexpensive_call_p (gcall *);
 extern bool stmt_can_terminate_bb_p (gimple *);
 extern location_t gimple_or_expr_nonartificial_location (gimple *, tree);
+extern void set_gimple_stmts_not_visited (basic_block);
+extern void set_phi_stmts_not_visited (basic_block);
+extern void set_bbs_stmts_not_visited (const basic_block *, unsigned);
 gcall *gimple_build_builtin_unreachable (location_t);
 
 /* Return the disposition for a warning (or all warnings by default)
diff --git a/gcc/internal-fn.cc b/gcc/internal-fn.cc
index a07f25f3aee..5724f34dff6 100644
--- a/gcc/internal-fn.cc
+++ b/gcc/internal-fn.cc
@@ -186,6 +186,7 @@ init_internal_fns ()
 #define mask_fold_left_direct { 1, 1, false }
 #define mask_len_fold_left_direct { 1, 1, false }
 #define check_ptrs_direct { 0, 0, false }
+#define crc_direct { 1, -1, true }
 
 const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {
 #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,
@@ -3873,6 +3874,58 @@ expand_convert_optab_fn (internal_fn fn, gcall *stmt, convert_optab optab,
   expand_fn_using_insn (stmt, icode, 1, nargs);
 }
 
+/* Expand CRC call STMT.  */
+
+static void
+expand_crc_optab_fn (internal_fn fn, gcall *stmt, convert_optab optab)
+{
+    tree lhs = gimple_call_lhs (stmt);
+    tree rhs1 = gimple_call_arg (stmt, 0); // crc
+    tree rhs2 = gimple_call_arg (stmt, 1); // data
+    tree rhs3 = gimple_call_arg (stmt, 2); // polynomial
+
+    tree result_type = TREE_TYPE (lhs);
+    tree data_type = TREE_TYPE (rhs2);
+
+    gcc_assert (TYPE_MODE (result_type) >= TYPE_MODE (data_type));
+    gcc_assert (word_mode >= TYPE_MODE (result_type));
+
+    rtx dest = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);
+    rtx op1 = expand_normal (rhs1);
+    rtx op2 = expand_normal (rhs2);
+    gcc_assert (TREE_CODE (rhs3) == INTEGER_CST);
+    rtx op3 = gen_rtx_CONST_INT (TYPE_MODE (result_type),
+				 TREE_INT_CST_LOW (rhs3));
+
+    /* Use target specific expansion if it exists.
+       Otherwise, generate table-based CRC.  */
+  if (direct_internal_fn_supported_p
+      (fn, tree_pair (data_type, result_type), OPTIMIZE_FOR_BOTH))
+    {
+      class expand_operand ops[4];
+      create_output_operand (&ops[0], dest, TYPE_MODE (result_type));
+      create_input_operand (&ops[1], op1, TYPE_MODE (result_type)); // crc
+      create_input_operand (&ops[2], op2, TYPE_MODE (data_type)); // data
+      create_input_operand (&ops[3], op3, TYPE_MODE (result_type)); //polynomial
+      insn_code icode = convert_optab_handler (optab, TYPE_MODE (data_type),
+					       TYPE_MODE (result_type));
+      expand_insn (icode, 4, ops);
+      if (!rtx_equal_p (dest, ops[0].value))
+	emit_move_insn (dest, ops[0].value);
+    }
+  else
+    {
+      /* If it's IFN_CRC generate bit-forward CRC.  */
+      if (fn == IFN_CRC)
+	expand_crc_table_based (dest, op1, op2, op3, TYPE_MODE (data_type));
+      else
+	/* If it's IFN_CRC_REV generate bit-reversed CRC.  */
+	expand_reversed_crc_table_based (dest, op1, op2, op3,
+					 TYPE_MODE (data_type),
+					 generate_reflecting_code_standard);
+    }
+}
+
 /* Expanders for optabs that can use expand_direct_optab_fn.  */
 
 #define expand_unary_optab_fn(FN, STMT, OPTAB) \
@@ -4009,6 +4062,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,
 #define direct_cond_len_unary_optab_supported_p direct_optab_supported_p
 #define direct_cond_len_binary_optab_supported_p direct_optab_supported_p
 #define direct_cond_len_ternary_optab_supported_p direct_optab_supported_p
+#define direct_crc_optab_supported_p convert_optab_supported_p
 #define direct_mask_load_optab_supported_p convert_optab_supported_p
 #define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p
 #define direct_mask_load_lanes_optab_supported_p multi_vector_optab_supported_p
diff --git a/gcc/internal-fn.def b/gcc/internal-fn.def
index c14d30365c1..3693a80e3bd 100644
--- a/gcc/internal-fn.def
+++ b/gcc/internal-fn.def
@@ -200,6 +200,8 @@ along with GCC; see the file COPYING3.  If not see
 				cond_len_##UNSIGNED_OPTAB, cond_len_##TYPE)
 #endif
 
+DEF_INTERNAL_OPTAB_FN (CRC, ECF_CONST | ECF_NOTHROW, crc, crc)
+DEF_INTERNAL_OPTAB_FN (CRC_REV, ECF_CONST | ECF_NOTHROW, crc_rev, crc)
 DEF_INTERNAL_OPTAB_FN (MASK_LOAD, ECF_PURE, maskload, mask_load)
 DEF_INTERNAL_OPTAB_FN (LOAD_LANES, ECF_CONST, vec_load_lanes, load_lanes)
 DEF_INTERNAL_OPTAB_FN (MASK_LOAD_LANES, ECF_PURE,
diff --git a/gcc/optabs.def b/gcc/optabs.def
index ad14f9328b9..f840f1fec16 100644
--- a/gcc/optabs.def
+++ b/gcc/optabs.def
@@ -78,6 +78,8 @@ OPTAB_CD(smsub_widen_optab, "msub$b$a4")
 OPTAB_CD(umsub_widen_optab, "umsub$b$a4")
 OPTAB_CD(ssmsub_widen_optab, "ssmsub$b$a4")
 OPTAB_CD(usmsub_widen_optab, "usmsub$a$b4")
+OPTAB_CD(crc_optab, "crc$a$b4")
+OPTAB_CD(crc_rev_optab, "crc_rev$a$b4")
 OPTAB_CD(vec_load_lanes_optab, "vec_load_lanes$a$b")
 OPTAB_CD(vec_store_lanes_optab, "vec_store_lanes$a$b")
 OPTAB_CD(vec_mask_load_lanes_optab, "vec_mask_load_lanes$a$b")
diff --git a/gcc/opts.cc b/gcc/opts.cc
index 3333600e0ea..38ce5cdb6be 100644
--- a/gcc/opts.cc
+++ b/gcc/opts.cc
@@ -655,6 +655,7 @@ static const struct default_options default_options_table[] =
       VECT_COST_MODEL_VERY_CHEAP },
     { OPT_LEVELS_2_PLUS, OPT_finline_functions, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },
+    { OPT_LEVELS_2_PLUS, OPT_fgimple_crc_optimization, NULL, 1 },
 
     /* -O2 and above optimizations, but not -Os or -Og.  */
     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_falign_functions, NULL, 1 },
@@ -2085,6 +2086,8 @@ enable_fdo_optimizations (struct gcc_options *opts,
   SET_OPTION_IF_UNSET (opts, opts_set, flag_loop_interchange, value);
   SET_OPTION_IF_UNSET (opts, opts_set, flag_unroll_jam, value);
   SET_OPTION_IF_UNSET (opts, opts_set, flag_tree_loop_distribution, value);
+  SET_OPTION_IF_UNSET (opts, opts_set, flag_gimple_crc_optimization, value);
+
 }
 
 /* -f{,no-}sanitize{,-recover}= suboptions.  */
diff --git a/gcc/passes.def b/gcc/passes.def
index 1cbbd413097..a65d1b36ea6 100644
--- a/gcc/passes.def
+++ b/gcc/passes.def
@@ -296,6 +296,7 @@ along with GCC; see the file COPYING3.  If not see
 	  NEXT_PASS (pass_cd_dce, false /* update_address_taken_p */);
 	  NEXT_PASS (pass_iv_canon);
 	  NEXT_PASS (pass_loop_distribution);
+	  NEXT_PASS (pass_crc_optimization);
 	  NEXT_PASS (pass_linterchange);
 	  NEXT_PASS (pass_copy_prop);
 	  NEXT_PASS (pass_graphite);
diff --git a/gcc/sym-exec/condition.cc b/gcc/sym-exec/condition.cc
new file mode 100644
index 00000000000..5b558d1e315
--- /dev/null
+++ b/gcc/sym-exec/condition.cc
@@ -0,0 +1,53 @@
+#include "condition.h"
+
+bit_condition::bit_condition (value_bit *left, value_bit *right, tree_code code)
+{
+  this->m_left = left;
+  this->m_right = right;
+  this->m_code = code;
+  m_type = BIT_CONDITION;
+}
+
+
+bit_condition::bit_condition (const bit_condition &expr)
+{
+  bit_expression::copy (&expr);
+  m_code = expr.get_code ();
+}
+
+
+tree_code
+bit_condition::get_code () const
+{
+  return m_code;
+}
+
+
+value_bit *
+bit_condition::copy () const
+{
+  return new bit_condition (*this);
+}
+
+
+void
+bit_condition::print_expr_sign ()
+{
+  switch (m_code)
+    {
+      case GT_EXPR:
+	fprintf (dump_file, " > ");
+	break;
+      case LT_EXPR:
+	fprintf (dump_file, " < ");
+	break;
+      case EQ_EXPR:
+	fprintf (dump_file, " == ");
+	break;
+      case NE_EXPR:
+	fprintf (dump_file, " != ");
+	break;
+      default:
+	fprintf (dump_file, " ? ");
+    }
+}
\ No newline at end of file
diff --git a/gcc/sym-exec/condition.h b/gcc/sym-exec/condition.h
new file mode 100644
index 00000000000..1882c6cfa91
--- /dev/null
+++ b/gcc/sym-exec/condition.h
@@ -0,0 +1,26 @@
+#ifndef SYM_EXEC_CONDITION_H
+#define SYM_EXEC_CONDITION_H
+
+#include "expression.h"
+
+enum condition_status {
+  CS_NO_COND,
+  CS_TRUE,
+  CS_FALSE,
+  CS_SYM
+};
+
+
+class bit_condition : public bit_expression {
+ private:
+  tree_code m_code;
+  void print_expr_sign ();
+
+ public:
+  bit_condition (value_bit *left, value_bit *right, tree_code type);
+  bit_condition (const bit_condition &expr);
+  tree_code get_code () const;
+  value_bit *copy () const;
+};
+
+#endif /* SYM_EXEC_CONDITION_H.  */
\ No newline at end of file
diff --git a/gcc/sym-exec/expression-is-a-helper.h b/gcc/sym-exec/expression-is-a-helper.h
new file mode 100644
index 00000000000..9931254c36e
--- /dev/null
+++ b/gcc/sym-exec/expression-is-a-helper.h
@@ -0,0 +1,204 @@
+#ifndef SYM_EXEC_EXPRESSION_IS_A_HELPER_H
+#define SYM_EXEC_EXPRESSION_IS_A_HELPER_H
+
+#include "condition.h"
+
+/* Defining test functions for value conversion via dyn_cast.  */
+
+template<>
+template<>
+inline bool
+is_a_helper<symbolic_bit *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::SYMBOLIC_BIT;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::BIT;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_expression *>::test (value_bit *ptr)
+{
+  value_type type = ptr->get_type ();
+  return type == value_type::BIT_AND_EXPRESSION
+	 || type == value_type::BIT_OR_EXPRESSION
+	 || type == value_type::BIT_XOR_EXPRESSION
+	 || type == value_type::BIT_COMPLEMENT_EXPRESSION
+	 || type == value_type::SHIFT_RIGHT_EXPRESSION
+	 || type == value_type::SHIFT_LEFT_EXPRESSION
+	 || type == value_type::ADD_EXPRESSION
+	 || type == value_type::SUB_EXPRESSION
+	 || type == value_type::BIT_CONDITION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_and_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::BIT_AND_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_or_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::BIT_OR_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_xor_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::BIT_XOR_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_complement_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::BIT_COMPLEMENT_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<shift_left_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::SHIFT_LEFT_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<shift_right_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::SHIFT_RIGHT_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<add_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::ADD_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<sub_expression *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::SUB_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_condition *>::test (value_bit *ptr)
+{
+  return ptr->get_type () == value_type::BIT_CONDITION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_and_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::BIT_AND_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_or_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::BIT_OR_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_xor_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::BIT_XOR_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_complement_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::BIT_COMPLEMENT_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<shift_left_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::SHIFT_LEFT_EXPRESSION;
+}
+
+template<>
+template<>
+inline bool
+is_a_helper<shift_right_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::SHIFT_RIGHT_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<add_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::ADD_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<sub_expression *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::SUB_EXPRESSION;
+}
+
+
+template<>
+template<>
+inline bool
+is_a_helper<bit_condition *>::test (bit_expression *ptr)
+{
+  return ptr->get_type () == value_type::BIT_CONDITION;
+}
+
+#endif /* SYM_EXEC_EXPRESSION_IS_A_HELPER_H.  */
\ No newline at end of file
diff --git a/gcc/sym-exec/expression.cc b/gcc/sym-exec/expression.cc
new file mode 100644
index 00000000000..0f885550ab8
--- /dev/null
+++ b/gcc/sym-exec/expression.cc
@@ -0,0 +1,374 @@
+/* Every class defined here represents a single bit value of a variable.
+   Every variable will be represented as a vector of these classes which later
+   will be used for bit-level symbolic execution.  */
+
+#include "expression-is-a-helper.h"
+
+value_type
+value_bit::get_type () const
+{
+  return m_type;
+}
+
+symbolic_bit::symbolic_bit (size_t i, tree orig)
+    : value_bit (i), m_origin (orig)
+{
+  m_type = SYMBOLIC_BIT;
+}
+
+
+bit::bit (unsigned char i) : m_val (i)
+{
+  m_type = BIT;
+}
+
+
+value_bit *
+bit_expression::get_left ()
+{
+  return m_left;
+}
+
+
+value_bit *
+bit_expression::get_right ()
+{
+  return m_right;
+}
+
+
+void
+bit_expression::set_left (value_bit *expr)
+{
+  m_left = expr;
+}
+
+
+void
+bit_expression::set_right (value_bit *expr)
+{
+  m_right = expr;
+}
+
+
+size_t
+value_bit::get_index () const
+{
+  return m_index;
+}
+
+
+unsigned char
+bit::get_val () const
+{
+  return m_val;
+}
+
+
+void
+bit::set_val (unsigned char new_val)
+{
+  m_val = new_val;
+}
+
+
+bit_complement_expression::bit_complement_expression (value_bit *right)
+{
+  this->m_left = nullptr;
+  this->m_right = right;
+  m_type = BIT_COMPLEMENT_EXPRESSION;
+}
+
+
+bit_complement_expression::bit_complement_expression (
+  const bit_complement_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+bit_expression::~bit_expression ()
+{
+  delete m_left;
+  m_left = nullptr;
+  delete m_right;
+  m_right = nullptr;
+}
+
+
+value_bit *
+symbolic_bit::copy () const
+{
+  return new symbolic_bit (*this);
+}
+
+
+value_bit *
+bit::copy () const
+{
+  return new bit (*this);
+}
+
+
+void
+bit_expression::copy (const bit_expression *expr)
+{
+  if (expr->m_left)
+    m_left = expr->m_left->copy ();
+
+  if (expr->m_right)
+    m_right = expr->m_right->copy ();
+
+  m_type = expr->m_type;
+}
+
+
+value_bit *
+bit_xor_expression::copy () const
+{
+  return new bit_xor_expression (*this);
+}
+
+
+value_bit *
+bit_and_expression::copy () const
+{
+  return new bit_and_expression (*this);
+}
+
+
+value_bit *
+bit_or_expression::copy () const
+{
+  return new bit_or_expression (*this);
+}
+
+
+value_bit *
+shift_right_expression::copy () const
+{
+  return new shift_right_expression (*this);
+}
+
+
+value_bit *
+shift_left_expression::copy () const
+{
+  return new shift_left_expression (*this);
+}
+
+
+value_bit *
+add_expression::copy () const
+{
+  return new add_expression (*this);
+}
+
+
+value_bit *
+sub_expression::copy () const
+{
+  return new sub_expression (*this);
+}
+
+
+value_bit *
+bit_complement_expression::copy () const
+{
+  return new bit_complement_expression (*this);
+}
+
+
+bit_xor_expression::bit_xor_expression (value_bit *left, value_bit *right)
+{
+  this->m_left = left;
+  this->m_right = right;
+  m_type = BIT_XOR_EXPRESSION;
+}
+
+
+bit_xor_expression::bit_xor_expression (const bit_xor_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+bit_and_expression::bit_and_expression (value_bit *left, value_bit *right)
+{
+  this->m_left = left;
+  this->m_right = right;
+  m_type = BIT_AND_EXPRESSION;
+}
+
+
+bit_and_expression::bit_and_expression (const bit_and_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+bit_or_expression::bit_or_expression (value_bit *left, value_bit *right)
+{
+  this->m_left = left;
+  this->m_right = right;
+  m_type = BIT_OR_EXPRESSION;
+}
+
+
+bit_or_expression::bit_or_expression (const bit_or_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+shift_right_expression::shift_right_expression (value_bit *left,
+						value_bit *right)
+{
+  this->m_left = left;
+  this->m_right = right;
+  m_type = SHIFT_RIGHT_EXPRESSION;
+}
+
+
+shift_right_expression::shift_right_expression (
+  const shift_right_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+shift_left_expression::shift_left_expression (value_bit *left, value_bit *right)
+{
+  this->m_left = left;
+  this->m_right = right;
+  m_type = SHIFT_LEFT_EXPRESSION;
+}
+
+
+shift_left_expression::shift_left_expression (const shift_left_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+add_expression::add_expression (value_bit *left, value_bit *right)
+{
+  this->m_left = left;
+  this->m_right = right;
+  m_type = ADD_EXPRESSION;
+}
+
+
+add_expression::add_expression (const add_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+sub_expression::sub_expression (value_bit *left, value_bit *right)
+{
+  this->m_left = left;
+  this->m_right = right;
+  m_type = SUB_EXPRESSION;
+}
+
+
+sub_expression::sub_expression (const sub_expression &expr)
+{
+  bit_expression::copy (&expr);
+}
+
+
+tree
+symbolic_bit::get_origin ()
+{
+  return m_origin;
+}
+
+
+void
+symbolic_bit::print ()
+{
+  if (dump_file)
+    {
+      print_generic_expr (dump_file, m_origin, dump_flags);
+      fprintf (dump_file, "[%zu]", m_index);
+    }
+}
+
+
+void
+bit::print ()
+{
+  if (dump_file)
+    fprintf (dump_file, "%u", m_val);
+}
+
+
+void
+bit_expression::print_expr_sign ()
+{
+  switch (m_type)
+    {
+      case BIT_XOR_EXPRESSION:
+	fprintf (dump_file, " ^ ");
+	break;
+      case BIT_AND_EXPRESSION:
+	fprintf (dump_file, " & ");
+	break;
+      case BIT_OR_EXPRESSION:
+	fprintf (dump_file, " | ");
+	break;
+      case SHIFT_RIGHT_EXPRESSION:
+	fprintf (dump_file, " >> ");
+	break;
+      case SHIFT_LEFT_EXPRESSION:
+	fprintf (dump_file, " << ");
+	break;
+      case ADD_EXPRESSION:
+	fprintf (dump_file, " + ");
+	break;
+      case SUB_EXPRESSION:
+	fprintf (dump_file, " - ");
+	break;
+      default:
+	fprintf (dump_file, " ?? ");
+    }
+}
+
+
+void
+bit_expression::print ()
+{
+  if (dump_file)
+    {
+      fprintf (dump_file, "(");
+      if (m_left)
+	m_left->print ();
+      else
+	fprintf (dump_file, "null");
+
+      print_expr_sign ();
+
+      if (m_right)
+	m_right->print ();
+      else
+	fprintf (dump_file, "null");
+
+      fprintf (dump_file, ")");
+    }
+}
+
+
+void
+bit_complement_expression::print ()
+{
+  if (dump_file)
+    {
+      fprintf (dump_file, "!");
+      if (m_right)
+	m_right->print ();
+      else
+	fprintf (dump_file, "null");
+    }
+}
\ No newline at end of file
diff --git a/gcc/sym-exec/expression.h b/gcc/sym-exec/expression.h
new file mode 100644
index 00000000000..da17b8042c7
--- /dev/null
+++ b/gcc/sym-exec/expression.h
@@ -0,0 +1,204 @@
+/* Every class defined here represents a single bit value of a variable.
+   Every variable will be represented as a vector of these classes which later
+   will be used for bit-level symbolic execution.  */
+
+#ifndef SYM_EXEC_EXPRESSION_H
+#define SYM_EXEC_EXPRESSION_H
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "tree.h"
+#include "hwint.h"
+#include "gimple-pretty-print.h"
+#include "is-a.h"
+#include "vec.h"
+#include "hash-map.h"
+#include "hash-set.h"
+#include "stddef.h"
+
+enum value_type {
+  SYMBOLIC_BIT,
+  BIT,
+  BIT_XOR_EXPRESSION,
+  BIT_AND_EXPRESSION,
+  BIT_OR_EXPRESSION,
+  BIT_COMPLEMENT_EXPRESSION,
+  SHIFT_RIGHT_EXPRESSION,
+  SHIFT_LEFT_EXPRESSION,
+  ADD_EXPRESSION,
+  SUB_EXPRESSION,
+  BIT_CONDITION
+};
+
+/* Base class for single bit value.  */
+
+class value_bit {
+ protected:
+  /* This will help us to understand where is moved the bit
+     from its initial position.  */
+  const size_t m_index;
+  value_type m_type;
+
+ public:
+  value_bit () : m_index (0)
+  {};
+  value_bit (size_t i) : m_index (i)
+  {};
+  value_bit (const value_bit &val) : m_index (val.m_index)
+  {};
+  size_t get_index () const;
+  value_type get_type () const;
+
+  /* This will support deep copy of objects' values.  */
+  virtual value_bit *copy () const = 0;
+  virtual void print () = 0;
+  virtual ~value_bit () = default;
+};
+
+/* Represents value of a single bit of symbolic marked variables.  */
+
+class symbolic_bit : public value_bit {
+  tree m_origin = nullptr;
+
+ public:
+  symbolic_bit (size_t i, tree orig);
+  symbolic_bit (const symbolic_bit &sym_bit) : symbolic_bit (sym_bit.m_index,
+							     sym_bit.m_origin)
+  {};
+
+  value_bit *copy () const;
+  void print ();
+  tree get_origin ();
+};
+
+
+/* Represents value of a single bit.  */
+
+class bit : public value_bit {
+ private:
+  /* This is the value of a bit.  It must be either 1 or 0.  */
+  unsigned char m_val = 0;
+
+ public:
+  bit (unsigned char i);
+  bit (const bit &b) : bit (b.m_val)
+  {};
+  unsigned char get_val () const;
+  void set_val (unsigned char new_val);
+  value_bit *copy () const;
+  void print ();
+};
+
+
+/* Bit-level base expression class.  In general expressions consist of
+   two operands.  Here we named them m_left and right.  */
+
+class bit_expression : public value_bit {
+ protected:
+  value_bit *m_left = nullptr;
+  value_bit *m_right = nullptr;
+
+  void copy (const bit_expression *expr);
+  virtual void print_expr_sign ();
+
+ public:
+  value_bit *get_left ();
+  value_bit *get_right ();
+
+  ~bit_expression ();
+
+  void set_left (value_bit *expr);
+  void set_right (value_bit *expr);
+  value_bit *copy () const = 0;
+  void print ();
+};
+
+
+/* Bit-level XOR expression.  XOR operation on two variables (when one of
+   them is symbolic) can be represented by XOR operations on
+   each of their bits.  */
+
+class bit_xor_expression : public bit_expression {
+ public:
+  bit_xor_expression (value_bit *left, value_bit *right);
+  bit_xor_expression (const bit_xor_expression &expr);
+  value_bit *copy () const;
+};
+
+
+/* Bit-level AND expression.  AND operation on two variables (when one of
+   them is symbolic) can be represented by AND operations on
+   each of their bits.  */
+
+class bit_and_expression : public bit_expression {
+ public:
+  bit_and_expression (value_bit *left, value_bit *right);
+  bit_and_expression (const bit_and_expression &expr);
+  value_bit *copy () const;
+};
+
+
+/* Bit-level OR expression.  OR operation on two variables (when one of
+   them is symbolic) can be represented by OR operations on
+   each of their bits.  */
+
+class bit_or_expression : public bit_expression {
+ public:
+  bit_or_expression (value_bit *left, value_bit *right);
+  bit_or_expression (const bit_or_expression &expr);
+  value_bit *copy () const;
+};
+
+
+/* SHIFT_RIGHT expression.  Result must be stored bit by bit.  */
+
+class shift_right_expression : public bit_expression {
+ public:
+  shift_right_expression (value_bit *left, value_bit *right);
+  shift_right_expression (const shift_right_expression &expr);
+  value_bit *copy () const;
+};
+
+
+/* SHIFT_LEFT expression.  Result must be stored bit by bit.  */
+
+class shift_left_expression : public bit_expression {
+ public:
+  shift_left_expression (value_bit *left, value_bit *right);
+  shift_left_expression (const shift_left_expression &expr);
+  value_bit *copy () const;
+};
+
+
+/* ADD expression.  Result must be stored bit by bit.  */
+
+class add_expression : public bit_expression {
+ public:
+  add_expression (value_bit *left, value_bit *right);
+  add_expression (const add_expression &expr);
+  value_bit *copy () const;
+};
+
+
+/* SUB expression.  Result must be stored bit by bit.  */
+
+class sub_expression : public bit_expression {
+ public:
+  sub_expression (value_bit *left, value_bit *right);
+  sub_expression (const sub_expression &expr);
+  value_bit *copy () const;
+};
+
+/* Bit-level negation expression.  */
+
+class bit_complement_expression : public bit_expression {
+ public:
+  bit_complement_expression (value_bit *right);
+  bit_complement_expression (const bit_complement_expression &expr);
+  value_bit *copy () const;
+  void print ();
+};
+
+#endif /* SYM_EXEC_EXPRESSION_H.  */
\ No newline at end of file
diff --git a/gcc/sym-exec/state.cc b/gcc/sym-exec/state.cc
new file mode 100644
index 00000000000..4fd29237c5b
--- /dev/null
+++ b/gcc/sym-exec/state.cc
@@ -0,0 +1,2330 @@
+/* State will store states of variables for a function's single execution path.
+   It will be used for bit-level symbolic execution to determine values of bits
+   of function's return value and symbolic marked arguments.  */
+
+#include "state.h"
+
+size_t min (size_t a, size_t b, size_t c)
+{
+  size_t min = (a < b ? a : b);
+  return min < c ? min : c;
+}
+
+
+state::state (const state &s)
+{
+  for (auto iter = s.var_states.begin (); iter != s.var_states.end (); ++iter)
+    {
+      value val ((*iter).second.length (), (*iter).second.is_unsigned);
+      for (size_t i = 0; i < (*iter).second.length (); i++)
+	val.push ((*iter).second[i]->copy ());
+
+      var_states.put ((*iter).first, val);
+    }
+
+  for (auto iter = s.conditions.begin (); iter != s.conditions.end (); ++iter)
+    conditions.add (as_a<bit_expression *> ((*iter)->copy ()));
+}
+
+
+state::~state ()
+{
+  clear_conditions ();
+}
+
+
+/* Checks whether state for variable with specified name already
+   exists or not.  */
+
+bool
+state::is_declared (tree var)
+{
+  return var_states.get (var) != NULL;
+}
+
+
+/* Declares given variable if it has not been declared yet.  */
+
+void
+state::declare_if_needed (tree var, size_t size)
+{
+  if (TREE_CODE (var) != INTEGER_CST && !is_declared (var))
+    {
+      make_symbolic (var, size);
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	{
+	  fprintf (dump_file,
+		   "Declaring var ");
+	  print_generic_expr (dump_file, var, dump_flags);
+	  fprintf (dump_file,
+		   " with size %zd\n", size);
+	}
+    }
+}
+
+
+/* Get value of the given variable.  */
+
+value *
+state::get_value (tree var)
+{
+  return var_states.get (var);
+}
+
+
+/* Get the value of the tree, which is in the beginning of the var_states.  */
+
+value *
+state::get_first_value ()
+{
+  return &(*(var_states.begin ())).second;
+}
+
+
+/* Returns the list of conditions in the state.  */
+
+const hash_set<bit_expression *> &
+state::get_conditions ()
+{
+  return conditions;
+}
+
+
+/* Checks if sizes of arguments and destination are compatible.  */
+
+bool
+state::check_args_compatibility (tree arg1, tree arg2, tree dest)
+{
+  if (!(get_var_size (arg1) == get_var_size (dest)
+	|| TREE_CODE (arg1) == INTEGER_CST)
+      || !(get_var_size (arg2) == get_var_size (dest)
+	   || TREE_CODE (arg2) == INTEGER_CST))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Sym-Exec: Incompatible destination"
+			    "and argument sizes.\n");
+
+      return false;
+    }
+
+  return true;
+}
+
+
+/* Creates value for given constant tree.  */
+
+value
+state::create_val_for_const (tree var, size_t size)
+{
+  unsigned HOST_WIDE_INT val = TYPE_UNSIGNED (TREE_TYPE (var))
+			       ? tree_to_uhwi (var) : tree_to_shwi (var);
+  value result (size, TYPE_UNSIGNED (TREE_TYPE (var)));
+
+  for (size_t i = 0; i < size; i++)
+    {
+      result.push (new bit (val & 1));
+      val >>= 1;
+    }
+
+  return result;
+}
+
+
+/* Adds the given variable to state.  */
+
+bool
+state::add_var_state (tree var, value *vstate)
+{
+  size_t size = vstate->length ();
+  value val (size, vstate->is_unsigned);
+  for (size_t i = 0; i < size; i++)
+    val.push ((*vstate)[i]->copy ());
+
+  return var_states.put (var, val);
+}
+
+
+/* Adds the given condition to the state.  */
+
+bool
+state::add_condition (bit_expression *cond)
+{
+  return conditions.add (as_a<bit_expression *> (cond->copy ()));
+}
+
+
+/* Bulk add the given conditions to the state.  */
+
+bool
+state::bulk_add_conditions (const hash_set<bit_expression *> &conds)
+{
+  bool status = true;
+  for (auto iter = conds.begin (); iter != conds.end (); ++iter)
+    status &= add_condition (*iter);
+
+  return status;
+}
+
+
+/* Remove all states from the states' vector.  */
+
+void
+state::remove_states (vec<state *> *states)
+{
+  while (!states->is_empty ())
+    {
+      delete states->last ();
+      states->pop ();
+    }
+}
+
+
+/* Remove all states from the states' vector and release the vector.  */
+
+void
+state::clear_states (vec<state *> *states)
+{
+  remove_states (states);
+  states->release ();
+}
+
+
+void
+state::clear_var_states ()
+{
+  var_states.empty ();
+}
+
+
+void
+state::clear_conditions ()
+{
+  for (auto iter = conditions.begin (); iter != conditions.end (); ++iter)
+    delete (*iter);
+  conditions.empty ();
+}
+
+
+/* Performs AND operation for 2 symbolic_bit operands.  */
+
+value_bit *
+state::and_sym_bits (const value_bit *var1, const value_bit *var2)
+{
+  return new bit_and_expression (var1->copy (), var2->copy ());
+}
+
+
+/* Performs AND operation for a symbolic_bit and const_bit operands.  */
+
+value_bit *
+state::and_var_const (const value_bit *var1, const bit *const_bit)
+{
+  if (const_bit->get_val () == 1)
+    return var1->copy ();
+
+  return new bit (0);
+}
+
+
+/* Performs AND operation for 2 constant bit operands.  */
+
+bit *
+state::and_const_bits (const bit *const_bit1, const bit *const_bit2)
+{
+  if (const_bit1->get_val () == const_bit2->get_val ())
+    return new bit (*const_bit1);
+
+  return new bit (0);
+}
+
+
+/* Performs OR operation for 2 symbolic_bit operands.  */
+
+value_bit *
+state::or_sym_bits (const value_bit *var1, const value_bit *var2)
+{
+  return new bit_or_expression (var1->copy (), var2->copy ());
+}
+
+
+/* Performs OR operation for a symbolic_bit and a constant bit operands.  */
+
+value_bit *
+state::or_var_const (const value_bit *var1, const bit *const_bit)
+{
+  if (const_bit->get_val () == 0)
+    return var1->copy ();
+
+  return new bit (1);
+}
+
+
+/* Performs OR operation for 2 constant bit operands.  */
+
+bit *
+state::or_const_bits (const bit *const_bit1, const bit *const_bit2)
+{
+  if (const_bit1->get_val () == const_bit2->get_val ())
+    return new bit (*const_bit1);
+
+  return new bit (1);
+}
+
+
+/* Adds an empty state for the given variable.  */
+
+bool
+state::decl_var (tree var, unsigned size)
+{
+  if (is_declared (var))
+    return false;
+
+  value val (size, TYPE_UNSIGNED (TREE_TYPE (var)));
+  for (unsigned i = 0; i < size; i++)
+    val.push (nullptr);
+
+  return var_states.put (var, val);
+}
+
+
+/* Returns size of the given variable.  */
+
+unsigned
+state::get_var_size (tree var)
+{
+  value *content = var_states.get (var);
+  if (content == NULL)
+    return 0;
+
+  return content->allocated ();
+}
+
+
+/* Adds a variable with unknown value to state.  Such variables are
+   represented as sequence of symbolic bits.  */
+
+bool
+state::make_symbolic (tree var, unsigned size)
+{
+  if (is_declared (var))
+    return false;
+
+  value val (size, TYPE_UNSIGNED (TREE_TYPE (var)));
+  /* Initialize each bit of a variable with unknown value.  */
+  for (size_t i = 0; i < size; i++)
+    val.push (new symbolic_bit (i, var));
+
+  return var_states.put (var, val);
+}
+
+
+/* Performs AND operation on two bits.  */
+
+value_bit *
+state::and_two_bits (value_bit *arg1, value_bit *arg2)
+{
+  value_bit *result = nullptr;
+
+  if (is_a<bit *> (arg1) && is_a<bit *> (arg2))
+    result = and_const_bits (as_a<bit *> (arg1), as_a<bit *> (arg2));
+
+  else if (is_a<bit *> (arg1) && (is_a<symbolic_bit *> (arg2)
+				  || (is_a<bit_expression *> (arg2))))
+    result = and_var_const (arg2, as_a<bit *> (arg1));
+
+  else if ((is_a<symbolic_bit *> (arg1)
+	    || (is_a<bit_expression *> (arg1))) && is_a<bit *> (arg2))
+    result = and_var_const (arg1, as_a<bit *> (arg2));
+
+  else
+    result = and_sym_bits (arg1, arg2);
+
+  return result;
+}
+
+
+/* A wrapper for operations on two bits.
+   Operation and operands are passed as arguments.  */
+
+value_bit *
+state::operate_bits (bit_func bit_op, value_bit *bit1, value_bit *bit2,
+		     value_bit **)
+{
+  return (bit_op) (bit1, bit2);
+}
+
+
+/* A wrapper for operations on three bits.
+   Operation and operands are passed as arguments.  */
+
+value_bit *
+state::operate_bits (bit_func3 bit_op, value_bit *bit1, value_bit *bit2,
+		     value_bit **bit3)
+{
+  return (bit_op) (bit1, bit2, bit3);
+}
+
+
+/* Does preprocessing and postprocessing for expressions with tree operands.
+   Handles value creation for constant and their removement in the end.  */
+
+bool
+state::do_binary_operation (tree arg1, tree arg2, tree dest,
+			    binary_func bin_func)
+{
+  declare_if_needed (dest, tree_to_uhwi (TYPE_SIZE (TREE_TYPE (dest))));
+  declare_if_needed (arg1, var_states.get (dest)->allocated ());
+  declare_if_needed (arg2, var_states.get (dest)->allocated ());
+
+  if (!check_args_compatibility (arg1, arg2, dest))
+    return false;
+
+  size_t dest_size = var_states.get (dest)->length ();
+
+  value *arg1_val = var_states.get (arg1);
+  value arg1_const_val (dest_size, false);
+  if (arg1_val == NULL && TREE_CODE (arg1) == INTEGER_CST)
+    {
+      arg1_const_val = create_val_for_const (arg1, dest_size);
+      arg1_val = &arg1_const_val;
+    }
+
+  value *arg2_val = var_states.get (arg2);
+  value arg2_const_val (dest_size, false);
+  if (arg2_val == NULL && TREE_CODE (arg2) == INTEGER_CST)
+    {
+      arg2_const_val = create_val_for_const (arg2, dest_size);
+      arg2_val = &arg2_const_val;
+    }
+
+  (this->*bin_func) (arg1_val, arg2_val, dest);
+  print_value (var_states.get (dest));
+  return true;
+}
+
+
+/* Does bit-level AND operation for given variables.  */
+
+bool
+state::do_and (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_and);
+}
+
+
+/* Performs AND operation on given values.  The result is stored in dest.  */
+
+void
+state::do_and (value *arg1, value *arg2, tree dest)
+{
+  /* Creating AND expressions for every bit pair of given arguments
+     and store them as a new state for given destination.  */
+
+  operate (arg1, arg2, nullptr, dest, &state::and_two_bits);
+}
+
+
+/* Performs OR operation on two bits.  */
+
+value_bit *
+state::or_two_bits (value_bit *arg1_bit, value_bit *arg2_bit)
+{
+  value_bit *result = nullptr;
+
+  if (is_a<bit *> (arg1_bit) && is_a<bit *> (arg2_bit))
+    result = or_const_bits (as_a<bit *> (arg1_bit), as_a<bit *> (arg2_bit));
+
+  else if (is_a<bit *> (arg1_bit) && (is_a<symbolic_bit *> (arg2_bit)
+				      || is_a<bit_expression *> (arg2_bit)))
+    result = or_var_const (arg2_bit, as_a<bit *> (arg1_bit));
+
+  else if ((is_a<symbolic_bit *> (arg1_bit)
+	    || is_a<bit_expression *> (arg1_bit))
+	   && is_a<bit *> (arg2_bit))
+    result = or_var_const (arg1_bit, as_a<bit *> (arg2_bit));
+
+  else
+    result = or_sym_bits (arg1_bit, arg2_bit);
+
+  return result;
+}
+
+
+/* Does bit-level OR operation for given variables.  */
+
+bool
+state::do_or (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_or);
+}
+
+
+/* Performs OR operation on given values.  The result is stored in dest.  */
+
+void
+state::do_or (value *arg1, value *arg2, tree dest)
+{
+  /* Creating OR expressions for every bit pair of given arguments
+     and store them as a new state for given destination.  */
+  operate (arg1, arg2, nullptr, dest, &state::or_two_bits);
+}
+
+
+/* Performs XOR operation on two bits.  */
+
+value_bit *
+state::xor_two_bits (value_bit *arg1_bit, value_bit *arg2_bit)
+{
+  value_bit *result = nullptr;
+
+  if (is_a<bit *> (arg1_bit) && is_a<bit *> (arg2_bit))
+    result = xor_const_bits (as_a<bit *> (arg1_bit), as_a<bit *> (arg2_bit));
+
+  else if (is_a<bit *> (arg1_bit) && (is_a<symbolic_bit *> (arg2_bit)
+				      || is_a<bit_expression *> (arg2_bit)))
+    result = xor_var_const (arg2_bit, as_a<bit *> (arg1_bit));
+
+  else if ((is_a<symbolic_bit *> (arg1_bit)
+	    || is_a<bit_expression *> (arg1_bit))
+	   && is_a<bit *> (arg2_bit))
+    result = xor_var_const (arg1_bit, as_a<bit *> (arg2_bit));
+
+  else
+    result = xor_sym_bits (arg1_bit, arg2_bit);
+
+  return result;
+}
+
+
+/* Does bit-level XOR operation for given variables.  */
+
+bool
+state::do_xor (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_xor);
+}
+
+
+/* Performs XOR operation on given values.  The result is stored in dest.  */
+
+void
+state::do_xor (value *arg1, value *arg2, tree dest)
+{
+  operate (arg1, arg2, nullptr, dest, &state::xor_two_bits);
+}
+
+
+/* Shifts value right by size of shift_value.  */
+
+value *
+state::shift_right_by_const (value *var, size_t shift_value)
+{
+  value *shift_result = new value (var->length (), var->is_unsigned);
+  if (var->length () <= shift_value)
+    for (size_t i = 0; i < var->length (); i++)
+      shift_result->push (new bit (0));
+  else
+    {
+      size_t i = 0;
+      for (; i < var->length () - shift_value; ++i)
+	shift_result->push (((*var)[shift_value + i])->copy ());
+
+      for (; i < var->length (); ++i)
+	shift_result->push (var->is_unsigned ? new bit (0)
+					     : var->last ()->copy ());
+    }
+  return shift_result;
+}
+
+
+/* Checks if all bits of the given value have constant bit type.  */
+
+bool
+state::is_bit_vector (const value *var)
+{
+  if (var == nullptr || !var->exists ())
+    return false;
+
+  for (size_t i = 0; i < var->length (); i++)
+    if (!(is_a<bit *> ((*var)[i])))
+      return false;
+  return true;
+}
+
+
+/* Returns the number represented by the value.  */
+
+unsigned HOST_WIDE_INT
+state::make_number (const value *var)
+{
+  unsigned HOST_WIDE_INT
+  number = 0;
+  int value_size = var->length ();
+  for (int i = value_size - 1; i >= 0; i--)
+    {
+      if (is_a<bit *> ((*var)[i]))
+	number = (number << 1) | as_a<bit *> ((*var)[i])->get_val ();
+      else
+	return 0;
+    }
+  return number;
+}
+
+
+/* Shift_left operation.  Case: var2 is a symbolic value.  */
+
+value_bit *
+state::shift_left_sym_bits (value_bit *var1, value_bit *var2)
+{
+  return new shift_left_expression (var1->copy (), var2->copy ());
+}
+
+
+/* Does shift_left operation for given variables.  */
+
+bool
+state::do_shift_left (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_shift_left);
+}
+
+
+/* Performs shift left operation on given values.
+   The result is stored in dest.  */
+
+void
+state::do_shift_left (value *arg1, value *arg2, tree dest)
+{
+  if (is_bit_vector (arg2))
+    {
+      size_t shift_value = make_number (arg2);
+      value *result = shift_left_by_const (arg1, shift_value);
+      for (size_t i = 0; i < get_var_size (dest); i++)
+	{
+	  delete (*var_states.get (dest))[i];
+	  (*var_states.get (dest))[i] = (*result)[i]->copy ();
+	}
+      delete result;
+    }
+  else
+    operate (arg1, arg2, nullptr, dest, &state::shift_left_sym_bits);
+}
+
+
+/* Does shift_right operation for given variables.  */
+
+bool
+state::do_shift_right (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_shift_right);
+}
+
+
+/* Performs shift right operation on given values.
+   The result is stored in dest.  */
+
+void
+state::do_shift_right (value *arg1, value *arg2, tree dest)
+{
+  if (is_bit_vector (arg2))
+    {
+      size_t shift_value = make_number (arg2);
+      value *result = shift_right_by_const (arg1, shift_value);
+      for (size_t i = 0; i < get_var_size (dest); i++)
+	{
+	  delete (*var_states.get (dest))[i];
+	  (*var_states.get (dest))[i] = (*result)[i]->copy ();
+	}
+
+      delete result;
+    }
+  else
+    operate (arg1, arg2, nullptr, dest, &state::shift_right_sym_bits);
+}
+
+
+/* Adds two bits and carry value.
+   Resturn result and stores new carry bit in "carry".  */
+
+value_bit *
+state::full_adder (value_bit *var1, value_bit *var2, value_bit **carry)
+{
+  value_bit *new_carry = and_two_bits (var1, var2);
+  value_bit *sum = xor_two_bits (var1, var2);
+
+  value_bit *result = xor_two_bits (sum, *carry);
+  value_bit *sum_and_carry = and_two_bits (sum, *carry);
+
+  delete *carry;
+  delete sum;
+
+  *carry = or_two_bits (sum_and_carry, new_carry);
+
+  delete sum_and_carry;
+  delete new_carry;
+
+  return result;
+}
+
+
+/* Adds two variables.  */
+
+bool
+state::do_add (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_add);
+}
+
+
+/* Adds given values.  The result is stored in dest.  */
+
+void
+state::do_add (value *arg1, value *arg2, tree dest)
+{
+  value_bit *carry = new bit (0);
+  operate (arg1, arg2, &carry, dest, &state::full_adder);
+  delete carry;
+}
+
+
+/* Returns the additive inverse of the given number.  */
+
+value *
+state::additive_inverse (const value *number)
+{
+  value *result = new value (number->length (), number->is_unsigned);
+  value one (number->length (), number->is_unsigned);
+
+  size_t size = number->length ();
+  one.push (new bit (1));
+  result->push (complement_a_bit ((*number)[0]));
+
+  for (size_t i = 1; i < size; i++)
+    {
+      one.push (new bit (0));
+      result->push (complement_a_bit ((*number)[i]));
+    }
+
+  value_bit *carry = new bit (0);
+  for (size_t i = 0; i < size; ++i)
+    {
+      value_bit *cur_bit = (*result)[i];
+      (*result)[i] = full_adder (cur_bit, one[i], &carry);
+      delete cur_bit;
+    }
+
+  delete carry;
+  return result;
+}
+
+
+/* Does subtraction.  */
+
+bool
+state::do_sub (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_sub);
+}
+
+
+/* Subtracks second value from the first.  The result is stored in dest.  */
+
+void
+state::do_sub (value *arg1, value *arg2, tree dest)
+{
+  value *neg_arg2 = additive_inverse (arg2);
+  do_add (arg1, neg_arg2, dest);
+  delete neg_arg2;
+}
+
+
+/* Performs complement operation on a bit.  */
+
+value_bit *
+state::complement_a_bit (value_bit *var)
+{
+  value_bit *result = nullptr;
+  if (is_a<bit *> (var))
+    result = complement_const_bit (as_a<bit *> (var));
+  else
+    result = complement_sym_bit (var);
+
+  return result;
+}
+
+
+/* Negates given variable.  */
+
+bool
+state::do_complement (tree arg, tree dest)
+{
+  declare_if_needed (dest, tree_to_uhwi (TYPE_SIZE (TREE_TYPE (dest))));
+  declare_if_needed (arg, var_states.get (dest)->allocated ());
+
+  /* Creating complement expressions for every bit the given argument
+     and store it as a new state for given destination.  */
+  size_t iter_count = min (get_var_size (dest), get_var_size (arg),
+			   get_var_size (arg));
+
+  size_t i = 0;
+  for (; i < iter_count; i++)
+    {
+      value_bit *result = complement_a_bit ((*var_states.get (arg))[i]);
+      delete (*var_states.get (dest))[i];
+      (*var_states.get (dest))[i] = result;
+    }
+
+  if (i >= get_var_size (dest))
+    {
+      print_value (var_states.get (dest));
+      return true;
+    }
+
+  for (; i < get_var_size (dest); i++)
+    {
+      delete (*var_states.get (dest))[i];
+      bit tmp (0);
+      (*var_states.get (dest))[i] = complement_a_bit (&tmp);
+    }
+
+  print_value (var_states.get (dest));
+  return true;
+}
+
+
+/* Does Assignment.  */
+
+bool
+state::do_assign (tree arg, tree dest)
+{
+  declare_if_needed (dest, tree_to_uhwi (TYPE_SIZE (TREE_TYPE (dest))));
+  if (TREE_CODE (arg) != INTEGER_CST)
+    declare_if_needed (arg, tree_to_uhwi (TYPE_SIZE (TREE_TYPE (arg))));
+  else
+    declare_if_needed (arg, var_states.get (dest)->allocated ());
+
+  value *dest_val = var_states.get (dest);
+
+  /* If the argument is already defined, then we must just copy its bits.  */
+  if (auto arg_val = var_states.get (arg))
+    {
+      for (size_t i = 0; i < dest_val->length (); i++)
+	{
+	  value_bit *new_val = nullptr;
+	  if (i < arg_val->length ())
+	    new_val = (*arg_val)[i]->copy ();
+	  else
+	    new_val = new bit (0);
+
+	  delete (*dest_val)[i];
+	  (*dest_val)[i] = new_val;
+	}
+    }
+    /* If the argument is a constant, we must save it as sequence of bits.  */
+  else if (TREE_CODE (arg) == INTEGER_CST)
+    {
+      value arg_val
+	= create_val_for_const (arg, dest_val->length ());
+      for (size_t i = 0; i < dest_val->length (); i++)
+	{
+	  delete (*dest_val)[i];
+	  (*dest_val)[i] = arg_val[i]->copy ();
+	}
+    }
+  else
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Sym-Exec: Unsupported assignment"
+			    " for given argument.\n");
+
+      return false;
+    }
+
+  print_value (var_states.get (dest));
+  return true;
+}
+
+
+/* Assigns pow 2 value.  */
+
+bool
+state::do_assign_pow2 (tree dest, unsigned pow)
+{
+  value *dest_val = var_states.get (dest);
+  unsigned dest_size = dest_val ? dest_val->allocated ()
+				: tree_to_uhwi (TYPE_SIZE (TREE_TYPE (dest)));
+  if (pow > dest_size)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Sym-Exec: pow %u of 2 won't fit in"
+			    " specified destination\n", pow);
+      return false;
+    }
+
+  if (!dest_val)
+    {
+      decl_var (dest, tree_to_uhwi (TYPE_SIZE (TREE_TYPE (dest))));
+      dest_val = var_states.get (dest);
+    }
+  else
+    dest_val->free_bits ();
+
+  for (unsigned i = 0; i < dest_val->length (); i++)
+    {
+      if (i == pow)
+	(*dest_val)[i] = new bit (1);
+      else
+	(*dest_val)[i] = new bit (0);
+    }
+
+  print_value (dest_val);
+  return true;
+}
+
+
+/* Performs NOT operation for constant bit.  */
+
+bit *
+state::complement_const_bit (const bit *const_bit)
+{
+  return new bit (1u ^ const_bit->get_val ());
+}
+
+
+/* Performs NOT operation for symbolic_bit.  */
+
+value_bit *
+state::complement_sym_bit (const value_bit *var)
+{
+  return new bit_complement_expression (var->copy ());
+}
+
+
+/* Performs XOR operation for 2 symbolic_bit operands.  */
+
+value_bit *
+state::xor_sym_bits (const value_bit *var1, const value_bit *var2)
+{
+  value_bit *var2_copy = var2->copy ();
+  bit_expression *node2_with_const_child = nullptr;
+  bit_expression *parent_of_node2_with_child = nullptr;
+  get_parent_with_const_child (var2_copy, node2_with_const_child,
+			       parent_of_node2_with_child);
+
+  if (node2_with_const_child != nullptr)
+    {
+      value_bit *var1_copy = var1->copy ();
+      bit_expression *node1_with_const_child = nullptr;
+      bit_expression *parent_of_node1_with_child = nullptr;
+      get_parent_with_const_child (var1_copy, node1_with_const_child,
+				   parent_of_node1_with_child);
+
+      /* If both subtrees have constant bit nodes,
+	 we can merge them together.  */
+      if (node1_with_const_child != nullptr)
+	{
+	  value_bit *var1_reformed = nullptr;
+	  value_bit *var2_reformed = nullptr;
+
+	  /* If var1's const bit is in its left subtree.  */
+	  value_bit *var1_left = node1_with_const_child->get_left ();
+	  if (var1_left != nullptr && is_a<bit *> (var1_left))
+	    {
+	      var1_reformed = node1_with_const_child->get_right ()->copy ();
+	      value_bit *var2_left = node2_with_const_child->get_left ();
+
+	      /* If var2's const bit is in its left subtree.  */
+	      if (var2_left != nullptr && is_a<bit *> (var2_left))
+		var2_reformed = node2_with_const_child->get_right ()->copy ();
+	      else /* Var2's const bit is in its right subtree.  */
+		var2_reformed = node2_with_const_child->get_left ()->copy ();
+	    }
+	  else /* Var1's const bit is in its right subtree.  */
+	    {
+	      var1_reformed = node1_with_const_child->get_left ()->copy ();
+	      value_bit *var2_left = node2_with_const_child->get_left ();
+
+	      /* If var2's const bit is in its left subtree.  */
+	      if (var2_left != nullptr && is_a<bit *> (var2_left))
+		var2_reformed = node2_with_const_child->get_right ()->copy ();
+	      else /* Var2's const bit is in its right subtree.  */
+		var2_reformed = node2_with_const_child->get_left ()->copy ();
+	    }
+
+	  if (parent_of_node1_with_child)
+	    {
+	      parent_of_node1_with_child->get_left ()
+	      == node1_with_const_child
+	      ? parent_of_node1_with_child->set_left (var1_reformed)
+	      : parent_of_node1_with_child->set_right (var1_reformed);
+	      delete node1_with_const_child;
+	    }
+	  else
+	    {
+	      delete var1_copy;
+	      var1_copy = var1_reformed;
+	    }
+
+	  if (parent_of_node2_with_child)
+	    {
+	      parent_of_node2_with_child->get_left ()
+	      == node2_with_const_child
+	      ? parent_of_node2_with_child->set_left (var2_reformed)
+	      : parent_of_node2_with_child->set_right (var2_reformed);
+	      delete node2_with_const_child;
+	    }
+	  else
+	    {
+	      delete var2_copy;
+	      var2_copy = var2_reformed;
+	    }
+
+	  return new bit_xor_expression (var1_copy, var2_copy);
+	}
+      delete var1_copy;
+    }
+
+  delete var2_copy;
+  return new bit_xor_expression (var1->copy (), var2->copy ());
+}
+
+
+/* Performs XOR operation for 2 constant bit operands.  */
+
+bit *
+state::xor_const_bits (const bit *const_bit1, const bit *const_bit2)
+{
+  return new bit (const_bit1->get_val () ^ const_bit2->get_val ());
+}
+
+
+/* Performs XOR operation for a symbolic_bit and const_bit operands.  */
+
+value_bit *
+state::xor_var_const (const value_bit *var, const bit *const_bit)
+{
+  if (const_bit->get_val () == 0)
+    return var->copy ();
+
+  value_bit *var_copy = var->copy ();
+  bit_expression *node_with_const_child = nullptr;
+  bit_expression *tmp = nullptr;
+  get_parent_with_const_child (var_copy, node_with_const_child, tmp);
+
+  if (node_with_const_child != nullptr)
+    {
+      value_bit *left = node_with_const_child->get_left ();
+      if (left != nullptr && is_a<bit *> (left))
+	{
+	  bit *new_left = xor_const_bits (as_a<bit *> (left), const_bit);
+	  delete left;
+	  node_with_const_child->set_left (new_left);
+	}
+      else
+	{
+	  value_bit *right = node_with_const_child->get_right ();
+	  bit *new_right = xor_const_bits (as_a<bit *> (right), const_bit);
+	  delete right;
+	  node_with_const_child->set_right (new_right);
+	}
+      return var_copy;
+    }
+
+  delete var_copy;
+  return new bit_xor_expression (var->copy (), const_bit->copy ());
+}
+
+
+/* Return node which has a const bit child.  Traversal is done based
+   on safe branching.  */
+
+void
+state::get_parent_with_const_child (value_bit *root, bit_expression *&parent,
+				    bit_expression *&parent_of_parent)
+{
+  parent_of_parent = nullptr;
+  parent = nullptr;
+
+  if (!is_a<bit_expression *> (root))
+    return;
+
+  bit_expression *expr_root = as_a<bit_expression *> (root);
+  hash_set < bit_expression * > nodes_to_consider;
+  nodes_to_consider.add (expr_root);
+
+  hash_map < bit_expression * , bit_expression * > node_to_parent;
+  node_to_parent.put (expr_root, nullptr);
+
+  /* Traversing expression tree:
+     considering only comutative expression nodes.  */
+  while (!nodes_to_consider.is_empty ())
+    {
+      bit_expression *cur_element = *nodes_to_consider.begin ();
+      nodes_to_consider.remove (cur_element);
+
+      value_bit *left = cur_element->get_left ();
+      value_bit *right = cur_element->get_right ();
+
+      if ((left != nullptr && is_a<bit *> (left))
+	  || (right != nullptr && is_a<bit *> (right)))
+	{
+	  parent = cur_element;
+	  parent_of_parent = *node_to_parent.get (cur_element);
+	}
+
+      if (left != nullptr && is_a<bit_xor_expression *> (left))
+	{
+	  nodes_to_consider.add (as_a<bit_expression *> (left));
+	  node_to_parent.put (as_a<bit_expression *> (left), cur_element);
+	}
+
+      if (right != nullptr && is_a<bit_xor_expression *> (right))
+	{
+	  nodes_to_consider.add (as_a<bit_expression *> (right));
+	  node_to_parent.put (as_a<bit_expression *> (right), cur_element);
+	}
+    }
+}
+
+
+/* Shifts number left by size of shift_value.  */
+
+value *
+state::shift_left_by_const (const value *number, size_t shift_value)
+{
+  value *shift_result = new value (number->length (), number->is_unsigned);
+  if (number->length () <= shift_value)
+    for (size_t i = 0; i < number->length (); i++)
+      shift_result->push (new bit (0));
+
+  else
+    {
+      size_t i = 0;
+      for (; i < shift_value; ++i)
+	shift_result->push (new bit (0));
+      for (size_t j = 0; i < number->length (); ++i, j++)
+	shift_result->push (((*number)[j])->copy ());
+    }
+  return shift_result;
+}
+
+
+/* Shift_right operation.  Case: var2 is a symbolic value.  */
+
+value_bit *
+state::shift_right_sym_bits (value_bit *var1, value_bit *var2)
+{
+  return new shift_right_expression (var1->copy (), var2->copy ());
+}
+
+
+/* Adds two values, stores the result in the first one.  */
+
+void
+state::add_numbers (value *var1, const value *var2)
+{
+  value_bit *carry = new bit (0);
+  for (unsigned i = 0; i < var1->length (); i++)
+    {
+      value_bit *temp = (*var1)[i];
+      (*var1)[i] = full_adder ((*var1)[i], (*var2)[i], &carry);
+      delete temp;
+    }
+  delete carry;
+}
+
+
+/* ANDs every bit of the vector with var_bit, stroes the result in var1.  */
+
+void
+state::and_number_bit (value *var1, value_bit *var_bit)
+{
+  for (unsigned i = 0; i < var1->length (); i++)
+    {
+      value_bit *tmp = (*var1)[i];
+      (*var1)[i] = and_two_bits ((*var1)[i], var_bit);
+      delete tmp;
+    }
+
+}
+
+
+/* Multiplies two variables, stores result in dest.  */
+
+bool
+state::do_mul (tree arg1, tree arg2, tree dest)
+{
+  return do_binary_operation (arg1, arg2, dest, &state::do_mul);
+}
+
+
+void
+state::do_mul (value *arg1, value *arg2, tree dest)
+{
+  value *shifted = new value (*arg1);
+  value *dest_val = var_states.get (dest);
+
+  for (unsigned i = 0; i < dest_val->length (); i++)
+    {
+      delete (*dest_val)[i];
+      (*dest_val)[i] = new bit (0);
+    }
+
+  for (unsigned i = arg2->length (); i != 0; --i)
+    {
+      if (is_a<bit *> ((*arg2)[i - 1])
+	  && as_a<bit *> ((*arg2)[i - 1])->get_val () != 0)
+	add_numbers (dest_val, shifted);
+      else if (is_a<symbolic_bit *> ((*arg2)[i - 1]))
+	{
+	  and_number_bit (shifted, as_a<symbolic_bit *> ((*arg2)[i - 1]));
+	  add_numbers (dest_val, shifted);
+	}
+
+      value *temp = shifted;
+      shifted = shift_left_by_const (shifted, 1);
+      delete temp;
+    }
+  delete shifted;
+}
+
+
+/* Checks whether the given two constant values are equal.  */
+
+bool
+state::check_const_value_equality (value *arg1, value *arg2)
+{
+  for (size_t i = 0; i < arg1->length (); i++)
+    if (as_a<bit *> ((*arg1)[i])->get_val ()
+	!= as_a<bit *> ((*arg2)[i])->get_val ())
+      return false;
+  return true;
+}
+
+
+/* Adds EQUAL condition of given variables to state.  */
+
+bool
+state::add_equal_cond (tree arg1, tree arg2)
+{
+  return add_binary_cond (arg1, arg2, &state::add_equal_cond);
+}
+
+
+/* Adds equality condition for two values.  */
+
+void
+state::add_equal_cond (value *arg1, value *arg2)
+{
+
+  /* If both arguments are constants then we can evaluate it.  */
+  if (is_bit_vector (arg1) && is_bit_vector (arg2))
+    {
+      bool result = check_const_value_equality (arg1, arg2);
+      last_cond_status = result ? condition_status::CS_TRUE
+				: condition_status::CS_FALSE;
+      return;
+    }
+
+  /* When some of bits are constants and they differ by value,
+     then we can evalate it to be false.  */
+  for (size_t i = 0; i < arg1->length (); i++)
+    {
+      if (is_a<bit *> ((*arg1)[i]) && is_a<bit *> ((*arg2)[i])
+	  && as_a<bit *> ((*arg1)[i])->get_val ()
+	     != as_a<bit *> ((*arg2)[i])->get_val ())
+	{
+	  last_cond_status = condition_status::CS_FALSE;
+	  return;
+	}
+    }
+
+  for (size_t i = 0; i < arg1->length (); i++)
+    {
+      /* If there is a constant bit pair, then they are equal
+	 as we checked not equality above.  */
+      if (is_a<bit *> ((*arg1)[i]) && is_a<bit *> ((*arg2)[i]))
+	continue;
+
+      conditions.add (new bit_condition ((*arg1)[i]->copy (),
+					 (*arg2)[i]->copy (),
+					 EQ_EXPR));
+    }
+  last_cond_status = condition_status::CS_SYM;
+}
+
+
+/* Checks whether the given two constant values are not equal.  */
+
+bool
+state::check_const_value_are_not_equal (value *arg1, value *arg2)
+{
+  for (size_t i = 0; i < arg1->length (); i++)
+    if (as_a<bit *> ((*arg1)[i])->get_val ()
+	!= as_a<bit *> ((*arg2)[i])->get_val ())
+      return true;
+  return false;
+}
+
+
+/* Adds NOT EQUAL condition of given variables to state.  */
+
+bool
+state::add_not_equal_cond (tree arg1, tree arg2)
+{
+  return add_binary_cond (arg1, arg2, &state::add_not_equal_cond);
+}
+
+
+/* Adds not equal condition for two values.  */
+
+void
+state::add_not_equal_cond (value *arg1, value *arg2)
+{
+  if (is_bit_vector (arg1) && is_bit_vector (arg2))
+    {
+      bool result = check_const_value_are_not_equal (arg1, arg2);
+      last_cond_status = result ? condition_status::CS_TRUE
+				: condition_status::CS_FALSE;
+      return;
+    }
+
+  /* When some of bits are constants and they differ by value,
+     then we can evalate it to be true.  */
+  for (size_t i = 0; i < arg1->length (); i++)
+    {
+      if (is_a<bit *> ((*arg1)[i]) && is_a<bit *> ((*arg2)[i])
+	  && as_a<bit *> ((*arg1)[i])->get_val ()
+	     != as_a<bit *> ((*arg2)[i])->get_val ())
+	{
+	  last_cond_status = condition_status::CS_TRUE;
+	  return;
+	}
+    }
+
+  bit_expression *prev = nullptr;
+  for (size_t i = 0; i < arg1->length (); i++)
+    {
+      /* If there is a constant bit pair, then they are equal
+	 as we checked not equality above.  */
+      if (is_a<bit *> ((*arg1)[i]) && is_a<bit *> ((*arg2)[i]))
+	continue;
+
+      bit_condition *new_cond = new bit_condition ((*arg1)[i]->copy (),
+						   (*arg2)[i]->copy (),
+						   NE_EXPR);
+      if (prev)
+	prev = new bit_or_expression (prev, new_cond);
+      else
+	prev = new_cond;
+    }
+
+  last_cond_status = condition_status::CS_SYM;
+  conditions.add (prev);
+}
+
+
+/* Checks whether the first given constant value
+   is greater than the second one.  */
+
+bool
+state::check_const_value_is_greater_than (value *arg1, value *arg2)
+{
+  for (int i = arg1->length () - 1; i >= 0; i--)
+    {
+      if (as_a<bit *> ((*arg1)[i])->get_val ()
+	  > as_a<bit *> ((*arg2)[i])->get_val ())
+	return true;
+      else if (as_a<bit *> ((*arg1)[i])->get_val ()
+	       < as_a<bit *> ((*arg2)[i])->get_val ())
+	return false;
+    }
+  return false;
+}
+
+
+/* Adds GREATER THAN condition of given variables to state.  */
+
+bool
+state::add_greater_than_cond (tree arg1, tree arg2)
+{
+  return add_binary_cond (arg1, arg2, &state::add_greater_than_cond);
+}
+
+
+/* Adds greater than condition for two values.  */
+
+void
+state::add_greater_than_cond (value *arg1, value *arg2)
+{
+  if (is_bit_vector (arg1) && is_bit_vector (arg2))
+    {
+      bool result = check_const_value_is_greater_than (arg1, arg2);
+      last_cond_status = result ? condition_status::CS_TRUE
+				: condition_status::CS_FALSE;
+      return;
+    }
+
+  if (is_bit_vector (arg2) && is_a<bit *> (arg1->last ())
+      && make_number (arg2) == 0 && !arg1->is_unsigned)
+    {
+      if (as_a<bit *> (arg1->last ())->get_val () == 1)
+	last_cond_status = condition_status::CS_FALSE;
+      else
+	{
+	  for (size_t i = 0; i < arg1->length (); i++)
+	    if (is_a<bit *> ((*arg1)[i])
+		&& as_a<bit *> ((*arg1)[i])->get_val ())
+	      {
+		last_cond_status = condition_status::CS_TRUE;
+		return;
+	      }
+	}
+    }
+
+  bit_expression *gt_cond = construct_great_than_cond (arg1, arg2);
+  if (gt_cond)
+    {
+      /* Otherwise its status is already set.  */
+      last_cond_status = condition_status::CS_SYM;
+      conditions.add (gt_cond);
+    }
+}
+
+
+/* Constructs expression trees of greater than condition for given values.  */
+
+bit_expression *
+state::construct_great_than_cond (value *arg1, value *arg2)
+{
+  bit_expression *prev = nullptr;
+  int i = arg1->length () - 1;
+  for (; i >= 0; i--)
+    {
+      if (is_a<bit *> ((*arg1)[i]) && is_a<bit *> ((*arg2)[i]))
+	{
+	  if (as_a<bit *> ((*arg1)[i])->get_val ()
+	      > as_a<bit *> ((*arg2)[i])->get_val ())
+	    {
+	      if (!prev)
+		last_cond_status = condition_status::CS_TRUE;
+	      return prev;
+	    }
+	  else if (as_a<bit *> ((*arg1)[i])->get_val ()
+		   < as_a<bit *> ((*arg2)[i])->get_val ())
+	    {
+	      if (prev)
+		{
+		  bit_expression *ret_val
+		    = as_a<bit_expression *> (prev->get_left ()->copy ());
+		  delete prev;
+		  return ret_val;
+		}
+	      else
+		{
+		  last_cond_status = condition_status::CS_FALSE;
+		  return nullptr;
+		}
+	    }
+	}
+      else
+	{
+	  bit_condition *gt_cond
+	    = new bit_condition ((*arg1)[i]->copy (), (*arg2)[i]->copy (),
+				 GT_EXPR);
+	  bit_expression *expr = nullptr;
+	  if (i)
+	    {
+	      bit_condition *eq_cond
+		= new bit_condition ((*arg1)[i]->copy (), (*arg2)[i]->copy (),
+				     EQ_EXPR);
+	      expr = new bit_or_expression (gt_cond, eq_cond);
+	    }
+	  else
+	    expr = gt_cond;
+
+	  if (prev)
+	    prev = new bit_and_expression (expr, prev);
+	  else
+	    prev = expr;
+	}
+    }
+
+  return prev;
+}
+
+
+/* Checks whether the first given constant value
+   is less than the second one.  */
+
+bool
+state::check_const_value_is_less_than (value *arg1, value *arg2)
+{
+  for (int i = arg1->length () - 1; i >= 0; i--)
+    {
+      if (as_a<bit *> ((*arg1)[i])->get_val ()
+	  < as_a<bit *> ((*arg2)[i])->get_val ())
+	return true;
+      else if (as_a<bit *> ((*arg1)[i])->get_val ()
+	       > as_a<bit *> ((*arg2)[i])->get_val ())
+	return false;
+    }
+  return false;
+}
+
+
+/* Adds LESS THAN condition of given variables to state.  */
+
+bool
+state::add_less_than_cond (tree arg1, tree arg2)
+{
+  return add_binary_cond (arg1, arg2, &state::add_less_than_cond);
+}
+
+
+/* Adds less than condition for two values.  */
+
+void
+state::add_less_than_cond (value *arg1, value *arg2)
+{
+  if (is_bit_vector (arg1) && is_bit_vector (arg2)
+      && (make_number (arg2) != 0 || arg1->is_unsigned))
+    {
+      bool result = check_const_value_is_less_than (arg1, arg2);
+      last_cond_status = result ? condition_status::CS_TRUE
+				: condition_status::CS_FALSE;
+      return;
+    }
+
+  last_cond_status = condition_status::CS_SYM;
+  if (is_bit_vector (arg2) && make_number (arg2) == 0 && !arg1->is_unsigned)
+    {
+      if (is_a<bit *> (arg1->last ()))
+	{
+	  if (as_a<bit *> (arg1->last ())->get_val () == 1)
+	    last_cond_status = condition_status::CS_TRUE;
+	  else
+	    last_cond_status = condition_status::CS_FALSE;
+	}
+      else
+	conditions.add (new bit_condition (arg1->last ()->copy (), new bit (1),
+					   EQ_EXPR));
+
+      return;
+    }
+
+  bit_expression *lt_cond = construct_less_than_cond (arg1, arg2);
+  if (lt_cond)
+    /* Otherwise its status is already set.  */
+    conditions.add (lt_cond);
+}
+
+
+/* Constructs expression trees of less than condition for given values.  */
+
+bit_expression *
+state::construct_less_than_cond (value *arg1, value *arg2)
+{
+  bit_expression *prev = nullptr;
+  int i = arg1->length () - 1;
+  for (; i >= 0; i--)
+    {
+      if (is_a<bit *> ((*arg1)[i]) && is_a<bit *> ((*arg2)[i]))
+	{
+	  if (as_a<bit *> ((*arg1)[i])->get_val ()
+	      < as_a<bit *> ((*arg2)[i])->get_val ())
+	    {
+	      if (!prev)
+		last_cond_status = condition_status::CS_TRUE;
+	      return prev;
+	    }
+	  else if (as_a<bit *> ((*arg1)[i])->get_val ()
+		   > as_a<bit *> ((*arg2)[i])->get_val ())
+	    {
+	      if (prev)
+		{
+		  bit_expression *ret_val
+		    = as_a<bit_expression *> (prev->get_left ()->copy ());
+		  delete prev;
+		  return ret_val;
+		}
+	      else
+		{
+		  last_cond_status = condition_status::CS_FALSE;
+		  return nullptr;
+		}
+	    }
+	}
+      else
+	{
+	  bit_condition *lt_cond
+	    = new bit_condition ((*arg1)[i]->copy (), (*arg2)[i]->copy (),
+				 LT_EXPR);
+	  bit_expression *expr = nullptr;
+	  if (i)
+	    {
+	      bit_condition *eq_cond
+		= new bit_condition ((*arg1)[i]->copy (), (*arg2)[i]->copy (),
+				     EQ_EXPR);
+	      expr = new bit_or_expression (lt_cond, eq_cond);
+	    }
+	  else
+	    expr = lt_cond;
+
+	  if (prev)
+	    prev = new bit_and_expression (expr, prev);
+	  else
+	    prev = expr;
+	}
+    }
+
+  return prev;
+}
+
+
+/* Adds GREATER OR EQUAL condition of given variables to state.  */
+
+bool
+state::add_greater_or_equal_cond (tree arg1, tree arg2)
+{
+  return add_binary_cond (arg1, arg2, &state::add_greater_or_equal_cond);
+}
+
+
+/* Adds greater or equal condition for two values.  */
+
+void
+state::add_greater_or_equal_cond (value *arg1, value *arg2)
+{
+  if (is_bit_vector (arg1) && is_bit_vector (arg2)
+      && (make_number (arg2) != 0 || arg1->is_unsigned))
+    {
+      bool is_greater_than = check_const_value_is_greater_than (arg1,
+								arg2);
+      bool is_equal = check_const_value_equality (arg1, arg2);
+      last_cond_status = (is_greater_than | is_equal)
+			 ? condition_status::CS_TRUE
+			 : condition_status::CS_FALSE;
+      return;
+    }
+
+  last_cond_status = condition_status::CS_SYM;
+  if (is_bit_vector (arg2) && make_number (arg2) == 0 && !arg1->is_unsigned)
+    {
+      if (is_a<bit *> (arg1->last ()))
+	{
+	  if (as_a<bit *> (arg1->last ())->get_val () == 1)
+	    last_cond_status = condition_status::CS_FALSE;
+	  else
+	    last_cond_status = condition_status::CS_TRUE;
+	}
+      else
+	conditions.add (new bit_condition (arg1->last ()->copy (), new bit (0),
+					   EQ_EXPR));
+
+      return;
+    }
+
+  bit_expression *eq_cond = construct_equal_cond (arg1, arg2);
+  if (!eq_cond)
+    return;
+
+  bit_expression *gt_cond = construct_great_than_cond (arg1, arg2);
+  if (gt_cond)
+    /* Otherwise its status is already set.  */
+    conditions.add (new bit_or_expression (eq_cond, gt_cond));
+}
+
+
+/* Adds LESS OR EQUAL condition of given variables to state.  */
+
+bool
+state::add_less_or_equal_cond (tree arg1, tree arg2)
+{
+  return add_binary_cond (arg1, arg2, &state::add_less_or_equal_cond);
+}
+
+
+/* Adds less or equal condition for two values.  */
+
+void
+state::add_less_or_equal_cond (value *arg1, value *arg2)
+{
+  if (is_bit_vector (arg1) && is_bit_vector (arg2))
+    {
+      bool is_less_than = check_const_value_is_less_than (arg1, arg2);
+      bool is_equal = check_const_value_equality (arg1, arg2);
+      last_cond_status = (is_less_than | is_equal)
+			 ? condition_status::CS_TRUE
+			 : condition_status::CS_FALSE;
+      return;
+    }
+
+  last_cond_status = condition_status::CS_SYM;
+  bit_expression *eq_cond = construct_equal_cond (arg1, arg2);
+  if (!eq_cond)
+    return;
+
+  bit_expression *lt_cond = construct_less_than_cond (arg1, arg2);
+  if (lt_cond)
+    /* Otherwise its status is already set.  */
+    conditions.add (new bit_or_expression (eq_cond, lt_cond));
+}
+
+
+/* Adds a bool condition to state.  */
+
+bool
+state::add_bool_cond (tree arg)
+{
+  if (!is_declared (arg))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Sym-Exec: Argument must be declared "
+			    "for bool condition.\n");
+
+      return false;
+    }
+
+  value *arg_bits = var_states.get (arg);
+  for (size_t i = 0; i < arg_bits->length (); i++)
+    if (is_a<bit *> ((*arg_bits)[i])
+	&& as_a<bit *> ((*arg_bits)[i])->get_val () != 0)
+      {
+	last_cond_status = condition_status::CS_TRUE;
+	print_conditions ();
+	return true;
+      }
+
+  if (is_bit_vector (arg_bits))
+    {
+      last_cond_status = condition_status::CS_FALSE;
+      print_conditions ();
+      return true;
+    }
+
+  bit_expression *prev = nullptr;
+  for (size_t i = 0; i < arg_bits->length (); i++)
+    {
+      if (is_a<bit *> ((*arg_bits)[i]))
+	continue;
+
+      bit_condition *not_eq_cond
+	= new bit_condition ((*arg_bits)[i], new bit (0), NE_EXPR);
+      if (prev)
+	prev = new bit_or_expression (not_eq_cond, prev);
+      else
+	prev = not_eq_cond;
+    }
+
+  last_cond_status = condition_status::CS_SYM;
+  conditions.add (prev);
+  print_conditions ();
+  return true;
+}
+
+
+/* Does preprocessing and postprocessing for condition adding.
+   Handles value creation for constants and their removement in the end.  */
+
+bool
+state::add_binary_cond (tree arg1, tree arg2, binary_cond_func cond_func)
+{
+  bool arg1_is_declared = is_declared (arg1);
+  bool arg2_is_declared = is_declared (arg2);
+
+  if (!arg1_is_declared && !arg2_is_declared)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Sym-Exec: At least one of arguments must be"
+			    " declared for adding the condition.\n");
+
+      return false;
+    }
+
+  if (arg1_is_declared)
+    declare_if_needed (arg2, var_states.get (arg1)->length ());
+
+  if (arg2_is_declared)
+    declare_if_needed (arg1, var_states.get (arg2)->length ());
+
+  value *arg1_val = var_states.get (arg1);
+  value arg1_const_val (MAX_VALUE_SIZE, false);
+
+  if (arg1_val == NULL && TREE_CODE (arg1) == INTEGER_CST)
+    {
+      arg1_const_val = create_val_for_const (arg1,
+					     var_states.get (arg2)->length ());
+      arg1_val = &arg1_const_val;
+    }
+
+  value *arg2_val = var_states.get (arg2);
+  value arg2_const_val (MAX_VALUE_SIZE, false);
+  if (arg2_val == NULL && TREE_CODE (arg2) == INTEGER_CST)
+    {
+      arg2_const_val = create_val_for_const (arg2,
+					     var_states.get (arg1)->length ());
+      arg2_val = &arg2_const_val;
+    }
+
+  (this->*cond_func) (arg1_val, arg2_val);
+  print_conditions ();
+  return true;
+}
+
+
+/* Constructs expression trees of equal condition for given values.  */
+
+bit_expression *
+state::construct_equal_cond (value *arg1, value *arg2)
+{
+  /* If both arguments are constants then we can evaluate it.  */
+  if (is_bit_vector (arg1) && is_bit_vector (arg2))
+    {
+      bool result = check_const_value_equality (arg1, arg2);
+      last_cond_status = result ? condition_status::CS_TRUE
+				: condition_status::CS_FALSE;
+      return nullptr;
+    }
+
+  /* When some bits are constants, and they differ by value,
+     then we can evaluate it to be false.  */
+  for (size_t i = 0; i < arg1->length (); i++)
+    {
+      if (is_a<bit *> ((*arg1)[i]) && is_a<bit *> ((*arg2)[i])
+	  && as_a<bit *> ((*arg1)[i])->get_val ()
+	     != as_a<bit *> ((*arg2)[i])->get_val ())
+	{
+	  last_cond_status = condition_status::CS_FALSE;
+	  return nullptr;
+	}
+    }
+
+  bit_expression *prev = nullptr;
+  for (size_t i = 0; i < arg1->length (); i++)
+    {
+      bit_condition *eq_expr = new bit_condition ((*arg1)[i]->copy (),
+						  (*arg2)[i]->copy (), EQ_EXPR);
+      if (prev)
+	prev = new bit_and_expression (eq_expr, prev);
+      else
+	prev = eq_expr;
+    }
+
+  return prev;
+}
+
+
+/* Gets the value of *arg1 and stores it in dest.  */
+
+bool
+state::do_mem_ref (tree arg1, tree dest)
+{
+  declare_if_needed (dest, tree_to_uhwi (TYPE_SIZE (TREE_TYPE (dest))));
+  if (!is_declared (arg1))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Sym-Exec: For memory reference"
+			    " argument must be declared\n");
+
+      return false;
+    }
+
+  for (unsigned i = 0; i < get_var_size (dest); i++)
+    {
+      delete (*var_states.get (dest))[i];
+      // TODO: Find a better way.
+      (*var_states.get (dest))[i] = new symbolic_bit (i, arg1);
+    }
+
+  print_value (var_states.get (dest));
+  return true;
+}
+
+
+/* Performs addition on arg1 pointer.  */
+
+bool
+state::do_pointer_plus (tree arg1, tree arg2, tree dest)
+{
+  //TODO: For pointer addition we need to consider size of argument
+  return do_add (arg1, arg2, dest);
+}
+
+
+/* Perform subtractions on arg1 pointer.  */
+
+bool
+state::do_pointer_diff (tree arg1, tree arg2, tree dest)
+{
+  //TODO: For pointer subtraction we need to consider size of argument
+  return do_sub (arg1, arg2, dest);
+}
+
+
+value::value (unsigned size, bool is_unsigned) : is_unsigned (is_unsigned)
+{
+  number.create (size);
+}
+
+
+value::value (const value &other) : is_unsigned (other.is_unsigned)
+{
+  number.create (other.length ());
+  for (size_t i = 0; i < other.length (); ++i)
+    {
+      value_bit *temp = other[i] ? other[i]->copy () : other[i];
+      number.quick_push (temp);
+    }
+}
+
+
+size_t
+value::length () const
+{
+  return number.length ();
+}
+
+
+value_bit *&
+value::operator[] (unsigned i)
+{
+  return number[i];
+}
+
+
+value &
+value::operator= (const value &other)
+{
+  unsigned smallest = number.allocated () < other.length ()
+		      ? number.allocated () : other.length ();
+
+  for (size_t i = 0; i < smallest; i++)
+    if (i < number.length ())
+      {
+	delete number[i];
+	number[i] = other[i]->copy ();
+      }
+    else
+      number.quick_push (other[i]->copy ());
+
+  for (size_t i = smallest; i < number.allocated (); i++)
+    if (i < number.length ())
+      {
+	delete number[i];
+	number[i] = other.is_unsigned ? new bit (0)
+				      : other[other.length () - 1]->copy ();
+      }
+    else
+      number.quick_push (other.is_unsigned
+			 ? new bit (0) : other[other.length () - 1]->copy ());
+
+  return (*this);
+}
+
+
+value_bit *
+value::operator[] (unsigned i) const
+{
+  return number[i];
+}
+
+
+bool
+value::exists () const
+{
+  return number.exists ();
+}
+
+
+unsigned
+value::allocated () const
+{
+  return number.allocated ();
+}
+
+
+value_bit *&
+value::last ()
+{
+  return number.last ();
+}
+
+
+/* Make a copy of given bits.  */
+
+vec<value_bit *> *
+state::make_copy (vec<value_bit *> *bits)
+{
+  vec < value_bit * > *copied_bits = new vec<value_bit *> ();
+  copied_bits->create (bits->length ());
+  for (size_t i = 0; i < bits->length (); i++)
+    copied_bits->quick_push ((*bits)[i]->copy ());
+
+  return copied_bits;
+}
+
+
+/* Returns status of last added condition.  */
+
+condition_status
+state::get_last_cond_status ()
+{
+  return last_cond_status;
+}
+
+
+/* Prints the given value.  */
+
+void
+state::print_value (value *var)
+{
+  if (!dump_file || !(dump_flags & TDF_DETAILS))
+    return;
+
+  fprintf (dump_file, "{");
+  for (int i = var->length () - 1; i >= 0; i--)
+    {
+      (*var)[i]->print ();
+
+      if (i)
+	fprintf (dump_file, ", ");
+    }
+  fprintf (dump_file, "}\n");
+}
+
+
+/* Casts arg to cast_size size, stores value in dest.  */
+
+bool
+state::do_cast (tree var, tree dest, size_t cast_size)
+{
+  declare_if_needed (dest, tree_to_uhwi (TYPE_SIZE (TREE_TYPE (dest))));
+  if (!is_declared (var))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Sym-Exec: For cast operantion "
+			    "argument must be declared\n");
+
+      return false;
+    }
+
+  value *arg = var_states.get (var);
+  value *dest_val = var_states.get (dest);
+
+  size_t arg_size = min (arg->length (), dest_val->length (), cast_size);
+
+  for (size_t i = 0; i < arg_size; i++)
+    {
+      value_bit *temp = (*dest_val)[i];
+      (*dest_val)[i] = (*arg)[i]->copy ();
+      delete temp;
+    }
+
+  value_bit *sign_bit = arg->is_unsigned
+			? new bit (0) : arg->last ()->copy ();
+  for (size_t i = arg_size; i < dest_val->length (); i++)
+    {
+      value_bit *temp = (*dest_val)[i];
+      (*dest_val)[i] = sign_bit->copy ();
+      delete temp;
+    }
+  delete sign_bit;
+  return true;
+}
+
+/* Create LFSR value for the reversed CRC.  */
+
+void
+state::create_reversed_lfsr (value &lfsr, const value &crc,
+			     const value &polynomial)
+{
+  size_t size = polynomial.length ();
+
+  /* Determine values of all bits, except MSB.  */
+  for (size_t i = 0; i < size - 1; i++)
+    {
+      if (as_a<bit *> (polynomial[i])->get_val ())
+	lfsr.push (state::xor_two_bits (crc[i + 1], crc[0]));
+      else
+	lfsr.push (crc[i + 1]->copy ());
+    }
+
+  /* Determine value of MSB.  */
+  if (as_a<bit *> (polynomial[size - 1])->get_val ())
+    lfsr.push (crc[0]->copy ());
+  else
+    lfsr.push (new bit (0));
+}
+
+
+/* Create LFSR value for the forward CRC.  */
+
+void
+state::create_forward_lfsr (value &lfsr, const value &crc,
+			    const value &polynomial)
+{
+  size_t size = polynomial.length ();
+  /* Determine value of LSB.  */
+  if (as_a<bit *> (polynomial[0])->get_val ())
+    lfsr.push (crc[size - 1]->copy ());
+  else
+    lfsr.push (new bit (0));
+
+  /* Determine values of remaining bits.  */
+  for (size_t i = 1; i < size; i++)
+    {
+      if (as_a<bit *> (polynomial[i])->get_val ())
+	lfsr.push (state::xor_two_bits (crc[i - 1], crc[size - 1]));
+      else
+	lfsr.push (crc[i - 1]->copy ());
+    }
+}
+
+
+/* Get the last 1 bit index.  */
+
+size_t
+last_set_bit (const value &polynomial)
+{
+  for (size_t i = 0; i < polynomial.length (); ++i)
+    {
+      if (as_a<bit *> (polynomial[polynomial.length () - i - 1])->get_val ())
+	return polynomial.length () - i - 1;
+    }
+  return 0;
+}
+
+
+/* Create LFSR value.  */
+
+value *
+state::create_lfsr (tree crc, value *polynomial, bool is_bit_forward)
+{
+  /* Check size compatibility․  */
+  unsigned HOST_WIDE_INT polynomial_length = polynomial->length ();
+  unsigned HOST_WIDE_INT crc_size = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (crc)));
+  if (crc_size < polynomial_length)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "LFSR state creation: "
+			    "Polynomial doesn't fit into the crc.\n");
+
+      return nullptr;
+    }
+
+  /* Get the minimal byte size to keep the polynomial.
+ Ie, if the last 1 bit of the polynomial is at 6 index, size will be 8.  */
+  size_t required_polynomial_size = ((last_set_bit (*polynomial)/8) + 1) * 8;
+
+  /* Polynomial's length actually equals to the CRC variable's size.
+ Now we detect only those CRC calculation algorithms, where leading 1 of the
+ polynomial isn't kept.  */
+  if (required_polynomial_size == 0
+      || required_polynomial_size != polynomial_length)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Polynomial's all bits are zeros "
+			    "or the size of the polynomial is uncertain.\n");
+      return nullptr;
+    }
+
+  /* Create vector of symbolic bits for crc.  */
+  value crc_value (polynomial_length, TYPE_UNSIGNED (TREE_TYPE (crc)));
+
+  for (unsigned HOST_WIDE_INT i = 0; i < polynomial_length; i++)
+  crc_value.push (new symbolic_bit (i, crc));
+
+  /* create LFSR vector.  */
+  value *lfsr = new value (polynomial_length, TYPE_UNSIGNED (TREE_TYPE (crc)));
+
+  /* Calculate values for LFSR.  */
+  if (is_bit_forward)
+    create_forward_lfsr (*lfsr, crc_value, *polynomial);
+  else
+    create_reversed_lfsr (*lfsr, crc_value, *polynomial);
+
+  return lfsr;
+}
+
+
+/* Prints added conditions.  */
+
+void
+state::print_conditions ()
+{
+  if (!dump_file || !(dump_flags & TDF_DETAILS))
+    return;
+
+  fprintf (dump_file, "Conditions {");
+  auto iter = conditions.begin ();
+  while (true)
+    {
+      if (iter != conditions.end ())
+	{
+	  (*iter)->print ();
+	  ++iter;
+	}
+
+      if (iter != conditions.end ())
+	fprintf (dump_file, ", ");
+      else
+	break;
+    }
+  fprintf (dump_file, "}\n");
+}
+
+
+value_bit **
+value::push (value_bit *elem)
+{
+  return number.quick_push (elem);
+}
+
+
+value::~value ()
+{
+  free_bits ();
+  number.release ();
+}
+
+
+/* Removes given sequence of bits.  */
+
+void
+value::free_bits ()
+{
+  if (!number.exists ())
+    return;
+
+  for (size_t i = 0; i < number.length (); i++)
+    {
+      delete number[i];
+      number[i] = nullptr;
+    }
+}
+
+
+value_bit *
+state::complement_bits_with_origin (value_bit *root, tree origin)
+{
+  /* Be careful.  This function doesn't make a full copy of the bit.  */
+  if (!is_a<bit_expression *> (root))
+    {
+      if (is_a<symbolic_bit *> (root)
+	  && as_a<symbolic_bit *> (root)->get_origin () == origin)
+	root = new bit_complement_expression (root);
+
+      return root;
+    }
+
+  bit_expression *expr_root = as_a<bit_expression *> (root);
+  hash_set <value_bit *> nodes_to_consider;
+  nodes_to_consider.add (expr_root);
+  hash_map <value_bit *, value_bit *> node_to_parent;
+  node_to_parent.put (expr_root, nullptr);
+
+  /* Traversing expression tree.  */
+  while (!nodes_to_consider.is_empty ())
+    {
+      value_bit *cur_element = *nodes_to_consider.begin ();
+      nodes_to_consider.remove (cur_element);
+
+      if (is_a<symbolic_bit *> (cur_element))
+	{
+	  if (as_a<symbolic_bit *> (cur_element)->get_origin () != origin)
+	    continue;
+
+	  bit_expression *parent
+	  = as_a<bit_expression *> (*node_to_parent.get (cur_element));
+	  if (is_a<bit_complement_expression *> (parent))
+	    {
+	      value_bit *parent_of_parent = *node_to_parent.get (parent);
+	      if (parent_of_parent)
+		{
+		  bit_expression *parent_of_parent_expr
+		  = as_a<bit_expression *> (parent_of_parent);
+		  parent->set_right (nullptr);
+		  delete parent;
+		  parent_of_parent_expr->get_left () == parent
+		    ? parent_of_parent_expr->set_left (cur_element)
+		    : parent_of_parent_expr->set_right (cur_element);
+		}
+	      else
+		{
+		  /* Parent is our root.  */
+		  as_a<bit_expression *> (root)->set_right (nullptr);
+		  delete root;
+		  root = cur_element;
+		}
+	    }
+	  else
+	    {
+	      value_bit* new_bit = new bit_complement_expression (cur_element);
+	      parent->get_left () == cur_element ? parent->set_left (new_bit)
+						 : parent->set_right (new_bit);
+	    }
+	  continue;
+	}
+
+      bit_expression* cur_elem_expr = as_a<bit_expression *> (cur_element);
+      value_bit *left = cur_elem_expr->get_left ();
+      value_bit *right = cur_elem_expr->get_right ();
+      if (left != nullptr && !is_a<bit *> (left))
+	{
+	  nodes_to_consider.add (left);
+	  node_to_parent.put (left, cur_element);
+	}
+
+      if (right != nullptr && !is_a<bit *> (right))
+	{
+	  nodes_to_consider.add (right);
+	  node_to_parent.put (right, cur_element);
+	}
+    }
+
+  return root;
+}
+
+
+void
+state::complement_val_bits_with_origin (value *val, tree origin)
+{
+  for (size_t i = 0; i < val->length (); i++)
+    {
+      (*val)[i] = complement_bits_with_origin ((*val)[i], origin);
+    }
+}
+
+
+void
+state::complement_all_vars_bits_with_origin (tree origin)
+{
+  for (auto iter = var_states.begin (); iter != var_states.end (); ++iter)
+    {
+      complement_val_bits_with_origin (&(*iter).second, origin);
+    }
+}
+
+
+void
+state::complement_conditions_with_origin (tree origin)
+{
+  hash_set<bit_expression *> updated_conditions;
+  for (auto iter = conditions.begin (); iter != conditions.end (); ++iter)
+    updated_conditions.add (as_a<bit_expression *> (
+      complement_bits_with_origin (*iter, origin)));
+
+  conditions.empty ();
+  for (auto iter = updated_conditions.begin ();
+       iter != updated_conditions.end (); ++iter)
+    conditions.add (*iter);
+}
+
+
+void
+state::complement_state_with_origin (tree origin)
+{
+  complement_all_vars_bits_with_origin (origin);
+  complement_conditions_with_origin (origin);
+}
\ No newline at end of file
diff --git a/gcc/sym-exec/state.h b/gcc/sym-exec/state.h
new file mode 100644
index 00000000000..b20c8deab2f
--- /dev/null
+++ b/gcc/sym-exec/state.h
@@ -0,0 +1,453 @@
+/* State will store states of variables for a function's single execution path.
+   It will be used for bit-level symbolic execution to determine values of bits
+   of function's return value and symbolic marked arguments.  */
+
+
+#ifndef SYM_EXEC_STATE_H
+#define SYM_EXEC_STATE_H
+
+#define MAX_VALUE_SIZE 64
+
+#include "expression-is-a-helper.h"
+
+struct value {
+ private:
+  vec<value_bit *> number;
+
+ public:
+  const bool is_unsigned;
+
+  value (unsigned size, bool is_unsigned);
+  value (const value &other);
+  value_bit **push (value_bit *elem);
+  size_t length () const;
+  value_bit *&last ();
+  unsigned allocated () const;
+  bool exists () const;
+  value_bit *&operator[] (unsigned i);
+  value &operator= (const value &other);
+  value_bit *operator[] (unsigned i) const;
+  ~value ();
+
+  /* Removes given sequence of bits.  */
+  void free_bits ();
+};
+
+/* Stores states of variables' values on bit-level.  */
+
+class state {
+  typedef void (state::*binary_func) (value *arg1, value *arg2, tree dest);
+  typedef value_bit *(*bit_func) (value_bit *bit1, value_bit *bit2);
+  typedef value_bit *(*bit_func3) (value_bit *var1, value_bit *var2,
+				   value_bit **var3);
+  typedef void (state::*binary_cond_func) (value *arg1, value *arg2);
+
+ private:
+
+  /* Here is stored values by bits of each variable.  */
+  hash_map<tree, value> var_states;
+
+  /* Here is stored conditions of symbolic bits.  */
+  hash_set<bit_expression *> conditions;
+
+  /* The result of last added condition.  */
+  condition_status last_cond_status = condition_status::CS_NO_COND;
+
+  /* Creates value for given constant tree.  */
+  static value create_val_for_const (tree var, size_t size);
+
+  /* Checks if sizes of arguments and destination are compatible.  */
+  bool check_args_compatibility (tree arg1, tree arg2, tree dest);
+
+  /* Adds equality condition for two values.  */
+  void add_equal_cond (value *arg1, value *arg2);
+
+  /* Adds not equal condition for two values.  */
+  void add_not_equal_cond (value *arg1, value *arg2);
+
+  /* Adds greater than condition for two values.  */
+  void add_greater_than_cond (value *arg1, value *arg2);
+
+  /* Adds less than condition for two values.  */
+  void add_less_than_cond (value *arg1, value *arg2);
+
+  /* Adds greater or equal condition for two values.  */
+  void add_greater_or_equal_cond (value *arg1, value *arg2);
+
+  /* Adds less or equal condition for two values.  */
+  void add_less_or_equal_cond (value *arg1, value *arg2);
+
+  /* Does preprocessing and postprocessing for condition adding.
+     Handles value creation for constants and their removement in the end.  */
+  bool add_binary_cond (tree arg1, tree arg2, binary_cond_func cond_func);
+
+  /* Constructs expression trees of greater than condition for given values.  */
+  bit_expression *construct_great_than_cond (value *arg1, value *arg2);
+
+  /* Constructs expression trees of less than condition for given values.  */
+  bit_expression *construct_less_than_cond (value *arg1, value *arg2);
+
+  /* Constructs expression trees of equal condition for given values.  */
+  bit_expression *construct_equal_cond (value *arg1, value *arg2);
+
+  /* A wrapper for operations on two bits.
+     Operation and operands are passed as arguments.  */
+  static value_bit *operate_bits (bit_func bit_op, value_bit *bit1,
+				  value_bit *bit2, value_bit **bit3);
+
+  /* A wrapper for operations on three bits.
+     Operation and operands are passed as arguments.  */
+  static value_bit *operate_bits (bit_func3 bit_op, value_bit *bit1,
+				  value_bit *bit2, value_bit **bit3);
+
+  /* Performs the given operation on passed arguments.
+     The result is stored in dest.  */
+  template<class func>
+  void operate (value *arg1, value *arg2, value_bit **bit_arg, tree dest,
+		func bit_op);
+
+  /* Does preprocessing and postprocessing for expressions with tree operands.
+     Handles value creation for constant and their removement in the end.  */
+  bool do_binary_operation (tree arg1, tree arg2, tree dest,
+			    binary_func bin_func);
+
+  /* Performs AND operation on given values.  The result is stored in dest.  */
+  void do_and (value *arg1, value *arg2, tree dest);
+
+  /* Performs OR operation on given values.  The result is stored in dest.  */
+  void do_or (value *arg1, value *arg2, tree dest);
+
+  /* Performs XOR operation on given values.  The result is stored in dest.  */
+  void do_xor (value *arg1, value *arg2, tree dest);
+
+  /* Performs shift right operation on given values.
+     The result is stored in dest.  */
+  void do_shift_right (value *arg1, value *arg2, tree dest);
+
+  /* Performs shift left operation on given values.
+     The result is stored in dest.  */
+  void do_shift_left (value *arg1, value *arg2, tree dest);
+
+  /* Adds given values.  The result is stored in dest.  */
+  void do_add (value *arg1, value *arg2, tree dest);
+
+  /* Subtracks second value from the first.  The result is stored in dest.  */
+  void do_sub (value *arg1, value *arg2, tree dest);
+
+  /* Casts arg to cast_size size, stores value in dest.  */
+  bool do_cast (tree arg, tree dest, size_t cast_size);
+
+  /* Performs AND operation on two bits.  */
+  static value_bit *and_two_bits (value_bit *arg1, value_bit *arg2);
+
+  /* ANDs every bit of the value with var_bit, stroes the result in var1.  */
+  void and_number_bit (value *var1, value_bit *var_bit);
+
+  /* Multiplies given values.  The result is stored in dest.  */
+  void do_mul (value *arg1, value *arg2, tree dest);
+
+  /* Performs AND operation for 2 symbolic_bit operands.  */
+  static value_bit *and_sym_bits (const value_bit *var1,
+				  const value_bit *var2);
+
+  /* Performs AND operation for a symbolic_bit and const_bit operands.  */
+  static value_bit *and_var_const (const value_bit *var1,
+				   const bit *const_bit);
+
+  /* Performs AND operation for 2 constant bit operands.  */
+  static bit *and_const_bits (const bit *const_bit1, const bit *const_bit2);
+
+  /* Performs OR operation on two bits.  */
+  static value_bit *or_two_bits (value_bit *arg1_bit, value_bit *arg2_bit);
+
+  /* Performs OR operation for 2 symbolic_bit operands.  */
+  static value_bit *or_sym_bits (const value_bit *var1,
+				 const value_bit *var2);
+
+  /* Performs OR operation for a symbolic_bit and a constant bit operands.  */
+  static value_bit *or_var_const (const value_bit *var1,
+				  const bit *const_bit);
+
+  /* Performs OR operation for 2 constant bit operands.  */
+  static bit *or_const_bits (const bit *const_bit1, const bit *const_bit2);
+
+  /* Performs complement operation on a bit.  */
+  static value_bit *complement_a_bit (value_bit *var);
+
+  /* Performs NOT operation for constant bit.  */
+  static bit *complement_const_bit (const bit *const_bit);
+
+  /* Performs NOT operation for symbolic_bit.  */
+  static value_bit *complement_sym_bit (const value_bit *var);
+
+  /* Performs XOR operation on two bits.  */
+  static value_bit *xor_two_bits (value_bit *var1, value_bit *var2);
+
+  /* Performs XOR operation for 2 symbolic_bit operands.  */
+  static value_bit *xor_sym_bits (const value_bit *var1,
+				  const value_bit *var2);
+
+  /* Performs XOR operation for 2 constant bit operands.  */
+  static bit *xor_const_bits (const bit *const_bit1, const bit *const_bit2);
+
+  /* Performs XOR operation for a symbolic_bit and const_bit operands.  */
+  static value_bit *xor_var_const (const value_bit *var,
+				   const bit *const_bit);
+
+  /* Shift_right operation.  Case: var2 is a symbolic value.  */
+  static value_bit *shift_right_sym_bits (value_bit *var1, value_bit *var2);
+
+  /* Shift_left operation.  Case: var2 is a symbolic value.  */
+  static value_bit *shift_left_sym_bits (value_bit *var1, value_bit *var2);
+
+  /* Shifts var right by size of shift_value.  */
+  value *shift_right_by_const (value *var, size_t shift_value);
+
+  /* Return node which has a const bit child.  Traversal is done based
+     on safe branching.  */
+  static void get_parent_with_const_child (value_bit *root,
+					   bit_expression *&parent,
+					   bit_expression *&parent_of_parent);
+
+  /* Checks whether state for variable with specified name already
+     exists or not.  */
+  bool is_declared (tree var);
+
+  /* Declares given variable if it has not been declared yet.  */
+  void declare_if_needed (tree var, size_t size);
+
+  /* Shifts number left by size of shift_value.  */
+  value *shift_left_by_const (const value *number, size_t shift_value);
+
+  /* Adds two bits and carry value.
+     Resturn result and stores new carry bit in "carry".  */
+  static value_bit *full_adder (value_bit *var1, value_bit *var2,
+				value_bit **carry);
+
+  /* Returns the additive inverse of the given number.  */
+  value *additive_inverse (const value *number);
+
+  /* Adds two values, stores the result in the first one.  */
+  void add_numbers (value *var1, const value *var2);
+
+  /* Make a copy of given bits.  */
+  static vec<value_bit *> *make_copy (vec<value_bit *> *bits);
+
+  /* Create LFSR value for the reversed CRC.  */
+  static void create_reversed_lfsr (value &lfsr, const value &crc,
+				    const value &polynomial);
+
+  /* Create LFSR value for the forward CRC.  */
+  static void create_forward_lfsr (value &lfsr, const value &crc,
+				   const value &polynomial);
+
+ public:
+  state () = default;
+
+  ~state ();
+
+  /* Adds an empty state for the given variable.  */
+  bool decl_var (tree name, unsigned size);
+
+  state (const state &s);
+
+  /* Adds the given variable to state.  */
+  bool add_var_state (tree var, value *state);
+
+  /* Remove all states from the states' vector.  */
+  static void remove_states (vec<state *> *states);
+
+  /* Remove all states from the states' vector and release the vector.  */
+  static void clear_states (vec<state *> *states);
+
+  void clear_var_states ();
+
+  void clear_conditions ();
+
+  /* Adds the given condition to the state.  */
+  bool add_condition (bit_expression *cond);
+
+  /* Bulk add the given conditions to the state.  */
+  bool bulk_add_conditions (const hash_set<bit_expression *> &conds);
+
+  /* Get value of the given variable.  */
+  value *get_value (tree var);
+
+  /* Get the value of the tree, which is in the beginning of the var_states.  */
+  value *get_first_value ();
+
+  /* Returns the list of conditions in the state.  */
+  const hash_set<bit_expression *> &get_conditions ();
+
+  /* Adds a variable with unknown value to state.  Such variables are
+     represented as sequence of symbolic bits.  */
+  bool make_symbolic (tree var, unsigned size);
+
+  /* Returns size of the given variable.  */
+  unsigned get_var_size (tree var);
+
+  /* Prints the given value.  */
+  static void print_value (value *var);
+
+  /* Prints added conditions.  */
+  void print_conditions ();
+
+  /* Checks if all bits of the given value have constant bit type.  */
+  static bool is_bit_vector (const value *var);
+
+  /* Returns the number represented by the value.  */
+  static unsigned HOST_WIDE_INT
+  make_number (const value *var);
+
+  /* Does bit-level XOR operation for given variables.  */
+  bool do_xor (tree arg1, tree arg2, tree dest);
+
+  /* Does bit-level AND operation for given variables.  */
+  bool do_and (tree arg1, tree arg2, tree dest);
+
+  /* Does bit-level OR operation for given variables.  */
+  bool do_or (tree arg1, tree arg2, tree dest);
+
+  /* Does Assignment.  */
+  bool do_assign (tree arg, tree dest);
+
+  /* Assigns pow 2 value.  */
+  bool do_assign_pow2 (tree dest, unsigned pow);
+
+  /* Does shift_left operation for given variables.  */
+  bool do_shift_left (tree arg1, tree arg2, tree dest);
+
+  /* Does shift_right operation for given variables.  */
+  bool do_shift_right (tree arg1, tree arg2, tree dest);
+
+  /* Adds two variables.  */
+  bool do_add (tree arg1, tree arg2, tree dest);
+
+  /* Does subtraction.  */
+  bool do_sub (tree arg1, tree arg2, tree dest);
+
+  /* Multiplies two variables, stores result in dest.  */
+  bool do_mul (tree arg1, tree arg2, tree dest);
+
+  /* Negates given variable.  */
+  bool do_complement (tree arg, tree dest);
+
+  /* Adds EQUAL condition of given variables to state.  */
+  bool add_equal_cond (tree arg1, tree arg2);
+
+  /* Gets the value of *arg1 and stores it in dest.  */
+  bool do_mem_ref (tree arg1, tree dest);
+
+  /* Performs addition on arg1 pointer.  */
+  bool do_pointer_plus (tree arg1, tree arg2, tree dest);
+
+  /* Perform subtractions on arg1 pointer.  */
+  bool do_pointer_diff (tree arg1, tree arg2, tree dest);
+
+  /* Adds NOT EQUAL condition of given variables to state.  */
+  bool add_not_equal_cond (tree arg1, tree arg2);
+
+  /* Adds GREATER THAN condition of given variables to state.  */
+  bool add_greater_than_cond (tree arg1, tree arg2);
+
+  /* Adds LESS THAN condition of given variables to state.  */
+  bool add_less_than_cond (tree arg1, tree arg2);
+
+  /* Adds GREATER OR EQUAL condition of given variables to state.  */
+  bool add_greater_or_equal_cond (tree arg1, tree arg2);
+
+  /* Adds LESS OR EQUAL condition of given variables to state.  */
+  bool add_less_or_equal_cond (tree arg1, tree arg2);
+
+  /* Adds a bool condition to state.  */
+  bool add_bool_cond (tree arg);
+
+  /* Checks whether the given two constant values are equal.  */
+  static bool check_const_value_equality (value *arg1, value *arg2);
+
+  /* Checks whether the given two constant values are not equal.  */
+  static bool check_const_value_are_not_equal (value *arg1, value *arg2);
+
+  /* Checks whether the first given constant value
+     is greater than the second one.  */
+  static bool check_const_value_is_greater_than (value *arg1, value *arg2);
+
+  /* Checks whether the first given constant value
+     is less than the second one.  */
+  static bool check_const_value_is_less_than (value *arg1, value *arg2);
+
+  static value_bit *complement_bits_with_origin (value_bit *root, tree origin);
+
+  static void complement_val_bits_with_origin (value *val, tree origin);
+
+  void complement_all_vars_bits_with_origin (tree origin);
+
+  void complement_conditions_with_origin (tree origin);
+
+  void complement_state_with_origin (tree origin);
+
+  /* Returns status of last added condition.  */
+  condition_status get_last_cond_status ();
+
+  /* Create LFSR value.  */
+  static value *create_lfsr (tree crc, value *polynomial, bool is_bit_forward);
+};
+
+
+size_t min (size_t a, size_t b, size_t c);
+
+
+/* Performs the given operation on passed arguments.
+   The result is stored in dest.  */
+
+template<class func>
+void
+state::operate (value *arg1, value *arg2, value_bit **bit_arg, tree dest,
+		func bit_op)
+{
+  value *dest_var = var_states.get (dest);
+  size_t min_iter = min (arg1->length (), arg2->length (), dest_var->length ());
+
+  size_t i = 0;
+  for (; i < min_iter; i++)
+    {
+      value_bit *temp = (*var_states.get (dest))[i];
+      (*var_states.get (dest))[i] = operate_bits (bit_op, (*arg1)[i],
+						  (*arg2)[i], bit_arg);
+      delete temp;
+    }
+
+  if (i >= dest_var->length ())
+    return;
+
+  value *biggest = arg1;
+  value_bit *sign_bit = (*arg2)[i - 1];
+  if (arg2->length () > arg1->length ())
+    {
+      biggest = arg2;
+      sign_bit = (*arg1)[i - 1];
+    }
+
+  min_iter = min (biggest->length (), dest_var->length (), dest_var->length ());
+  for (; i < min_iter; i++)
+    {
+      value_bit *temp = (*var_states.get (dest))[i];
+      (*var_states.get (dest))[i] = operate_bits (bit_op, (*biggest)[i],
+						  sign_bit, bit_arg);
+      delete temp;
+    }
+
+  if (i >= dest_var->length ())
+    return;
+
+  sign_bit = (*biggest)[i - 1];
+  for (; i < dest_var->length (); i++)
+    {
+      value_bit *temp = (*var_states.get (dest))[i];
+      (*var_states.get (dest))[i] = operate_bits (bit_op, sign_bit, sign_bit,
+						  bit_arg);
+      delete temp;
+    }
+}
+
+#endif /* SYM_EXEC_STATE_H.  */
diff --git a/gcc/testsuite/gcc.dg/crc-1.c b/gcc/testsuite/gcc.dg/crc-1.c
new file mode 100644
index 00000000000..50907247db6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-1.c
@@ -0,0 +1,75 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC16 0x8005
+
+#define CRC(x) uint16_t gen_crc16_##x (const uint8_t *data, uint16_t size);\
+__attribute__ ((noinline,optimize(#x)))\
+uint16_t gen_crc16_##x (const uint8_t *data, uint16_t size) {\
+    uint16_t out = 0;\
+    int bits_read = 0, bit_flag;\
+\
+    if (data == NULL)\
+        return 0;\
+\
+    while (size > 0) {\
+        bit_flag = out >> 15;\
+\
+        out <<= 1;\
+        out |= (*data >> bits_read) & 1;\
+\
+        bits_read++;\
+        if (bits_read > 7) {\
+            bits_read = 0;\
+            data++;\
+            size--;\
+        }\
+\
+        if (bit_flag)\
+            out ^= CRC16;\
+    }\
+\
+    int i;\
+    for (i = 0; i < 16; ++i) {\
+        bit_flag = out >> 15;\
+        out <<= 1;\
+        if (bit_flag)\
+            out ^= CRC16;\
+    }\
+\
+    uint16_t crc = 0;\
+    i = 0x8000;\
+    int j = 0x0001;\
+    for (; i != 0; i >>= 1, j <<= 1) {\
+        if (i & out) crc |= j;\
+    }\
+\
+    return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  if (gen_crc16_O2 ("hello", 5) != 13522)
+    abort ();
+
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint16_t res1 = gen_crc16_O0 (&i, 1);
+      uint16_t res2 = gen_crc16_O2 (&i, 1);
+      if (res1 != res2)
+	abort ();
+    }
+}
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1\\\}" "crc" } } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-10.c b/gcc/testsuite/gcc.dg/crc-10.c
new file mode 100644
index 00000000000..fa965b342d1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-10.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define POLY (0x1070U << 3)
+#define u8 uint8_t
+#define u16 uint16_t
+
+#define CRC(x) u8 crc8_##x (u16 data);\
+ __attribute__ ((noinline,optimize(#x)))\
+u8 crc8_##x(u16 data) {\
+    int i;\
+    for (i = 0; i < 8; i++) {\
+        if (data & 0x8000)\
+            data = data ^ POLY;\
+        data = data << 1;\
+    }\
+    return (u8)(data >> 8);\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  for (u8 i = 0; i < 255; i++)
+    {
+      u8 res1 = crc8_O0 (i);
+      u8 res2 = crc8_O2 (i);
+      if (res1 != res2)
+	abort ();
+    }
+}
+/* { dg-final { scan-tree-dump "crc8_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0\\\}" "crc" } } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-11.c b/gcc/testsuite/gcc.dg/crc-11.c
new file mode 100644
index 00000000000..10fa47c5f5b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-11.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+//We just don't check cases when the polynomial is a variable, as we can't replace it.
+#include <stdint.h>
+
+uint16_t crc16(uint16_t crc, uint8_t a, uint16_t polynom) {
+  int i;
+  crc ^= a;
+  for (i = 0; i < 8; ++i) {
+      if (crc & 1)
+	crc = (crc >> 1) ^ polynom;
+      else
+	crc = (crc >> 1);
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "Second operand of the xor statement isn't an integer constant.\n" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-12.c b/gcc/testsuite/gcc.dg/crc-12.c
new file mode 100644
index 00000000000..b5f1f61c267
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-12.c
@@ -0,0 +1,72 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC16 0x8005
+#define CRC(x) uint16_t gen_crc16_##x (const uint8_t *data, uint16_t size);\
+__attribute__ ((noinline,optimize(#x)))\
+uint16_t gen_crc16_##x(const uint8_t *data, uint16_t size) {\
+    uint16_t out = 0;\
+    int bits_read = 0, bit_flag;\
+\
+\
+    if (data == NULL)\
+        return 0;\
+\
+    while (size > 0) {\
+        bit_flag = out >> 15;\
+\
+        out <<= 1;\
+        out |= (*data >> bits_read) & 1;\
+\
+        bits_read++;\
+        if (bits_read > 7) {\
+            bits_read = 0;\
+            data++;\
+            size--;\
+        }\
+\
+        if (bit_flag)\
+            out ^= CRC16;\
+\
+    }\
+\
+    int i;\
+    for (i = 0; i < 16; ++i) {\
+        bit_flag = out >> 15;\
+        out <<= 1;\
+        if (bit_flag)\
+            out ^= CRC16;\
+    }\
+\
+    uint16_t crc = 0;\
+    i = 0x8000;\
+    int j = 0x0001;\
+    for (; i != 0; i >>= 1, j <<= 1) {\
+        if (i & out) crc |= j;\
+    }\
+\
+    return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint16_t res1 = gen_crc16_O0 (&i, 1);
+      uint16_t res2 = gen_crc16_O2 (&i, 1);
+      if (res1 != res2)
+	abort ();
+    }
+}
+/* { dg-final { scan-tree-dump "gen_crc16_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-13.c b/gcc/testsuite/gcc.dg/crc-13.c
new file mode 100644
index 00000000000..44a265a8993
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-13.c
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdlib.h>
+
+#define CRC(x)\
+unsigned short crc16_##x (unsigned char data, unsigned short crc);\
+__attribute__ ((noinline,optimize(#x)))\
+unsigned short crc16_##x(unsigned char newByte, unsigned short crcValue) {\
+  unsigned char i;\
+\
+  for (i = 0; i < 8; i++) {\
+\
+      if (((crcValue & 0x8000) >> 8) ^ (newByte & 0x80)) {\
+	  crcValue = (crcValue << 1) ^ 0x102;\
+	} else {\
+	  crcValue = (crcValue << 1);\
+	}\
+\
+      newByte <<= 1;\
+    }\
+\
+  return crcValue;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  unsigned short crc = 0x0D80;
+  for (unsigned char i = 0; i < 255; i++)
+    {
+      unsigned short res1 = crc16_O0 (crc, i);
+      unsigned short res2 = crc16_O2 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crc16_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-14.c b/gcc/testsuite/gcc.dg/crc-14.c
new file mode 100644
index 00000000000..8208e2292a1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-14.c
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdlib.h>
+
+typedef unsigned char uint8_t;
+#define CRC(x) uint8_t gencrc_##x (uint8_t *data);\
+__attribute__ ((noinline,optimize(#x)))\
+uint8_t gencrc_##x (uint8_t *data)\
+{\
+  uint8_t crc = 0xff;\
+  size_t j;\
+  crc ^= *data;\
+  for (j = 0; j < 8; j++)\
+    {\
+      if ((crc & 0x80) != 0)\
+	crc = (uint8_t) ((crc << 1) ^ 0x31);\
+      else\
+	crc <<= 1;\
+    }\
+  return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint8_t res1 = gencrc_O0 (&i);
+      uint8_t res2 = gencrc_O2 (&i);
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "gencrc_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-15.c b/gcc/testsuite/gcc.dg/crc-15.c
new file mode 100644
index 00000000000..6acd5e78259
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-15.c
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -w -fdump-tree-crc-details" } */
+
+/* Test from busybox, we don't verify as it depends on endian variable.  */
+#include <stdint.h>
+#include <stdlib.h>
+
+uint32_t* crc32_filltable(uint32_t *crc_table, int endian)
+{
+  uint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;
+  uint32_t c;
+  unsigned i, j;
+
+  if (!crc_table)
+    crc_table = malloc (256 * sizeof (uint32_t));
+
+  for (i = 0; i < 256; i++)
+    {
+      c = endian ? (i << 24) : i;
+      for (j = 8; j; j--)
+	{
+	  if (endian)
+	    c = (c & 0x80000000) ? ((c << 1) ^ polynomial) : (c << 1);
+	  else
+	    c = (c & 1) ? ((c >> 1) ^ polynomial) : (c >> 1);
+	}
+      *crc_table++ = c;
+    }
+
+  return crc_table - 256;
+}
diff --git a/gcc/testsuite/gcc.dg/crc-16.c b/gcc/testsuite/gcc.dg/crc-16.c
new file mode 100644
index 00000000000..6715cd238d5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-16.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+/* A test from busybox - we don't verify, as unsigned is used for the
+  "expected" variable, but 16-bit CRC is calculated.  We verify only those cases
+  when CRC variable's size and calculated CRC are equal. In the algorithm we don't
+  check whether "expected" variable's only low half is used.  */
+int receive(/*int read_fd, */int file_fd)
+{
+  /* Initialization is not the same as in Busybox.  */
+  unsigned blockLength = 13;
+  unsigned char blockBuf[1024] = "sgdfsgdfsgdfs";
+  int cksum_or_crc = 0x4561;
+
+  unsigned expected;
+  int i, j;
+ /* ... */
+  expected = 0;
+      for (i = 0; i < blockLength; i++)
+	{
+	  expected = expected ^ blockBuf[i] << 8;
+	  for (j = 0; j < 8; j++)
+	    {
+	      if (expected & 0x8000)
+		expected = (expected << 1) ^ 0x1021;
+	      else
+		expected = (expected << 1);
+	    }
+	}
+      expected &= 0xffff;
+
+  if (cksum_or_crc != expected) {
+      /* ... */
+      return 1; // was - goto timout
+    }
+
+  /* ... */
+  return -1;
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-17.c b/gcc/testsuite/gcc.dg/crc-17.c
new file mode 100644
index 00000000000..b748b7169aa
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-17.c
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdlib.h>
+
+#define CRC(x)\
+unsigned short calc_crc_##x (unsigned short crc, unsigned char data);\
+__attribute__ ((noinline,optimize(#x)))\
+unsigned short calc_crc_##x (unsigned short crc, unsigned char data)\
+{\
+ unsigned int i, j, org, dst;\
+ org = data;\
+ dst = 0;\
+\
+ for (i = 0; i < 8; i++) {\
+  org <<= 1;\
+  dst >>= 1;\
+  if (org & 0x100)\
+   dst |= 0x80;\
+ }\
+ data = (unsigned char) dst;\
+ crc ^= (unsigned int) data << (16 - 8);\
+ for (j = 0; j < 8; j++) {\
+  if (crc & 0x8000U)\
+   crc = (crc << 1) ^ 0x1021U ;\
+  else\
+   crc <<= 1 ;\
+ }\
+ return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  unsigned short crc = 0x0D80;
+  for (unsigned char i = 0; i < 255; i++)
+    {
+      unsigned short res1 = calc_crc_O0 (crc, i);
+      unsigned short res2 = calc_crc_O2 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "calc_crc_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Polynomial's value is \\\{\[0, \]*1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\\\}" 1 "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-18.c b/gcc/testsuite/gcc.dg/crc-18.c
new file mode 100644
index 00000000000..e0a4f975773
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-18.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdlib.h>
+
+#define CRC(x) unsigned char crc8_##x (unsigned char value);\
+__attribute__ ((noinline,optimize(#x)))\
+unsigned char crc8_##x (unsigned char value)\
+{\
+    for (int i = 0; i < 8; ++i) {\
+        value = (value & 0x80) ? ((value << 1) ^ 0x31) : (value << 1);\
+    }\
+\
+    return value;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  for (unsigned char i = 0; i < 255; i++)
+    {
+      unsigned char res1 = crc8_O0 (i);
+      unsigned char res2 = crc8_O2 (i);
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "crc8_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*0, 0, 1, 1, 0, 0, 0, 1\\\}" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-19.c b/gcc/testsuite/gcc.dg/crc-19.c
new file mode 100644
index 00000000000..2be78692656
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-19.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+ #include <stdint.h>
+
+ uint32_t crc24_reverse(uint32_t crc, const uint8_t *data, uint8_t len)
+ {
+   uint32_t state = crc;
+   uint8_t i;
+
+   for (i = 0; i < len; i++) {
+       uint8_t n, cur = data[len - i - 1];
+
+       for (n = 0; n < 8; n++) {
+	   int top_bit = state >> 23;
+
+	   state = (state << 1) & 0xffffff;
+	   state |= top_bit ^ ((cur >> (7 - n)) & 1);
+	   if (top_bit)
+	     state ^= 0xb4c000;
+	 }
+     }
+
+   return state;
+ }
+
+/* { dg-final { scan-tree-dump "crc24_reverse function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-2.c b/gcc/testsuite/gcc.dg/crc-2.c
new file mode 100644
index 00000000000..84fba4d92f1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-2.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#define CRC16_CCITT     0x102
+#define POLYNOM         CRC16_CCITT
+
+unsigned int crc16 (unsigned int crcValue, unsigned char newByte) {
+    unsigned char i;
+
+    for (i = 0; i < 8; i++) {
+
+        if (((crcValue & 0x8000) >> 8) ^ (newByte & 0x80)) {
+            crcValue = (crcValue << 1) ^ POLYNOM;
+        } else {
+            crcValue = (crcValue << 1);
+        }
+
+        newByte <<= 1;
+    }
+
+    return crcValue;
+}
+
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*1, 0, 0, 0, 0, 0, 0, 1, 0\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-20.c b/gcc/testsuite/gcc.dg/crc-20.c
new file mode 100644
index 00000000000..944d2444e4e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-20.c
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+/* We don't detect this case, because there are many conditional branches.
+    Even if we detected it won't be verified,
+    because we would get more than two execution paths (states).  */
+
+#include <stdint.h>
+
+typedef uint8_t byte;
+byte Compute_CRC8_Simple_OneByte_ShiftReg (byte byteVal)
+{
+  const byte generator = 0x1D;
+  byte crc = 0; /* init crc register with 0 */
+  byte b = byteVal;
+  for (int i = 7; i >= 0; i--)
+    {
+      /* check if MSB is set */
+      if ((crc & 0x80) != 0)
+	{   /* MSB set, shift it out of the register */
+	  crc = (byte) (crc << 1);
+	  /* shift in next bit of input stream:
+	   * If it's 1, set LSB of crc to 1.
+	   * If it's 0, set LSB of crc to 0. */
+	  crc = ((byte) (b & (1 << i)) != 0) ? (byte) (crc | 0x01)
+					     : (byte) (crc & 0xFE);
+	  /* Perform the 'division' by XORing the crc register with the generator polynomial */
+	  crc = (byte) (crc ^ generator);
+	}
+      else
+	{   /* MSB not set, shift it out and shift in next bit of input stream. Same as above, just no division */
+	  crc = (byte) (crc << 1);
+	  crc = ((byte) (b & (1 << i)) != 0) ? (byte) (crc | 0x01)
+					     : (byte) (crc & 0xFE);
+	}
+    }
+  return crc;
+}
diff --git a/gcc/testsuite/gcc.dg/crc-21.c b/gcc/testsuite/gcc.dg/crc-21.c
new file mode 100644
index 00000000000..36a052a5370
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-21.c
@@ -0,0 +1,44 @@
+/* { dg-do run { target { lp64 } } } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC(x) uint32_t _crc32_##x (uint32_t crc, uint32_t data);\
+__attribute__ ((noinline,optimize(#x)))\
+uint32_t _crc32_##x (uint32_t crc, uint32_t data) {\
+  if (sizeof (uint32_t) < 4)\
+    exit (0);\
+  int i;\
+  crc = crc ^ data;\
+\
+  for (i = 0; i < 32; i++) {\
+      if (crc & 0x80000000)\
+	crc = (crc << 1) ^ 0x04C11DB7;\
+      else\
+	crc = (crc << 1);\
+    }\
+\
+  return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  uint32_t crc = 0x0D800D80;
+  for (uint32_t i = 0; i < 0xffffff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (crc, i);
+      uint32_t res2 = _crc32_O2 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "_crc32_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 31" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC." "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-22.c b/gcc/testsuite/gcc.dg/crc-22.c
new file mode 100644
index 00000000000..a4850543ae9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-22.c
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdlib.h>
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+#define CRC(x) ee_u16 crcu16_##x (ee_u16 data, ee_u16 crc);\
+__attribute__ ((noinline,optimize(#x)))\
+ee_u16 crcu16_##x (ee_u16 data, ee_u16 crc) {\
+  ee_u8 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 16; i++) {\
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x4002;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x8000;\
+      else\
+	crc &= 0x7fff;\
+    }\
+  return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  ee_u16 crc = 0x0D80;
+  for (ee_u16 i = 0; i < 255; i++)
+    {
+      ee_u16 res1 = crcu16_O0 (i, crc);
+      ee_u16 res2 = crcu16_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-23.c b/gcc/testsuite/gcc.dg/crc-23.c
new file mode 100644
index 00000000000..7f47f6b1a65
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-23.c
@@ -0,0 +1,55 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -ftree-cselim" } */
+
+// Modified example from crc-from-fedora-packages-24.c
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC(x) void crc_byte_##x (const char data, uint16_t * crc16);\
+__attribute__ ((noinline,optimize(#x)))\
+void crc_byte_##x(const char data, uint16_t *crc16)\
+{\
+  int k;\
+  uint16_t c,d ;\
+\
+  c = data << 8 ;\
+  d = c;\
+\
+  for (k = 0; k < 16; k++) {\
+      *crc16 = (c & 0x8000) ^ *crc16;\
+\
+      if (*crc16 & 0x8000) {\
+	  *crc16 = *crc16 << 1;\
+	  *crc16 = *crc16 ^ 0x8005;\
+	} else\
+	*crc16 = *crc16 << 1;\
+\
+      d = d << 1;\
+      c = d;\
+    }\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  uint16_t crc = 0x0D80;
+  for (char i = 0; i < 127; i++)
+    {
+      uint16_t res1 = crc, res2 = crc;
+      crc_byte_O0 (i, &res1);
+      crc_byte_O2 (i, &res2);
+
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-24.c b/gcc/testsuite/gcc.dg/crc-24.c
new file mode 100644
index 00000000000..e8c0164a73c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-24.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+// Modified Coremark test, we don't detect.
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint16_t data, uint16_t crc)
+{
+  uint16_t i = 0, carry = 0;
+  for (i = 0; i < 16; i++)
+    {
+      if ((((crc & 1) == 1) && ((data & 1) == 0))
+	  || (((crc & 1) == 0) && (data & 1) == 1))
+	{
+	  crc ^= 0x4002;
+	  carry = 1;
+	}
+      else
+	carry = 0;
+      crc >>= 1;
+      data >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-25.c b/gcc/testsuite/gcc.dg/crc-25.c
new file mode 100644
index 00000000000..c36c6944620
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-25.c
@@ -0,0 +1,58 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+//Test from roms/u-boot-sam460ex/drivers/net/mpc512x_fec.c(fsl_mcdmafec.c)
+
+#include <stdint.h>
+#include <stdlib.h>
+
+typedef uint8_t u8;
+typedef uint32_t u32;
+
+#define CRC(x)\
+u32 mpc512x_fec_set_hwaddr_##x (unsigned char *mac);\
+__attribute__ ((noinline,optimize(#x)))\
+u32 mpc512x_fec_set_hwaddr_##x (unsigned char *mac)\
+{\
+  u8 currByte;                    /* byte for which to compute the CRC */\
+  int byte;                       /* loop - counter */\
+  int bit;                        /* loop - counter */\
+  u32 crc = 0xffffffff;           /* initial value */\
+\
+  for (byte = 0; byte < 6; byte++) {\
+      currByte = mac[byte];\
+      for (bit = 0; bit < 8; bit++) {\
+	  if ((currByte & 0x01) ^ (crc & 0x01)) {\
+	      crc >>= 1;\
+	      crc = crc ^ 0xedb88320;\
+	    } else {\
+	      crc >>= 1;\
+	    }\
+	  currByte >>= 1;\
+	}\
+    }\
+\
+  crc = crc >> 26;\
+  return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  unsigned char st[6] = "Hello";
+  for (unsigned char i = 0; i < 255; i++)
+    {
+      st[0] = i;
+      u32 res1 = mpc512x_fec_set_hwaddr_O0 (st);
+      u32 res2 = mpc512x_fec_set_hwaddr_O2 (st);
+      if (res1 != res2)
+	abort ();
+    }
+}
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-26.c b/gcc/testsuite/gcc.dg/crc-26.c
new file mode 100644
index 00000000000..d20fc650a2d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-26.c
@@ -0,0 +1,51 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+//Test from roms/u-boot-sam460ex/drivers/mtd/ubi/crc32.c
+#include <stdint.h>
+#include <stdlib.h>
+
+typedef uint8_t u8;
+typedef uint32_t u32;
+#define CRCPOLY_LE 0xedb88320
+
+#define CRC(x)\
+u32 crc32_le_##x (u32 crc, unsigned char const *p, size_t len);\
+__attribute__ ((noinline,optimize(#x)))\
+u32 crc32_le_##x (u32 crc, unsigned char const *p, size_t len)\
+{\
+  if (sizeof (u32) < 4)\
+    exit (0);\
+  int i;\
+  while (len--) {\
+      crc ^= *p++;\
+      for (i = 0; i < 8; i++)\
+	crc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY_LE : 0);\
+    }\
+  return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  if (sizeof (u32) < 4)
+    exit (0);
+  u32 crc = 0x0D800D80;
+  unsigned char st[2] = {'H','i'};
+  for (unsigned char i = 0; i < 255; i++)
+    {
+      st[0] = i;
+      u32 res1 = crc32_le_O0 (crc, st, 2);
+      u32 res2 = crc32_le_O2 (crc, st, 2);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-27.c b/gcc/testsuite/gcc.dg/crc-27.c
new file mode 100644
index 00000000000..f36999b3751
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-27.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// Test from roms/ipxe/src/util/zbin.c
+// We don't detect this case, as second operand of the xor is a variable.
+
+#include <stdint.h>
+#include <stddef.h>
+
+#define CRCPOLY 0xedb88320
+#define CRCSEED 0xffffffff
+
+uint32_t crc32_le ( uint32_t crc, const void *data, size_t len ) {
+  const uint8_t *src = data;
+  uint32_t mult;
+  unsigned int i;
+
+  while ( len-- ) {
+      crc ^= *(src++);
+      for ( i = 0 ; i < 8 ; i++ ) {
+	  mult = ( ( crc & 1 ) ? CRCPOLY : 0 );
+	  crc = ( ( crc >> 1 ) ^ mult );
+	}
+    }
+  return crc;
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-28.c b/gcc/testsuite/gcc.dg/crc-28.c
new file mode 100644
index 00000000000..7079ffc45bc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-28.c
@@ -0,0 +1,75 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+// Test from roms/u-boot/drivers/ram/octeon/dimm_spd_eeprom.c
+
+#include <stdint.h>
+#include <stdlib.h>
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+
+// We don't verify as crc is of type int (32 bit),
+// but the polynomial fits into 16 bit.
+u16 ddr3_crc16_orig (u8 *ptr, int count)
+{
+  /* From DDR3 SPD specification */
+  int crc, i;
+
+  crc = 0;
+  while (--count >= 0) {
+      crc = crc ^ (int)*ptr++ << 8;
+      for (i = 0; i < 8; ++i) {
+	  if (crc & 0x8000)
+	    crc = crc << 1 ^ 0x1021;
+	  else
+	    crc = crc << 1;
+	}
+    }
+
+  return (crc & 0xFFFF);
+}
+
+#define CRC(x)\
+u16 ddr3_crc16_modified_##x (u8 *ptr, int count);\
+__attribute__ ((noinline,optimize(#x)))\
+u16 ddr3_crc16_modified_##x  (u8 *ptr, int count)\
+{\
+  /* From DDR3 SPD specification */\
+  u16 crc, i;\
+\
+  crc = 0;\
+  while (--count >= 0) {\
+      crc = crc ^ (int)*ptr++ << 8;\
+      for (i = 0; i < 8; ++i) {\
+	  if (crc & 0x8000)\
+	    crc = crc << 1 ^ 0x1021;\
+	  else\
+	    crc = crc << 1;\
+	}\
+    }\
+\
+  return (crc & 0xFFFF);\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  u8 st[2] = {'H', 'i'};
+  for (u8 i = 0; i < 255; i++)
+    {
+      st[0] = i;
+      u16 res1 = ddr3_crc16_modified_O0 (st, 2);
+      u16 res2 = ddr3_crc16_modified_O2 (st, 2);
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-29.c b/gcc/testsuite/gcc.dg/crc-29.c
new file mode 100644
index 00000000000..f9225afcb8c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-29.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint8_t data, uint16_t crc) {
+  uint8_t x16 = 0, carry = 0;
+  for (uint8_t i = 0, j=4; i < 8; i++, j+=2) {
+      x16 = (uint8_t) (((uint8_t) crc & 1)  ^ (j & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-3.c b/gcc/testsuite/gcc.dg/crc-3.c
new file mode 100644
index 00000000000..77395e1ab1b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-3.c
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+//We don't verify this case as for the CRC unsigned int (32 bit) is used and
+// the polynomial fits into 16 bit.
+
+unsigned short crc16 (char *data_p, unsigned short length) {
+    unsigned char i;
+    unsigned int data;
+    unsigned int crc = 0xffff;
+
+    if (length == 0)
+        return (~crc);
+
+    do {
+        for (i = 0, data = (unsigned int) 0xff & *data_p++;
+             i < 8;
+             i++, data >>= 1) {
+            if ((crc & 0x0001) ^ (data & 0x0001))
+                crc = (crc >> 1) ^ 0x8408;
+            else crc >>= 1;
+        }
+    } while (--length);
+
+    crc = ~crc;
+    data = crc;
+    crc = (crc << 8) | (data >> 8 & 0xff);
+
+    return (crc);
+}
+
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-4.c b/gcc/testsuite/gcc.dg/crc-4.c
new file mode 100644
index 00000000000..1ee4d484b2f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-4.c
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#define CRC(x) uint16_t crc16_update_##x (uint16_t crc, uint8_t a); \
+__attribute__ ((noinline,optimize(#x)))\
+uint16_t crc16_update_##x (uint16_t crc, uint8_t a) {\
+    int i;\
+    crc ^= a;\
+    for (i = 0; i < 8; ++i) {\
+        if (crc & 1)\
+            crc = (crc >> 1) ^ 0xA001;\
+        else\
+            crc = (crc >> 1);\
+    }\
+    return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  uint16_t crc = 0x0D80;
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint16_t res1 = crc16_update_O2 (crc, i);
+      uint16_t res2 = crc16_update_O0 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-5.c b/gcc/testsuite/gcc.dg/crc-5.c
new file mode 100644
index 00000000000..c1d04a729ba
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-5.c
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+#define CRC(x) ee_u16 crcu8_##x (ee_u8 data, ee_u16 crc);\
+__attribute__ ((noinline,optimize(#x)))\
+ee_u16 crcu8_##x (ee_u8 data, ee_u16 crc) {\
+  ee_u8 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 8; i++) {\
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x4002;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x8000;\
+      else\
+	crc &= 0x7fff;\
+    }\
+  return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  ee_u16 crc = 0x0D80;
+  for (ee_u8 i = 0; i < 255; i++)
+    {
+      ee_u16 res1 = crcu8_O0 (i, crc);
+      ee_u16 res2 = crcu8_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crcu8_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-6.c b/gcc/testsuite/gcc.dg/crc-6.c
new file mode 100644
index 00000000000..97663d78549
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-6.c
@@ -0,0 +1,49 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+typedef uint8_t crc;
+#define WIDTH (8 * sizeof(crc))
+#define TOPBIT (1 << (WIDTH - 1))
+
+#define CRC(x) crc crcSlow_##x (uint8_t const message[], int nBytes);\
+__attribute__ ((noinline,optimize(#x)))\
+crc crcSlow_##x (uint8_t const message[], int nBytes) {\
+    crc remainder = 0;\
+/*\
+* Perform modulo-2 division, a byte at a time.\
+*/\
+    for (int byte = 0; byte < nBytes; ++byte) {\
+        remainder ^= (message[byte] << (WIDTH - 8));\
+        for (uint8_t bit = 8; bit > 0; --bit) {\
+            if (remainder & TOPBIT) {\
+                remainder = (remainder << 1) ^ 1234;\
+            } else {\
+                remainder = (remainder << 1);\
+            }\
+        }\
+    }\
+    return (remainder);\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  for (crc i = 0; i < 255; i++)
+    {
+      crc res1 = crcSlow_O0 (&i, 1);
+      crc res2 = crcSlow_O2 (&i, 1);
+      if (res1 != res2)
+	abort ();
+    }
+}
+/* { dg-final { scan-tree-dump "crcSlow_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{1, 1, 0, 1, 0, 0, 1, 0\\\}" "crc" } } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-7.c b/gcc/testsuite/gcc.dg/crc-7.c
new file mode 100644
index 00000000000..4092bd23c36
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-7.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC(x) uint16_t crc_xmodem_update_##x (uint16_t crc, uint8_t data);\
+__attribute__ ((noinline,optimize(#x)))\
+uint16_t crc_xmodem_update_##x (uint16_t crc, uint8_t data) {\
+    int i;\
+    crc = crc ^ ((uint16_t) data << 8);\
+    for (i = 0; i < 8; i++) {\
+        if (crc & 0x8000)\
+            crc = (crc << 1) ^ 0x1021;\
+        else\
+            crc <<= 1;\
+    }\
+    return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  uint16_t crc = 0x0D80;
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint16_t res1 = crc_xmodem_update_O0 (i, crc);
+      uint16_t res2 = crc_xmodem_update_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crc_xmodem_update_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\\\}" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-8.c b/gcc/testsuite/gcc.dg/crc-8.c
new file mode 100644
index 00000000000..04fb8711486
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-8.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC(x) uint8_t _crc_ibutton_update_##x (uint8_t data, uint8_t crc);\
+__attribute__ ((noinline,optimize(#x)))\
+uint8_t _crc_ibutton_update_##x (uint8_t crc, uint8_t data) {\
+    uint8_t i;\
+    crc = crc ^ data;\
+    for (i = 0; i < 8; i++) {\
+        if (crc & 0x01)\
+            crc = (crc >> 1) ^ 0x8C;\
+        else\
+            crc >>= 1;\
+    }\
+    return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  uint8_t crc = 0x0D;
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint8_t res1 = _crc_ibutton_update_O0 (i, crc);
+      uint8_t res2 = _crc_ibutton_update_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "_crc_ibutton_update_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*1, 0, 0, 0, 1, 1, 0, 0\\\}" "crc" } } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-9.c b/gcc/testsuite/gcc.dg/crc-9.c
new file mode 100644
index 00000000000..e39a20c8007
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-9.c
@@ -0,0 +1,44 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdlib.h>
+
+typedef unsigned char uint8_t;
+
+#define CRC(x) uint8_t gencrc_##x (uint8_t *data, size_t len);\
+__attribute__ ((noinline,optimize(#x)))\
+uint8_t gencrc_##x (uint8_t *data, size_t len) {\
+    uint8_t crc = 0xff;\
+    size_t i, j;\
+    for (i = 0; i < len; i++) {\
+        crc ^= data[i];\
+        for (j = 0; j < 8; j++) {\
+            if ((crc & 0x80) != 0)\
+                crc = (uint8_t) ((crc << 1) ^ 0x31);\
+            else\
+                crc <<= 1;\
+        }\
+    }\
+    return crc;\
+}\
+
+CRC(O2)
+CRC(O0)
+
+int main ()
+{
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint8_t res1 = gencrc_O0 (&i, 1);
+      uint8_t res2 = gencrc_O2 (&i, 1);
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "gencrc_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*0, 0, 1, 1, 0, 0, 0, 1\\\}" "crc" } } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-CCIT-data16-xorOutside_InsideFor.c b/gcc/testsuite/gcc.dg/crc-CCIT-data16-xorOutside_InsideFor.c
new file mode 100644
index 00000000000..d7a034fb699
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-CCIT-data16-xorOutside_InsideFor.c
@@ -0,0 +1,54 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdlib.h>
+#include <stdint.h>
+
+uint16_t crc16_xor_outside (uint16_t data, uint16_t crc)
+{
+  int carry;
+  crc ^= data;
+  for (int i = 0; i < 16; ++i) {
+      carry = ((crc & 0x8000));
+      crc <<= 1;
+      if (carry) crc ^= 0x1021;
+    }
+  return crc;
+}
+
+uint16_t crc16_xor_inside (uint16_t data, uint16_t crc)
+{
+  int carry;
+  for (int i = 0; i < 16; ++i) {
+      carry = ((crc & 0x8000) ^ (data & 0x8000));
+      crc <<= 1;
+      data <<= 1;
+      if (carry) crc ^= 0x1021;
+    }
+  return crc;
+}
+
+int main ()
+{
+  uint16_t crc = 0;
+
+  for (uint16_t i = 0; i < 65535; i++)
+    {
+      uint16_t res1 = crc16_xor_outside (i, crc);
+      uint16_t res2 = crc16_xor_inside (i, crc);
+      crc = res1;
+      if (res1 != res2)
+	abort ();
+    }
+
+  if (crc16_xor_outside (0x1111, 0xFFFF) != 0x2f5d)
+    abort ();
+
+  if (crc16_xor_inside (0x1111, 0xFFFF) != 0x2f5d)
+    abort ();
+}
+
+/* { dg-final { scan-tree-dump "crc16_xor_outside function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 4 "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-CCIT-data16.c b/gcc/testsuite/gcc.dg/crc-CCIT-data16.c
new file mode 100644
index 00000000000..18780f2f1b1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-CCIT-data16.c
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+#include <stdint.h>
+#define CRC(x) static uint16_t crc16_##x (uint16_t data, uint16_t crc); static \
+__attribute__ ((noinline,optimize(#x))) uint16_t crc16_##x (uint16_t data, uint16_t crc)\
+{\
+  int carry;\
+  for (int i = 0; i < 16; ++i) {\
+      carry = ((crc & 0x8000) ^ (data & 0x8000));\
+      crc <<= 1;\
+      data <<= 1;\
+      if (carry) crc ^= 0x1021;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  uint16_t crc = 0;
+
+  for (uint16_t i = 0; i < 65535; i++)
+    {
+      uint16_t res1 = crc16_O0 (i, crc);
+      uint16_t res2 = crc16_O2 (i, crc);
+      crc = res1;
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "crc16_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-CCIT-data8.c b/gcc/testsuite/gcc.dg/crc-CCIT-data8.c
new file mode 100644
index 00000000000..40fe0a2b516
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-CCIT-data8.c
@@ -0,0 +1,38 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC(x) static uint16_t crc16_##x (uint8_t data, uint16_t crc); static \
+__attribute__ ((noinline,optimize(#x))) uint16_t crc16_##x (uint8_t data, uint16_t crc) {\
+  int carry;\
+  for (int i = 0; i < 8; ++i) {\
+      carry = ((crc & 0x8000) >> 8 ^ (data & 0x80));\
+      crc <<= 1;\
+      data <<= 1;\
+      if (carry) crc ^= 0x1021;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  uint16_t crc = 0x0D80;
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint16_t res1 = crc16_O0 (i, crc);
+      uint16_t res2 = crc16_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "crc16_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-coremark16-data16.c b/gcc/testsuite/gcc.dg/crc-coremark16-data16.c
new file mode 100644
index 00000000000..826848e774b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-coremark16-data16.c
@@ -0,0 +1,48 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+#define CRC(x) static ee_u16 crcu16_##x (ee_u16 data, ee_u16 crc); static \
+__attribute__ ((noinline,optimize(#x))) ee_u16 crcu16_##x (ee_u16 data, ee_u16 crc) {\
+  ee_u8 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 16; i++) {\
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x4002;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x8000;\
+      else\
+	crc &= 0x7fff;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  ee_u16 crc = 0x0D80;
+  for (ee_u16 i = 0; i < 65535; i++)
+    {
+      ee_u16 res1 = crcu16_O0 (i, crc);
+      ee_u16 res2 = crcu16_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "crcu16_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
diff --git a/gcc/testsuite/gcc.dg/crc-coremark32-data16.c b/gcc/testsuite/gcc.dg/crc-coremark32-data16.c
new file mode 100644
index 00000000000..f46108e57d4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-coremark32-data16.c
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+
+typedef unsigned int ee_u32;
+typedef unsigned short ee_u16;
+
+#define CRC(x) static ee_u32 crcu32_##x (ee_u16 data, ee_u32 crc); static \
+__attribute__ ((noinline,optimize(#x))) ee_u32 crcu32_##x (ee_u16 data, ee_u32 crc) {\
+  ee_u32 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 16; i++) {\
+      x16 = ((data & 1) ^ (crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x4002123;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x80000000;\
+      else\
+	crc &= 0x7fffffff;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  ee_u32 crc = 0;
+  for (ee_u16 i = 0; i < 0xffff; i++)
+    {
+      ee_u32 res1 = crcu32_O0 (i, crc);
+      ee_u32 res2 = crcu32_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crcu32_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-coremark32-data32.c b/gcc/testsuite/gcc.dg/crc-coremark32-data32.c
new file mode 100644
index 00000000000..21bb996a068
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-coremark32-data32.c
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+
+typedef unsigned int ee_u32;
+
+#define CRC(x) static ee_u32 crcu32_##x (ee_u32 data, ee_u32 crc); static \
+__attribute__ ((noinline,optimize(#x))) ee_u32 crcu32_##x(ee_u32 data, ee_u32 crc) {\
+  ee_u32 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 32; i++) {\
+      x16 = ((data & 1) ^ (crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x4002123;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x80000000;\
+      else\
+	crc &= 0x7fffffff;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  ee_u32 crc = 0;
+  for (ee_u32 i = 0; i < 0xffff; i++)
+    {
+      ee_u32 res1 = crcu32_O0 (i, crc);
+      ee_u32 res2 = crcu32_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crcu32_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 31" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-coremark32-data8.c b/gcc/testsuite/gcc.dg/crc-coremark32-data8.c
new file mode 100644
index 00000000000..f9903fec087
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-coremark32-data8.c
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+
+typedef unsigned int ee_u32;
+typedef unsigned char ee_u8;
+
+#define CRC(x) static ee_u32 crcu32_##x (ee_u8 data, ee_u32 crc); static \
+__attribute__ ((noinline,optimize(#x))) ee_u32 crcu32_##x (ee_u8 data, ee_u32 crc) {\
+  ee_u32 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 8; i++) {\
+      x16 = ((data & 1) ^ (crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x4002123;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x80000000;\
+      else\
+	crc &= 0x7fffffff;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  ee_u32 crc = 0;
+  for (ee_u8 i = 0; i < 0xff; i++)
+    {
+      ee_u32 res1 = crcu32_O0 (i, crc);
+      ee_u32 res2 = crcu32_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crcu32_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-coremark64-data64.c b/gcc/testsuite/gcc.dg/crc-coremark64-data64.c
new file mode 100644
index 00000000000..c1179b553c6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-coremark64-data64.c
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+
+typedef unsigned long long int ee_u64;
+
+#define CRC(x) static ee_u64 crcu64_##x (ee_u64 data, ee_u64 crc); static \
+__attribute__ ((noinline,optimize(#x))) ee_u64 crcu64_##x(ee_u64 data, ee_u64 crc) {\
+  ee_u64 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 64; i++) {\
+      x16 = ((data & 1) ^ (crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x4002123f4002123f;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x8000000000000000;\
+      else\
+	crc &= 0x7fffffffffffffff;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  ee_u64 crc = 0;
+  for (ee_u64 i = 0; i < 0xff; i++)
+    {
+      ee_u64 res1 = crcu64_O0 (i, crc);
+      ee_u64 res2 = crcu64_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crcu64_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 63" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-coremark8-data8.c b/gcc/testsuite/gcc.dg/crc-coremark8-data8.c
new file mode 100644
index 00000000000..076f48606ab
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-coremark8-data8.c
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdlib.h>
+
+typedef unsigned char ee_u8;
+
+#define CRC(x) static ee_u8 crcu8_##x (ee_u8 data, ee_u8 crc); static \
+__attribute__ ((noinline,optimize(#x))) ee_u8 crcu8_##x(ee_u8 data, ee_u8 crc) {\
+  ee_u8 i = 0, x16 = 0, carry = 0;\
+  for (i = 0; i < 8; i++) {\
+      x16 = ((data & 1) ^ (crc & 1));\
+      data >>= 1;\
+      if (x16 == 1) {\
+	  crc ^= 0x40;\
+	  carry = 1;\
+	} else\
+	carry = 0;\
+      crc >>= 1;\
+      if (carry)\
+	crc |= 0x80;\
+      else\
+	crc &= 0x7f;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  ee_u8 crc = 0;
+  for (ee_u8 i = 0; i < 0xff; i++)
+    {
+      ee_u8 res1 = crcu8_O0 (i, crc);
+      ee_u8 res2 = crcu8_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+/* { dg-final { scan-tree-dump "crcu8_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-crc32-data16.c b/gcc/testsuite/gcc.dg/crc-crc32-data16.c
new file mode 100644
index 00000000000..19c91e0ee4e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc32-data16.c
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+#define CRC(x) static uint32_t _crc32_##x (uint16_t data, uint32_t crc); static \
+__attribute__ ((noinline,optimize(#x))) uint32_t _crc32_##x (uint16_t data, uint32_t crc) {\
+  if (sizeof (uint32_t) < 4)\
+    exit (0);\
+  int i;\
+  for (i = 0; i < 16; i++) {\
+      if ((crc & 0x80000000) >> 16 ^ (data & 0x8000))\
+	crc = (crc << 1) ^ 0x04C11DB7;\
+      else\
+	crc = (crc << 1);\
+      data <<= 1;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  if (sizeof (uint32_t) < 4)
+    exit (0);
+
+  uint32_t crc = 0;
+
+  for (uint16_t i = 0; i < 0xfff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (i, crc);
+      uint32_t res2 = _crc32_O2 (i, crc);
+      crc = res2;
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "_crc32_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 15" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC." "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-crc32-data24.c b/gcc/testsuite/gcc.dg/crc-crc32-data24.c
new file mode 100644
index 00000000000..5105e3c3a3c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc32-data24.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+uint32_t _crc32 (uint32_t data, uint32_t crc) {
+  int i;
+  for (i = 0; i < 24; i++) {
+      if ((crc & 0x80000000) >> 8 ^ (data & 0x800000))
+	crc = (crc << 1) ^ 0x04C11DB7;
+      else
+	crc = (crc << 1);
+      data <<= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "_crc32 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 23" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-crc32-data8.c b/gcc/testsuite/gcc.dg/crc-crc32-data8.c
new file mode 100644
index 00000000000..085671daef0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc32-data8.c
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+#define CRC(x) static uint32_t _crc32_##x (uint8_t data, uint32_t crc); static \
+__attribute__ ((noinline,optimize(#x))) uint32_t _crc32_##x (uint8_t data, uint32_t crc) {\
+  if (sizeof (uint32_t) < 4)\
+    exit (0);\
+  int i;\
+  for (i = 0; i < 8; i++) {\
+      if ((crc & 0x80000000) >> 24 ^ (data & 0x80))\
+	crc = (crc << 1) ^ 0x04C11DB7;\
+      else\
+	crc = (crc << 1);\
+      data <<= 1;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  if (sizeof (uint32_t) < 4)
+    exit (0);
+
+  uint32_t crc = 0;
+
+  for (uint8_t i = 0; i < 0xff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (i, crc);
+      uint32_t res2 = _crc32_O2 (i, crc);
+      crc = res2;
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "_crc32_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC." "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-crc32.c b/gcc/testsuite/gcc.dg/crc-crc32.c
new file mode 100644
index 00000000000..e6662fc4d17
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc32.c
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+#define CRC(x) static uint32_t _crc32_##x (uint32_t data, uint32_t crc); static \
+__attribute__ ((noinline,optimize(#x))) uint32_t _crc32_##x (uint32_t data, uint32_t crc) {\
+  if (sizeof (uint32_t) < 4)\
+    exit (0);\
+  int i;\
+  for (i = 0; i < 32; i++) {\
+      if ((crc & 0x80000000) ^ (data & 0x80000000))\
+	crc = (crc << 1) ^ 0x04C11DB7;\
+      else\
+	crc = (crc << 1);\
+      data <<= 1;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  if (sizeof (uint32_t) < 4)
+    exit (0);
+
+  uint32_t crc = 0;
+
+  for (uint32_t i = 0; i < 0xffff; i++)
+    {
+      uint32_t res1 = _crc32_O0 (i, crc);
+      uint32_t res2 = _crc32_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res2;
+    }
+}
+
+/* { dg-final { scan-tree-dump "_crc32_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 31" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC." "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-crc64-data32.c b/gcc/testsuite/gcc.dg/crc-crc64-data32.c
new file mode 100644
index 00000000000..56459a708e4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc64-data32.c
@@ -0,0 +1,43 @@
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+// CRC64_ECMA_182
+#define CRC(x) uint64_t _crc64_##x (uint32_t data, uint64_t crc);\
+__attribute__ ((noinline,optimize(#x)))\
+uint64_t _crc64_##x (uint32_t data, uint64_t crc) {\
+  int i;\
+  for (i = 0; i < 32; i++) {\
+      if (((crc & 0x8000000000000000) >> 32 ^ (data & 0x80000000)))\
+	crc = (crc << 1) ^ 0x42F0E1EBA9EA3693;\
+      else\
+	crc = (crc << 1);\
+      data <<= 1;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  uint64_t crc = 0;
+
+  for (uint32_t i = 0; i < 0xff; i++)
+    {
+      uint64_t res1 = _crc64_O0 (i, crc);
+      uint64_t res2 = _crc64_O2 (i, crc);
+      crc = res2;
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "_crc64_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 31" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-crc64-data64.c b/gcc/testsuite/gcc.dg/crc-crc64-data64.c
new file mode 100644
index 00000000000..16f2584f0b0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc64-data64.c
@@ -0,0 +1,42 @@
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+// CRC64_ECMA_182
+#define CRC(x) static uint64_t _crc64_##x (uint64_t data, uint64_t crc); static \
+__attribute__ ((noinline,optimize(#x))) uint64_t _crc64_##x (uint64_t crc, uint64_t data) {\
+  int i;\
+  for (i = 0; i < 64; i++) {\
+      if (((crc & 0x8000000000000000) ^ (data & 0x8000000000000000)))\
+	crc = (crc << 1) ^ 0x42F0E1EBA9EA369342F0E1EBA9EA3693;\
+      else\
+	crc = (crc << 1);\
+      data <<= 1;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  uint64_t crc = 0;
+
+  for (uint64_t i = 0; i < 0xff; i++)
+    {
+      uint64_t res1 = _crc64_O0 (i, crc);
+      uint64_t res2 = _crc64_O2 (i, crc);
+      crc = res2;
+      if (res1 != res2)
+	abort ();
+    }
+}
+
+/* { dg-final { scan-tree-dump "_crc64_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 63" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-crc8-data8-loop-xorInFor.c b/gcc/testsuite/gcc.dg/crc-crc8-data8-loop-xorInFor.c
new file mode 100644
index 00000000000..70c126f5a36
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc8-data8-loop-xorInFor.c
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stddef.h>
+#include <assert.h>
+
+typedef unsigned char uint8_t;
+
+uint8_t gencrc (uint8_t *message, size_t len) {
+  uint8_t crc = 0;
+  size_t i, j;
+  for (i = 0; i < len; i++) {
+      uint8_t data = message[i];
+      for (j = 0; j < 8; j++) {
+	  if (((crc & 0x80) ^ (data & 0x80)) != 0)
+	    crc = (uint8_t) ((crc << 1) ^ 0x31);
+	  else
+	    crc <<= 1;
+	  data <<=1;
+	}
+    }
+  return crc;
+}
+
+int main()
+{
+  uint8_t message[] = "Hello world!";
+  assert (gencrc(message, 12) == 0x24);
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-crc8-data8-loop-xorOutsideFor.c b/gcc/testsuite/gcc.dg/crc-crc8-data8-loop-xorOutsideFor.c
new file mode 100644
index 00000000000..306b5d6ffad
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc8-data8-loop-xorOutsideFor.c
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stddef.h>
+#include <assert.h>
+
+typedef unsigned char uint8_t;
+
+uint8_t gencrc (uint8_t *message, size_t len) {
+  uint8_t crc = 0;
+  size_t i, j;
+  for (i = 0; i < len; i++) {
+      uint8_t data = message[i];
+      crc ^= data;
+      for (j = 0; j < 8; j++) {
+	  if ((crc & 0x80)!= 0)
+	    crc = (uint8_t) ((crc << 1) ^ 0x31);
+	  else
+	    crc <<= 1;
+	}
+    }
+  return crc;
+}
+
+int main()
+{
+  uint8_t message[] = "Hello world!";
+  assert (gencrc(message, 12) == 0x24);
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-crc8-data8-xorOustideFor.c b/gcc/testsuite/gcc.dg/crc-crc8-data8-xorOustideFor.c
new file mode 100644
index 00000000000..2c163db0644
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc8-data8-xorOustideFor.c
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-options "-fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC(x) uint8_t gencrc_##x (uint8_t crc, uint8_t data);\
+__attribute__ ((noinline,optimize(#x)))\
+uint8_t gencrc_##x (uint8_t crc, uint8_t data)\
+{\
+  size_t j;\
+  crc ^= data;\
+  for (j = 0; j < 8; j++)\
+    {\
+      if ((crc & 0x80) != 0)\
+	crc = (uint8_t) ((crc << 1) ^ 0x31);\
+      else\
+	crc <<= 1;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  uint8_t crc = 0x0D;
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint8_t res1 = gencrc_O0 (crc, i);
+      uint8_t res2 = gencrc_O2 (crc, i);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-crc8.c b/gcc/testsuite/gcc.dg/crc-crc8.c
new file mode 100644
index 00000000000..27c6b91cd06
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-crc8.c
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -w" } */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define CRC(x) uint8_t crc8_##x (uint8_t data, uint8_t crc);\
+__attribute__ ((noinline,optimize(#x))) uint8_t crc8_##x (uint8_t data, uint8_t crc)\
+{\
+  int carry;\
+  for (int i = 0; i < 8; ++i) {\
+      carry = ((crc & 0x80) ^ (data & 0x80));\
+      crc <<= 1;\
+      data <<= 1;\
+      if (carry) crc ^= 0x21;\
+    }\
+  return crc;\
+}\
+
+CRC(O0)
+CRC(O2)
+
+int main ()
+{
+  uint8_t crc = 0x0D;
+  for (uint8_t i = 0; i < 255; i++)
+    {
+      uint8_t res1 = crc8_O0 (i, crc);
+      uint8_t res2 = crc8_O2 (i, crc);
+      if (res1 != res2)
+	abort ();
+      crc = res1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "crc8_O2 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit forward" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-1.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-1.c
new file mode 100644
index 00000000000..69dceb5c43a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-1.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File_Ac3.cpp.ii
+// We don't support non-constant polynomials.
+
+#include <stddef.h>
+typedef unsigned short int16u;
+typedef unsigned char int8u;
+int CRC16_Init(int16u *Table, int16u Polynomial)
+{
+    for (size_t Pos=0; Pos<256; Pos++)
+    {
+        Table[Pos]=(int16u)Pos<<8;
+
+        for(int8u bit=0; bit<8; bit++)
+        {
+            if (Table[Pos]&0x8000)
+                Table[Pos]=(Table[Pos]<<1)^Polynomial;
+            else
+                Table[Pos]=Table[Pos]<<1;
+        }
+    }
+    return 0;
+}
+
+/* { dg-final { scan-tree-dump "Second operand of the xor statement isn't an integer constant.\n" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-10.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-10.c
new file mode 100644
index 00000000000..bc404abe35b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-10.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - protocol
+#include <stdint.h>
+#include <stddef.h>
+uint16_t crc16_mcrf4xx(uint16_t crc, uint8_t *data, size_t len) {
+    int i;
+
+    if (!data || !len)
+        return crc;
+
+    while (len--) {
+        crc ^= *data++;
+        for (i = 0; i < 8; i++) {
+            if (crc & 1)
+                crc = (crc >> 1) ^ 0x8408;
+            else
+                crc = (crc >> 1);
+        }
+    }
+
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-11.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-11.c
new file mode 100644
index 00000000000..b753b4e47d9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-11.c
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - slz
+#include <stdint.h>
+#include <stdio.h>
+uint32_t crc32_fast[4][256];
+void __slz_make_crc_table(void) {
+    uint32_t c;
+    int n, k;
+
+    for (n = 0; n < 256; n++) {
+        c = (uint32_t) n ^ 255;
+        for (k = 0; k < 8; k++) {
+            if (c & 1) {
+                c = 0xedb88320 ^ (c >> 1);
+            } else {
+                c = c >> 1;
+            }
+        }
+        crc32_fast[0][n] = c ^ 0xff000000;
+    }
+}
+
+int main ()
+{
+    __slz_make_crc_table();
+    printf ("%d", crc32_fast[0][0]);
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-12.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-12.c
new file mode 100644
index 00000000000..22d1d7a12e8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-12.c
@@ -0,0 +1,75 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+
+// File - wifi.  Sizeof check is added for the test.
+
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdio.h>
+typedef unsigned int u32;
+typedef unsigned char u8;
+u32 WIFI_CRC32Table[256];
+bool initialized;
+u32 reflect (u32 ref, char ch)
+{
+  if (sizeof (u32) < 4)
+    exit (0);
+
+  u32 value = 0;
+
+  for (int i = 1; i < (ch + 1); i++)
+    {
+      if (ref & 1)
+	value |= 1 << (ch - i);
+      ref >>= 1;
+    }
+
+  return value;
+}
+
+u32 WIFI_calcCRC32 (u8 *data, int len)
+{
+  if (sizeof (u32) < 4)
+    exit (0);
+
+  u32 crc = 0xFFFFFFFF;
+
+  while (len--)
+    crc = (crc >> 8) ^ WIFI_CRC32Table[(crc & 0xFF) ^ *data++];
+
+  return (crc ^ 0xFFFFFFFF);
+}
+
+void WIFI_initCRC32Table ()
+{
+  if (sizeof (u32) < 4)
+    exit (0);
+
+  initialized = false;
+  if (initialized) return;
+  initialized = true;
+
+  u32 polynomial = 0x04C11DB7;
+
+  for (int i = 0; i < 0x100; i++)
+    {
+      WIFI_CRC32Table[i] = reflect (i, 8) << 24;
+      for (int j = 0; j < 8; j++)
+	WIFI_CRC32Table[i] = (WIFI_CRC32Table[i] << 1)
+			     ^ (WIFI_CRC32Table[i] & (1 << 31) ? polynomial
+							       : 0);
+      WIFI_CRC32Table[i] = reflect (WIFI_CRC32Table[i], 32);
+    }
+}
+
+int main ()
+{
+  if (sizeof (u32) < 4)
+    exit (0);
+
+  WIFI_initCRC32Table ();
+  WIFI_calcCRC32 ("dfsf", 4);
+  printf ("%d", WIFI_CRC32Table[0]);
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-13.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-13.c
new file mode 100644
index 00000000000..c1247632ec1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-13.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// crc.ii, CRC16
+#include <stdio.h>
+typedef unsigned short u16;
+
+void GenerateCRC32Table(u16 polynomial, u16 *table)
+{
+  for (u16 i = 0; i <= 255; i++) {
+      u16 crc = i;
+      for (u16 j = 0; j < 8; j++) { // latch's next bb is loop header
+	  crc = (crc >> 1) ^ ((crc & 1) ? 0x2342 : 0);
+	}
+      table[i] = crc;
+    }
+}
+
+int main ()
+{
+  u16 table [256];
+  GenerateCRC32Table (0x4, table);
+  printf ("%d", table[0]);
+}
+
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-14.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-14.c
new file mode 100644
index 00000000000..148dc9616d9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-14.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+
+// File - base64, slightly modified
+// We don't support the case when leading bit of the polynomial is kept.
+
+#include <stdint.h>
+#include <stdlib.h>
+
+uint32_t b64crc (const unsigned char* data, size_t ns)
+{
+  if (sizeof (unsigned int) < 4)
+    exit (0);
+
+  const unsigned char *s = data;
+  uint32_t crc = 0xb704ceL;
+
+  while (ns-- > 0)
+    {
+      int i;
+      crc ^= (*s++) << 16;
+      for (i = 0; i < 8; i++)
+	{
+	  crc <<= 1;
+	  if (crc & 0x1000000)
+	    crc ^= 0x1864cfbL;
+	}
+    }
+  crc &= 0xffffff;
+  /* ... */
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*0\\\}" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-15.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-15.c
new file mode 100644
index 00000000000..a5b823c8b9c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-15.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - callerid
+
+unsigned short calc_crc(unsigned short crc, unsigned char data)
+{
+  unsigned int i, j, org, dst;
+  org = data;
+  dst = 0;
+
+  for (i = 0; i < 8; i++) {
+    org <<= 1;
+    dst >>= 1;
+    if (org & 0x100)
+      dst |= 0x80;
+  }
+  data = (unsigned char) dst;
+  crc ^= (unsigned int) data << (16 - 8);
+  for (j = 0; j < 8; j++) {
+    if (crc & 0x8000U)
+      crc = (crc << 1) ^ 0x1021U ;
+    else
+      crc <<= 1 ;
+  }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-16.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-16.c
new file mode 100644
index 00000000000..112b0cb7381
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-16.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - cc1541
+
+unsigned char
+crc8(unsigned char value)
+{
+  for (int i = 0; i < 8; ++i) {
+      value = (value & 0x80) ? ((value << 1) ^ 0x31) : (value << 1);
+    }
+
+  return value;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-17.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-17.c
new file mode 100644
index 00000000000..5aa534ab8e7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-17.c
@@ -0,0 +1,58 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+
+// File - crc.i.  Sizeof check is added for the test.
+// We don't support this case.
+
+#include <stdlib.h>
+#include <stdint.h>
+uint32_t crc24_calculate(uint32_t preset, const uint8_t *data, uint8_t len)
+{
+  uint32_t state = preset;
+  uint8_t i;
+
+  if (sizeof (state) <= 3 && sizeof (1) <= 3)
+    exit (0);
+
+  for (i = 0; i < len; i++) {
+      uint8_t n, cur = data[i];
+
+      for (n = 0; n < 8; n++) {
+	  int next_bit = (state ^ cur) & 1;
+
+	  cur >>= 1;
+	  state >>= 1;
+	  if (next_bit) {
+	      state |= 1 << 23;
+	      state ^= 0x5a6000;
+	    }
+	}
+    }
+
+  return state;
+}
+
+uint32_t crc24_reverse(uint32_t crc, const uint8_t *data, uint8_t len)
+{
+  uint32_t state = crc;
+  uint8_t i;
+
+  if (sizeof (state) <= 3 && sizeof (1) <= 3)
+    exit (0);
+
+  for (i = 0; i < len; i++) {
+      uint8_t n, cur = data[len - i - 1];
+
+      for (n = 0; n < 8; n++) {
+	  int top_bit = state >> 23;
+
+	  state = (state << 1) & 0xffffff;
+	  state |= top_bit ^ ((cur >> (7 - n)) & 1);
+	  if (top_bit)
+	    state ^= 0xb4c000;
+	}
+    }
+
+  return state;
+}
+/* { dg-final { scan-tree-dump-times "Polynomial's all bits are zeros or the size of the polynomial is uncertain." 2 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-18.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-18.c
new file mode 100644
index 00000000000..de25909d12a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-18.c
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+
+// File - cryptobonrrxternd.i
+// We don't support this case.
+
+unsigned char PGP_input[2*100];
+unsigned long crc24(int len) {
+
+  if (sizeof (long) < 4)
+    __builtin_exit (0);
+
+  long crc;
+  crc = 0xB704CE;
+  int i,j;
+  j = 0;
+  while (len--) {
+      crc ^= (PGP_input[j]) << 16;
+      j++;
+      for (i = 0; i < 8; i++) {
+	  crc <<= 1;
+	  if (crc & 0x1000000){
+	      crc ^= 0x1864CFB;
+	    }
+	}
+    }
+  return crc & 0xFFFFFF;
+}
+
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*0\\\}
+" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-19.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-19.c
new file mode 100644
index 00000000000..c2eb5d82b6b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-19.c
@@ -0,0 +1,61 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+
+// File - liboctasic_la-oct6100_chip_open
+// We don't support this case.
+
+typedef unsigned int UINT32;
+typedef UINT32 * PUINT32;
+typedef struct _OCT6100_INSTANCE_API_
+{
+
+   // tPOCT6100_SHARED_INFO pSharedInfo;
+
+    //PVOID pProcessContext;
+
+    //tOCT6100_USER_SERIAL_OBJECT ulApiSerObj;
+
+
+} tOCT6100_INSTANCE_API, *tPOCT6100_INSTANCE_API;
+
+UINT32 Oct6100ApiProductionCrc(
+    tPOCT6100_INSTANCE_API f_pApiInstance,
+    PUINT32 f_pulMessage,
+    UINT32 f_ulMessageLength,
+    PUINT32 f_pulCrcResult )
+{
+  if (sizeof (UINT32) < 4)
+    __builtin_exit (0);
+
+  UINT32 ulWidth = 32;
+  UINT32 ulKey, i, j;
+  UINT32 ulRemainder = 0;
+
+
+  ulRemainder = f_pulMessage[ f_ulMessageLength - 1 ];
+  for ( j = f_ulMessageLength - 1; j != 0xFFFFFFFF ; j-- )
+    {
+      for ( i = 0; i < ulWidth; i++ )
+	{
+	  if ( ( ( ulRemainder >> 0x1F ) & 0x1 ) == 0x1 )
+	    {
+	      ulKey = 0x8765DCBA;
+	    }
+	  else
+	    {
+	      ulKey = 0;
+	    }
+	  ulRemainder = ulRemainder ^ ulKey;
+
+	  ulRemainder = ulRemainder << 1;
+	  if ( j != 0 )
+	    {
+	      ulRemainder = ulRemainder | ( ( f_pulMessage[ j - 1 ] ) >> ( 0x1F - i ) );
+	    }
+	}
+    }
+
+  *f_pulCrcResult = ulRemainder;
+
+  return 0x00000000;
+}
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-2.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-2.c
new file mode 100644
index 00000000000..756bcd7db7b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-2.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -ftree-cselim" } */
+//File - Ac3 from Fedora, polynomial made const. Original crc-side-instr-21.c test
+#include <stddef.h>
+typedef unsigned short int16u;
+typedef unsigned char int8u;
+int CRC16_Init(int16u *Table)
+{
+    for (size_t Pos=0; Pos<256; Pos++)
+    {
+        Table[Pos]=(int16u)Pos<<8;
+
+        for(int8u bit=0; bit<8; bit++)
+        {
+            if (Table[Pos]&0x8000)
+                Table[Pos]=(Table[Pos]<<1)^0x2101;
+            else
+                Table[Pos]=Table[Pos]<<1;
+        }
+    }
+    return 0;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-20.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-20.c
new file mode 100644
index 00000000000..7995f99cd48
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-20.c
@@ -0,0 +1,45 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+// File - scorelayout.i
+
+#include <stdlib.h>
+typedef unsigned char guchar;
+typedef unsigned int guint32;
+guint32
+bit_reverse (guint32 x)
+{
+  x = ((x & 0x55555555) << 1) | ((x >> 1) & 0x55555555);
+  x = ((x & 0x33333333) << 2) | ((x >> 2) & 0x33333333);
+  x = ((x & 0x0F0F0F0F) << 4) | ((x >> 4) & 0x0F0F0F0F);
+  x = (x << 24) | ((x & 0xFF00) << 8) | ((x >> 8) & 0xFF00) | (x >> 24);
+  return x;
+}
+
+guint32
+crc32 (guchar * message)
+{
+  if (sizeof (int) < 4)
+    exit (0);
+
+  int i, j;
+  guint32 byte, crc;
+  i = 0;
+  crc = 0xFFFFFFFF;
+  while (message[i] != 0)
+    {
+      byte = message[i];
+      byte = bit_reverse (byte);
+      for (j = 0; j <= 7; j++)
+	{
+	  if ((int) (crc ^ byte) < 0)
+	    crc = (crc << 1) ^ 0x04C11DB7;
+	  else
+	    crc = crc << 1;
+	  byte = byte << 1;
+	}
+      i = i + 1;
+    }
+  return bit_reverse (~crc);
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-21.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-21.c
new file mode 100644
index 00000000000..432f6d38fd5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-21.c
@@ -0,0 +1,57 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - Unsafe_crc16.i
+
+long BGl_crczd2valuezd2zz__crc16z00(long BgL_valz00_4, long BgL_crcz00_5)
+{
+  {
+    {
+      long BgL_iz00_1796;
+      long BgL_valuez00_1797;
+      long BgL_crcz00_1798;
+
+      BgL_iz00_1796 = ((long) 0);
+      BgL_valuez00_1797 = (BgL_valz00_4 << (int) (((long) 8)));
+      BgL_crcz00_1798 = BgL_crcz00_5;
+      BgL_loopz00_1795:
+      if ((BgL_iz00_1796 == ((long) 8)))
+	{
+	  return BgL_crcz00_1798;
+	}
+      else
+	{
+	  long BgL_valuez00_1801;
+	  long BgL_crcz00_1802;
+
+	  BgL_valuez00_1801 = (BgL_valuez00_1797 << (int) (((long) 1)));
+	  BgL_crcz00_1802 = (BgL_crcz00_1798 << (int) (((long) 1)));
+	  {
+	    long BgL_crcz00_2209;
+	    long BgL_valuez00_2208;
+	    long BgL_iz00_2206;
+
+	    BgL_iz00_2206 = (BgL_iz00_1796 + ((long) 1));
+	    BgL_valuez00_2208 = BgL_valuez00_1801;
+	    if (
+		(((long) 0) ==
+		 (((long) 65536) & (BgL_crcz00_1802 ^ BgL_valuez00_1801))))
+	      {
+		BgL_crcz00_2209 = BgL_crcz00_1802;
+	      }
+	    else
+	      {
+		BgL_crcz00_2209 = (BgL_crcz00_1802 ^ ((long) 32773));
+	      }
+	    BgL_crcz00_1798 = BgL_crcz00_2209;
+	    BgL_valuez00_1797 = BgL_valuez00_2208;
+	    BgL_iz00_1796 = BgL_iz00_2206;
+	    goto BgL_loopz00_1795;
+	  }
+	}
+    }
+  }
+}
+
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\\}
+" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-22.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-22.c
new file mode 100644
index 00000000000..752c063982a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-22.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - crrcsim-LoggerReader_byte.ii
+// We don't support this case.
+
+int crcReg;
+enum { crcPoly = 49 };
+void crcByteSchritt(unsigned char data)
+{
+  for (int i=0; i<8; i++)
+    {
+      crcReg <<= 1;
+
+
+      if ((data & 0x80) != 0)
+	crcReg |= 1;
+
+      data <<= 1;
+
+      if ((crcReg & 0x100) != 0)
+	crcReg = crcReg ^ crcPoly;
+    }
+
+  crcReg &= 0xFF;
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-23.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-23.c
new file mode 100644
index 00000000000..c3ccc098e7b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-23.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - ModbusComm.ii
+
+#include <stdint.h>
+uint16_t ModbusCrc(const uint8_t *data, unsigned int sz)
+{
+  static const uint16_t MODBUS_CRC_POLY = 0xA001;
+  uint16_t crc = 0xffff;
+
+  while (sz--)
+    {
+      crc ^= *data++;
+      for (unsigned int i = 0; i < 8; ++i)
+	{
+	  if (crc & 0x1)
+	    crc = (crc >> 1) ^ MODBUS_CRC_POLY;
+	  else
+	    crc >>= 1;
+	}
+    }
+
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-24.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-24.c
new file mode 100644
index 00000000000..6b1acfbd389
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-24.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -ftree-cselim" } */
+
+// File - utils.ii
+/* We don't support the case when CRC variable's size is different from the
+   calculated CRC (I.e. in this case CRC 16 is calculated.)  */
+
+void crc_byte(const char data, unsigned int *crc16)
+{
+  int k;
+  unsigned c,d ;
+
+  c = data << 8 ;
+  d = c;
+
+  for (k = 0; k < 8; k++) {
+      *crc16 = (c & 0x8000) ^ *crc16;
+
+      if (*crc16 & 0x8000) {
+	  *crc16 = *crc16 << 1;
+	  *crc16 = *crc16 ^ 0x8005;
+	} else
+	*crc16 = *crc16 << 1;
+
+      d = d << 1;
+      c = d;
+    }
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-3.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-3.c
new file mode 100644
index 00000000000..8b61c55ca49
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-3.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+//File - as_format
+uint32_t crc32r(const uint8_t *data, uint32_t size)
+{
+
+    uint32_t crc = 0xffffffff;
+    for(uint32_t i=0; i != size; i++) {
+        crc = crc ^ data[i];
+        for(int j=0; j<8; j++)
+            if(crc & 1)
+                crc = (crc >> 1) ^ 0xedb88320;
+            else
+                crc = crc >> 1;
+    }
+    return ~crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-4.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-4.c
new file mode 100644
index 00000000000..60f3710a385
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-4.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// crc.ii
+typedef unsigned int u32;
+
+void GenerateCRC32Table (u32 polynomial, u32 *table)
+{
+  for (u32 i = 0; i <= 255; i++)
+    {
+      u32 crc = i;
+      for (u32 j = 0; j < 8; j++)
+	{
+	  crc = (crc >> 1) ^ ((crc & 1) ? 0x23428765 : 0);
+	}
+      table[i] = crc;
+    }
+}
+
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-5.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-5.c
new file mode 100644
index 00000000000..ec7947eebdb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-5.c
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// crc32.i
+// We don't support this case.
+
+#include <stddef.h>
+typedef unsigned int u32;
+u32 gf2_multiply(u32 x, u32 y, u32 modulus)
+{
+    u32 product = x & 1 ? y : 0;
+    int i;
+
+    for (i = 0; i < 31; i++) {
+        product = (product >> 1) ^ (product & 1 ? modulus : 0);
+        x >>= 1;
+        product ^= x & 1 ? y : 0;
+    }
+
+    return product;
+}
+
+u32 crc32_generic_shift(u32 crc, size_t len,
+                        u32 polynomial)
+{
+    u32 power = 0x2101;
+    int i;
+
+    for (i = 0; i < 8 * (int)(len & 3); i++)
+        crc = (crc >> 1) ^ (crc & 1 ? 0x2101 : 0);
+
+    len >>= 2;
+    if (!len)
+        return crc;
+
+    for (;;) {
+
+        if (len & 1)
+            crc = gf2_multiply(crc, power, polynomial);
+
+        len >>= 1;
+        if (!len)
+            break;
+
+
+        power = gf2_multiply(power, power, polynomial);
+    }
+
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump "Loop iteration number isn't a constant." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 30" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-6.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-6.c
new file mode 100644
index 00000000000..40621726a50
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-6.c
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// libmng_chunk_io
+typedef unsigned int mng_uint32;
+typedef signed int mng_int32;
+typedef signed char mng_int8;
+typedef mng_int8 mng_bool;
+typedef struct mng_data_struct {
+    // ...
+    mng_uint32 aCRCtable [256];
+    mng_bool bCRCcomputed;
+    // ...
+} mng_data;
+
+typedef mng_data * mng_datap;
+void make_crc_table (mng_datap pData)
+{
+    mng_uint32 iC;
+    mng_int32 iN, iK;
+
+    for (iN = 0; iN < 256; iN++)
+    {
+        iC = (mng_uint32) iN;
+
+        for (iK = 0; iK < 8; iK++)
+        {
+            if (iC & 1)
+                iC = 0xedb88320U ^ (iC >> 1);
+            else
+                iC = iC >> 1;
+        }
+
+        pData->aCRCtable [iN] = iC;
+    }
+
+    pData->bCRCcomputed = 1;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-7.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-7.c
new file mode 100644
index 00000000000..aeed228647f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-7.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+// File - lsf_decode, modified.
+// We don't support this case.
+
+#include <stddef.h>
+#include <stdint.h>
+
+uint16_t crc(uint8_t byte, uint16_t reg) {
+    for (size_t i = 0; i != 8; ++i) {
+        uint16_t msb = reg & 0x8000;
+        reg = ((reg << 1) & 0xFFFF) | ((byte >> (7 - i)) & 0x0001);
+        if (msb) reg ^= 0x5935;
+    }
+    return reg & 0xFFFF;
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-8.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-8.c
new file mode 100644
index 00000000000..0e23db7d445
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-8.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stddef.h>
+// File - misc
+uint32_t _crc32(uint32_t crc, uint32_t data) {
+    int i;
+    crc = crc ^ data;
+
+    for (i = 0; i < 32; i++) {
+        if (crc & 0x80000000)
+            crc = (crc << 1) ^ 0x04C11DB7;
+        else
+            crc = (crc << 1);
+    }
+
+    return crc;
+}
+
+uint32_t stm_crc32(const uint8_t *data, size_t size) {
+    uint32_t crc = 0xffffffff;
+    const uint32_t *pend = (const uint32_t *) (data + size);
+    for (const uint32_t *p = (const uint32_t *) (data); p < pend; p++)
+        crc = _crc32(crc, *p);
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 2 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-from-fedora-packages-9.c b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-9.c
new file mode 100644
index 00000000000..d946f561d34
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-from-fedora-packages-9.c
@@ -0,0 +1,48 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+
+// File - nvme_mi
+#include <stdlib.h>
+typedef unsigned int __u32;
+typedef unsigned char __u8;
+struct nvme_mi_msg_hdr {
+    __u8 type;
+    __u8 nmp;
+    __u8 meb;
+    __u8 rsvd0;
+} __attribute__((packed));
+
+struct nvme_mi_req {
+    struct nvme_mi_msg_hdr *hdr;
+    size_t hdr_len;
+    void *data;
+    size_t data_len;
+    __u32 mic;
+};
+__u32 nvme_mi_crc32_update (__u32 crc, void *data, size_t len)
+{
+  int i;
+
+  while (len--)
+    {
+      crc ^= *(unsigned char *) (data++);
+      for (i = 0; i < 8; i++)
+	crc = (crc >> 1) ^ ((crc & 1) ? 0x82F63B78 : 0);
+    }
+  return crc;
+}
+
+void nvme_mi_calc_req_mic (struct nvme_mi_req *req)
+{
+  if (sizeof (__u32) < 4)
+    exit (0);
+
+  __u32 crc = 0xffffffff;
+
+  crc = nvme_mi_crc32_update (crc, req->hdr, req->hdr_len);
+  crc = nvme_mi_crc32_update (crc, req->data, req->data_len);
+
+  req->mic = ~crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-linux-1.c b/gcc/testsuite/gcc.dg/crc-linux-1.c
new file mode 100644
index 00000000000..f85e4fd12f0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-linux-1.c
@@ -0,0 +1,43 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+#include <stdlib.h>
+#define CRC32_POLY_BE 0x04c11db7
+#define RETVAL_OUT_OF_MEMORY		(-6)
+#define RETVAL_NOT_BZIP_DATA		(-2)
+#define RETVAL_OK			0
+
+struct bunzip_data {
+    unsigned int crc32Table[256];
+};
+
+
+int start_bunzip(struct bunzip_data **bdp, void *inbuf, long len,
+			     long (*fill)(void*, unsigned long))
+{
+  if (sizeof (unsigned int) <= 3)
+    exit (0);
+
+  struct bunzip_data *bd;
+  unsigned int i, j, c;
+
+  /* Figure out how much data to allocate */
+  i = sizeof(struct bunzip_data);
+
+  /* Allocate bunzip_data.  Most fields initialize to zero. */
+  bd = *bdp = malloc(i);
+
+  /* ... */
+
+  /* Init the CRC32 table (big endian) */
+  for (i = 0; i < 256; i++) {
+      c = i << 24;
+      for (j = 8; j; j--)
+	c = c&0x80000000 ? (c << 1)^(CRC32_POLY_BE) : (c << 1);
+      bd->crc32Table[i] = c;
+    }
+
+  /* . . . */
+  return RETVAL_OK;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-linux-2.c b/gcc/testsuite/gcc.dg/crc-linux-2.c
new file mode 100644
index 00000000000..bb346fb5f88
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-linux-2.c
@@ -0,0 +1,64 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+#include <stddef.h>
+typedef unsigned char  u8;
+typedef unsigned short u16;
+typedef unsigned char __u8;
+typedef unsigned short __u16;
+struct i2c_msg {
+    __u16 addr;
+    __u16 flags;
+#define I2C_M_RD                0x0001  /* guaranteed to be 0x0001! */
+    /* ... */
+    __u16 len;
+    __u8 *buf;
+};
+
+#define POLY    (0x1070U << 3)
+static u8 crc8(u16 data)
+{
+  int i;
+
+  for (i = 0; i < 8; i++) {
+      if (data & 0x8000)
+	data = data ^ POLY;
+      data = data << 1;
+    }
+  return (u8)(data >> 8);
+}
+
+/**
+* i2c_smbus_pec - Incremental CRC8 over the given input data array
+* @crc: previous return crc8 value
+* @p: pointer to data buffer.
+* @count: number of bytes in data buffer.
+*
+* Incremental CRC8 over count bytes in the array pointed to by p
+*/
+u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)
+{
+  int i;
+
+  for (i = 0; i < count; i++)
+    crc = crc8((crc ^ p[i]) << 8);
+  return crc;
+}
+static inline u8 i2c_8bit_addr_from_msg(const struct i2c_msg *msg)
+{
+  return (msg->addr << 1) | (msg->flags & I2C_M_RD ? 1 : 0);
+}
+
+
+/* Assume a 7-bit address, which is reasonable for SMBus */
+u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)
+{
+  /* The address will be sent first */
+  u8 addr = i2c_8bit_addr_from_msg(msg);
+  pec = i2c_smbus_pec(pec, &addr, 1);
+
+  /* The data buffer follows */
+  return i2c_smbus_pec(pec, msg->buf, msg->len);
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-linux-3.c b/gcc/testsuite/gcc.dg/crc-linux-3.c
new file mode 100644
index 00000000000..301f6d22b65
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-linux-3.c
@@ -0,0 +1,49 @@
+/* We don't find this case because in "crc32_generic_shift" function
+   loop's iteration number isn't a constant (i < 8 * (int)(len & 3)).  */
+
+#include <stddef.h>
+typedef unsigned int u32;
+#define __attribute_const__	__attribute__((__const__))
+static u32 __attribute_const__ gf2_multiply (u32 x, u32 y, u32 modulus)
+{
+  u32 product = x & 1 ? y : 0;
+  int i;
+
+  for (i = 0; i < 31; i++)
+    {
+      product = (product >> 1) ^ (product & 1 ? modulus : 0);
+      x >>= 1;
+      product ^= x & 1 ? y : 0;
+    }
+  return product;
+}
+
+u32 __attribute_const__ crc32_generic_shift(u32 crc, size_t len,
+                                                  u32 polynomial)
+{
+       u32 power = polynomial; /* CRC of x^32 */
+       int i;
+
+       /* Shift up to 32 bits in the simple linear way */
+       for (i = 0; i < 8 * (int)(len & 3); i++)
+               crc = (crc >> 1) ^ (crc & 1 ? polynomial : 0);
+
+       len >>= 2;
+       if (!len)
+               return crc;
+
+       for (;;) {
+               /* "power" is x^(2^i), modulo the polynomial */
+               if (len & 1)
+                       crc = gf2_multiply(crc, power, polynomial);
+
+               len >>= 1;
+               if (!len)
+                       break;
+
+               /* Square power, advancing to x^(2^(i+1)) */
+               power = gf2_multiply(power, power, polynomial);
+       }
+
+       return crc;
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-linux-4.c b/gcc/testsuite/gcc.dg/crc-linux-4.c
new file mode 100644
index 00000000000..ad3b15bcd84
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-linux-4.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details -w" } */
+
+/* We don't detect, it's optimized to branch-less CRC.  */
+#define CRC32_POLY_LE 0xedb88320
+typedef unsigned int u32;
+u32 calc_crc(unsigned char *buf, int len)
+{
+  u32 reg;
+  u32 tmp;
+  int j, k;
+
+  reg = 0xffffffff;
+
+  for (j = 0; j < len; j++) {
+      reg ^= buf[j];
+
+      for (k = 0; k < 8; k++) {
+	  tmp = reg & 0x01;
+
+	  reg >>= 1;
+
+	  if (tmp)
+	    reg ^= CRC32_POLY_LE;
+	}
+    }
+
+  return ~reg;
+}
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-linux-5.c b/gcc/testsuite/gcc.dg/crc-linux-5.c
new file mode 100644
index 00000000000..f29eebd6e53
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-linux-5.c
@@ -0,0 +1,79 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+#include <stddef.h>
+#include <stdint.h>
+/* We don't find, as we can't replace the first loop,
+   and in the second loop polynomials leading 1 bit is kept too
+   (second function's iteration count is 4).  */
+typedef unsigned char  u8;
+typedef unsigned short u16;
+u8 drm_dp_msg_data_crc4(const uint8_t *data, u8 number_of_bytes)
+{
+  u8 bitmask = 0x80;
+  u8 bitshift = 7;
+  u8 array_index = 0;
+  int number_of_bits = number_of_bytes * 8;
+  u16 remainder = 0;
+
+  while (number_of_bits != 0) {
+      number_of_bits--;
+      remainder <<= 1;
+      remainder |= (data[array_index] & bitmask) >> bitshift;
+      bitmask >>= 1;
+      bitshift--;
+      if (bitmask == 0) {
+	  bitmask = 0x80;
+	  bitshift = 7;
+	  array_index++;
+	}
+      if ((remainder & 0x100) == 0x100)
+	remainder ^= 0xd5;
+    }
+
+  number_of_bits = 8;
+  while (number_of_bits != 0) {
+      number_of_bits--;
+      remainder <<= 1;
+      if ((remainder & 0x100) != 0)
+	remainder ^= 0xd5;
+    }
+
+  return remainder & 0xff;
+}
+
+/* sideband msg handling */
+u8 drm_dp_msg_header_crc4(const uint8_t *data, size_t num_nibbles)
+{
+  u8 bitmask = 0x80;
+  u8 bitshift = 7;
+  u8 array_index = 0;
+  int number_of_bits = num_nibbles * 4;
+  u8 remainder = 0;
+
+  while (number_of_bits != 0) {
+      number_of_bits--;
+      remainder <<= 1;
+      remainder |= (data[array_index] & bitmask) >> bitshift;
+      bitmask >>= 1;
+      bitshift--;
+      if (bitmask == 0) {
+	  bitmask = 0x80;
+	  bitshift = 7;
+	  array_index++;
+	}
+      if ((remainder & 0x10) == 0x10)
+	remainder ^= 0x13;
+    }
+
+  number_of_bits = 4;
+  while (number_of_bits != 0) {
+      number_of_bits--;
+      remainder <<= 1;
+      if ((remainder & 0x10) != 0)
+	remainder ^= 0x13;
+    }
+
+  return remainder;
+}
+
+/* { dg-final { scan-tree-dump "drm_dp_msg_data_crc4 function maybe contains CRC calculation." "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-1.c b/gcc/testsuite/gcc.dg/crc-not-crc-1.c
new file mode 100644
index 00000000000..bac7e934736
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-1.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+//loop iteration number is 5
+ee_u16 not_crcu8 (ee_u8 data, ee_u16 crc) {
+    ee_u8 i = 0, x16 = 0, carry = 0;
+    for (i = 0; i < 5; i++) {
+        x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+        data >>= 1;
+        if (x16 == 1) {
+            crc ^= 0x4002;
+            carry = 1;
+        } else
+            carry = 0;
+        crc >>= 1;
+        if (carry)
+            crc |= 0x8000;
+        else
+            crc &= 0x7fff;
+    }
+    return crc;
+}
+/* { dg-final { scan-tree-dump-times "crcu8 function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-10.c b/gcc/testsuite/gcc.dg/crc-not-crc-10.c
new file mode 100644
index 00000000000..2351fe8fce6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-10.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+//Spoiled crc value
+uint16_t not_crc(uint16_t crc, uint8_t a) {
+    int i;
+    crc ^= a;
+    for (i = 0; i < 8; ++i) {
+        if (crc & 1) {
+            crc = 0;
+            crc = (crc << 1) ^ 0xA001;
+        }
+        else
+            crc = crc >> 1;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-11.c b/gcc/testsuite/gcc.dg/crc-not-crc-11.c
new file mode 100644
index 00000000000..04bf753ae73
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-11.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+ee_u16 not_crc(ee_u8 data, ee_u16 crc) {
+    ee_u8 i = 0, carry = 0;
+    for (i = 0; i < 8; i++) {
+        data >>= 1;
+        if (data == 1) {
+            crc ^= 0x4002;
+            carry = 1;
+        } else
+            carry = 0;
+        crc >>= 1;
+        if (carry)
+            crc |= 0x8000;
+        else
+            crc &= 0x7fff;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-12.c b/gcc/testsuite/gcc.dg/crc-not-crc-12.c
new file mode 100644
index 00000000000..b49ba752e58
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-12.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+    uint8_t i;
+    crc = crc ^ data;
+    for (i = 0; i < 8; i++) {
+        if (data & 0x01)
+            crc = (crc >> 1) ^ 0x8C;
+        else
+            crc >>= 1;
+    }
+    return crc;
+}
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-13.c b/gcc/testsuite/gcc.dg/crc-not-crc-13.c
new file mode 100644
index 00000000000..0a328e1cff6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-13.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  uint8_t i;
+  crc = crc ^ data;
+  for (i = 0; i < 8; i++) {
+      if (crc & 0x01)
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+      if (i > 1)
+	crc = 8;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-14.c b/gcc/testsuite/gcc.dg/crc-not-crc-14.c
new file mode 100644
index 00000000000..c2d86f441ef
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-14.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  crc = crc ^ data;
+
+  for (uint8_t i = 0, n = 0; i < 8; i++, n++) {
+      if (data > i)
+	crc = 8;
+      if (crc & 0x01)
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-15.c b/gcc/testsuite/gcc.dg/crc-not-crc-15.c
new file mode 100644
index 00000000000..cdfda5002ff
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-15.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  crc = crc ^ data;
+
+  for (uint8_t i = 0, n = 0; i < 8; i++, n++) {
+      if ((crc & 0x01) && data)
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-16.c b/gcc/testsuite/gcc.dg/crc-not-crc-16.c
new file mode 100644
index 00000000000..8a114c29ccb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-16.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  uint8_t i;
+  crc = crc ^ data;
+  for (i = 0; i < 8; i++) {
+      if (!i && (crc & 0x01))
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-17.c b/gcc/testsuite/gcc.dg/crc-not-crc-17.c
new file mode 100644
index 00000000000..94a09b73d36
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-17.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  uint8_t i;
+  crc = crc ^ data;
+  for (i = 0; i < 8; i++) {
+      if (i && (crc & 0x01))
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-18.c b/gcc/testsuite/gcc.dg/crc-not-crc-18.c
new file mode 100644
index 00000000000..2484b37fcd5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-18.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  uint8_t i;
+  crc = crc ^ data;
+  for (i = 0; i < 8; i++) {
+      if ((crc & 0x01) && i==0)
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-19.c b/gcc/testsuite/gcc.dg/crc-not-crc-19.c
new file mode 100644
index 00000000000..45307e1b9fc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-19.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  uint8_t i;
+  crc = crc ^ data;
+  for (i = 0; i < 8; i++) {
+      if ((crc & 0x01) || i==0)
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-2.c b/gcc/testsuite/gcc.dg/crc-not-crc-2.c
new file mode 100644
index 00000000000..95fc2c707e2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-2.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+typedef uint8_t crc;
+#define TOPBIT (1 << 7)
+
+//shift not by one
+crc
+notCrc(uint8_t const message[], int nBytes) {
+    crc remainder = 0;
+    for (int byte = 0; byte < nBytes; ++byte) {
+        remainder ^= message[byte] ;
+        for (uint8_t bit = 8; bit > 0; --bit) {
+            if (remainder & TOPBIT) {
+                remainder = (remainder << 3) ^ 1234;
+            } else {
+                remainder = (remainder << 9);
+            }
+        }
+    }
+    return (remainder);
+}
+
+/* { dg-final { scan-tree-dump-times "notCrc function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-20.c b/gcc/testsuite/gcc.dg/crc-not-crc-20.c
new file mode 100644
index 00000000000..67f950c3a8c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-20.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint8_t not_crc(uint8_t crc, uint8_t data) {
+  uint8_t i;
+  crc = crc ^ data;
+  for (i = 0; i < 8; i++) {
+      if (i == 0 || (crc & 0x01))
+	crc = (crc >> 1) ^ 0x8C;
+      else
+	crc >>= 1;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-21.c b/gcc/testsuite/gcc.dg/crc-not-crc-21.c
new file mode 100644
index 00000000000..8b9711e49df
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-21.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint8_t data, uint16_t crc) {
+  uint8_t i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      x16 = (uint8_t)((data & 128) ^ ((uint8_t) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-22.c b/gcc/testsuite/gcc.dg/crc-not-crc-22.c
new file mode 100644
index 00000000000..c5713a7a652
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-22.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint8_t data, uint16_t crc) {
+  uint8_t i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      x16 = (uint8_t) ((data & 2) ^ ((uint8_t) crc & 2));
+      data >>= 1;
+      if (x16 == 2) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-23.c b/gcc/testsuite/gcc.dg/crc-not-crc-23.c
new file mode 100644
index 00000000000..2db3927e075
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-23.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint8_t data, uint16_t crc) {
+  uint8_t i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      x16 = (uint8_t) ((data & 1) ^ ((uint8_t) crc & 1)  ^ (i & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-24.c b/gcc/testsuite/gcc.dg/crc-not-crc-24.c
new file mode 100644
index 00000000000..e4299e7fb00
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-24.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint8_t data, uint16_t crc) {
+  uint8_t i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      x16 = (uint8_t) (((uint8_t) crc & 1)  ^ (i & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-25.c b/gcc/testsuite/gcc.dg/crc-not-crc-25.c
new file mode 100644
index 00000000000..274f54bde6a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-25.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint8_t *data, uint16_t crc) {
+  uint8_t x16 = 0, carry = 0;
+  for (uint8_t i = 0, j=4; i < 8; i++, j+=2) {
+      x16 = (uint8_t) (((uint8_t) crc & 1)  ^ (j & 1));
+      *data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-26.c b/gcc/testsuite/gcc.dg/crc-not-crc-26.c
new file mode 100644
index 00000000000..989c8cdfb79
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-26.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t not_crcu8 (uint8_t data, uint16_t crc) {
+  uint8_t x16 = 0, carry = 0;
+  for (uint8_t i = 0, j=3; i < 8; i++, j+=2) {
+      x16 = (uint8_t) (((uint8_t) crc & 1)  ^ (j & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-3.c b/gcc/testsuite/gcc.dg/crc-not-crc-3.c
new file mode 100644
index 00000000000..921f8152914
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-3.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+//no shift in case of xor
+uint16_t not_crc16_update(uint16_t crc, uint8_t a) {
+	
+    int i;
+    crc ^= a;
+    for (i = 0; i < 8; ++i) {
+        if (crc & 1)
+            crc = crc ^ 0xA001;
+        else
+            crc = (crc >> 1);
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc16_update function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-4.c b/gcc/testsuite/gcc.dg/crc-not-crc-4.c
new file mode 100644
index 00000000000..62fbe9c480e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-4.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+//shift and xor only if lsb is 1
+uint16_t not_crc(uint16_t crc, uint8_t a) {
+    int i;
+    crc ^= a;
+    for (i = 0; i < 8; ++i) {
+        if (crc & 1)
+            crc = (crc >> 1) ^ 0xA001;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-5.c b/gcc/testsuite/gcc.dg/crc-not-crc-5.c
new file mode 100644
index 00000000000..9456be0d330
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-5.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdio.h>
+
+typedef unsigned char uint8_t;
+
+//no xor
+uint8_t not_crc(uint8_t *data, size_t len) {
+    uint8_t crc = 0xff;
+    size_t i, j;
+    for (i = 0; i < len; i++) {
+        crc ^= data[i];
+        for (j = 0; j < 8; j++) {
+            if ((crc & 0x80) != 0)
+                crc = (uint8_t) ((crc << 1) | 0x31);
+            else
+                crc <<= 1;
+        }
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
+
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-6.c b/gcc/testsuite/gcc.dg/crc-not-crc-6.c
new file mode 100644
index 00000000000..c5d23496467
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-6.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+#define POLY (0x1070U << 3)
+#define u8 uint8_t
+#define u16 uint16_t
+
+//xor in case 0
+u8 not_crc(u16 data) {
+    int i;
+    for (i = 0; i < 8; i++) {
+        if (data & 0x0000)
+            data = data ^ POLY;
+        data = data << 1;
+    }
+    return (u8)(data >> 8);
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
+
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-7.c b/gcc/testsuite/gcc.dg/crc-not-crc-7.c
new file mode 100644
index 00000000000..a6f7e6a8b68
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-7.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+//in one case is called shift left, in another shift right
+uint16_t not_crc(uint16_t crc, uint8_t a) {
+    int i;
+    crc ^= a;
+    for (i = 0; i < 8; ++i) {
+        if (crc & 1)
+            crc = (crc << 1) ^ 0xA001;
+        else
+            crc = crc >> 1;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-8.c b/gcc/testsuite/gcc.dg/crc-not-crc-8.c
new file mode 100644
index 00000000000..5898e423a4e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-8.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+
+//xor is done in case lsb is 0
+int16_t not_crc(int16_t crc, int8_t a) {
+    int i;
+    crc ^= a;
+    for (i = 0; i < 8; ++i) {
+        if (crc << 15 == 0)
+            crc = (crc >> 1) ^ 0xA001;
+        else
+            crc = crc >> 1;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-not-crc-9.c b/gcc/testsuite/gcc.dg/crc-not-crc-9.c
new file mode 100644
index 00000000000..b97204ae09c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-not-crc-9.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc" } */
+
+#include <stdint.h>
+//no conditional xor
+uint16_t not_crc(uint16_t crc, uint8_t a) {
+    int i;
+    crc ^= a;
+    for (i = 0; i < 8; ++i) {
+            crc = (crc << 1) ^ 0xA001;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "not_crc function maybe contains CRC calculation" 0 "crc"} } */
+
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-1.c b/gcc/testsuite/gcc.dg/crc-side-instr-1.c
new file mode 100644
index 00000000000..18068cd0a89
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-1.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t crc16_update (uint16_t crc, uint8_t a)
+{
+  int i;
+  for (i = 0; i < 8; ++i)
+    {
+      int b;
+      if ((crc & 1) ^ (a & 1))
+	crc = (crc >> 1) ^ 0xa001;
+      else
+	crc = (crc >> 1);
+      a >>= 1;
+      b = crc; // Unused instruction, this is safe to remove.
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "crc16_update function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-10.c b/gcc/testsuite/gcc.dg/crc-side-instr-10.c
new file mode 100644
index 00000000000..f99244eff69
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-10.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+  ee_u16 i = 0, x16 = 0, carry = 0;
+  int a = 1;
+  for (i = 0; i < 8; i++) {
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      a = a * (crc + 5);
+      if (carry)
+	{
+	  crc |= 0x8000;
+	}
+      else
+	crc &= 0x7fff;
+    }
+  return a;
+}
+
+/* { dg-final { scan-tree-dump "Output CRC and determined input CRC differ." "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-11.c b/gcc/testsuite/gcc.dg/crc-side-instr-11.c
new file mode 100644
index 00000000000..15601e17f0d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-11.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+  ee_u16 i = 0, x16 = 0, carry = 0;
+  int a = 1;
+  for (i = 0; i < 8; i++) {
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      a = a * (crc + 5);
+      if (carry)
+	{
+	  crc |= 0x8000;
+	}
+      else
+	crc &= 0x7fff;
+    }
+  return a + crc;
+}
+
+/* { dg-final { scan-tree-dump "There is more than one output phi." "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-12.c b/gcc/testsuite/gcc.dg/crc-side-instr-12.c
new file mode 100644
index 00000000000..147ad60d3a0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-12.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int a;
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+  ee_u16 i = 0, x16 = 0, carry = 0;
+  int c;
+  for (i = 0; i < 8; i++) {
+      c += i*2; // In compiled code, it is moved outside of the loop.
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      a = c;
+      if (carry)
+	{
+	  crc |= 0x8000;
+	}
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-13.c b/gcc/testsuite/gcc.dg/crc-side-instr-13.c
new file mode 100644
index 00000000000..24f1483e0df
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-13.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int a;
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+    ee_u16 i = 0, x16 = 0, carry = 0;
+    int c;
+    for (i = 0; i < 8; i++) {
+        c += crc * 2;
+        x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+        data >>= 1;
+        if (x16 == 1) {
+            crc ^= 0x4002;
+            carry = 1;
+        } else
+            carry = 0;
+        crc >>= 1;
+        a = c;
+        if (carry) {
+            crc |= 0x8000;
+        } else
+            crc &= 0x7fff;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump "There is more than one output phi." "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-14.c b/gcc/testsuite/gcc.dg/crc-side-instr-14.c
new file mode 100644
index 00000000000..e9e8077810a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-14.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdio.h>
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int a;
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+    ee_u16 i = 0, x16 = 0, carry = 0;
+    int c;
+    for (i = 0; i < 8; i++) {
+        c += i*2;
+        printf ("%d", c);
+        x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+        data >>= 1;
+        if (x16 == 1) {
+            crc ^= 0x4002;
+            carry = 1;
+        } else
+            carry = 0;
+        crc >>= 1;
+        a = c;
+        if (carry)
+        {
+            crc |= 0x8000;
+        }
+        else
+            crc &= 0x7fff;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-15.c b/gcc/testsuite/gcc.dg/crc-side-instr-15.c
new file mode 100644
index 00000000000..189eb4c4f76
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-15.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int foo (int c)
+{
+    return c*c;
+}
+
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+    ee_u16 i = 0, x16 = 0, carry = 0;
+    int c;
+    for (i = 0; i < 8; i++) {
+        c += i*2;
+        c = foo (c); // All calculations related to c are removed.
+        x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+        data >>= 1;
+        if (x16 == 1) {
+            crc ^= 0x4002;
+            carry = 1;
+        } else
+            carry = 0;
+        crc >>= 1;
+        if (carry)
+        {
+            crc |= 0x8000;
+        }
+        else
+            crc &= 0x7fff;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-16.c b/gcc/testsuite/gcc.dg/crc-side-instr-16.c
new file mode 100644
index 00000000000..c54a8fe86b5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-16.c
@@ -0,0 +1,37 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+__attribute__ ((noinline,noipa))
+int foo (int c)
+{
+    return c*c;
+}
+
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+    ee_u16 i = 0, x16 = 0, carry = 0;
+    int c;
+    for (i = 0; i < 8; i++) {
+        c += i*2;
+        c = foo (c); //Warning, encountered unsupported statement, while executing gimple statements!
+        x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+        data >>= 1;
+        if (x16 == 1) {
+            crc ^= 0x4002;
+            carry = 1;
+        } else
+            carry = 0;
+        crc >>= 1;
+        if (carry)
+        {
+            crc |= 0x8000;
+        }
+        else
+            crc &= 0x7fff;
+    }
+    return crc;
+}
+
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-17.c b/gcc/testsuite/gcc.dg/crc-side-instr-17.c
new file mode 100644
index 00000000000..a48d19407ef
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-17.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int foo (int c)
+{
+    return c*c;
+}
+
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+    ee_u16 i = 0, x16 = 0, carry = 0;
+    int c;
+    for (i = 0; i < 8; i++) {
+        c += i*2;
+        c = foo (c);
+        x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+        data >>= 1;
+        if (x16 == 1) {
+            crc ^= 0x4002;
+            carry = 1;
+        } else
+            carry = 0;
+        crc >>= 1;
+        if (carry)
+        {
+            crc |= 0x8000;
+        }
+        else
+            crc &= 0x7fff;
+    }
+    return crc + c;
+}
+
+/* { dg-final { scan-tree-dump "There is more than one output phi." "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-2.c b/gcc/testsuite/gcc.dg/crc-side-instr-2.c
new file mode 100644
index 00000000000..5d51a8b4447
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-2.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdio.h>
+
+uint16_t crc16_update(uint16_t crc, uint8_t a) {
+  int i;
+  int b;
+  for (i = 0; i < 8; ++i) {
+      if ((crc & 1) ^ (a & 1))
+	crc = (crc >> 1) ^ 0xa001;
+      else
+	crc = (crc >> 1);
+      a >>= 1;
+      b = crc; // Unused instruction, this is safe to remove.
+    }
+    printf ("%d", b);
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "crc16_update function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-3.c b/gcc/testsuite/gcc.dg/crc-side-instr-3.c
new file mode 100644
index 00000000000..177174221a6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-3.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t crc16_update(uint16_t crc, uint8_t a) {
+  int i;
+  int b;
+  for (i = 0; i < 8; ++i) {
+      if ((crc & 1) ^ (a & 1))
+	crc = (crc >> 1) ^ 0xa001;
+      else
+	crc = (crc >> 1);
+      a >>= 1;
+      b = crc;
+    }
+  int c = b; // This is removed from the compiled code.
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "crc16_update function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-4.c b/gcc/testsuite/gcc.dg/crc-side-instr-4.c
new file mode 100644
index 00000000000..37dc5d1679b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-4.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t crc16_update(uint16_t crc, uint8_t a) {
+  int i;
+  uint16_t b;
+  for (i = 0; i < 8; ++i) {
+      if ((crc & 1) ^ (a & 1))
+	crc = (crc >> 1) ^ 0xa001;
+      else
+	crc = (crc >> 1);
+      a >>= 1;
+      b = crc;
+    }
+  uint16_t c = b++; // This is removed from the compiled code.
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "crc16_update function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-5.c b/gcc/testsuite/gcc.dg/crc-side-instr-5.c
new file mode 100644
index 00000000000..bb2c5cd3b9b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-5.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+
+uint16_t crc16_update(uint16_t crc, uint8_t a) {
+  int i;
+  uint16_t b;
+  for (i = 0; i < 8; ++i) {
+      if ((crc & 1) ^ (a & 1))
+	crc = (crc >> 1) ^ 0xa001;
+      else
+	crc = (crc >> 1);
+      a >>= 1;
+      b = crc; // In compiled version, b is outside of the loop.
+    }
+  uint16_t c = ++b;
+  return c;
+}
+
+/* { dg-final { scan-tree-dump "crc16_update function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-6.c b/gcc/testsuite/gcc.dg/crc-side-instr-6.c
new file mode 100644
index 00000000000..53aa9786a81
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-6.c
@@ -0,0 +1,41 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdint.h>
+#include <stdio.h>
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int a;
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+  ee_u8 i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      a++; // this is moved outside of the loop
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+int main()
+{
+  printf ("%04X\n", crcu8 (0, 0xaa));
+  printf ("%d", a);
+}
+
+
+/* { dg-final { scan-tree-dump "crcu8 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump "Polynomial's value is \\\{\[0, \]*1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\\\}" "crc" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-7.c b/gcc/testsuite/gcc.dg/crc-side-instr-7.c
new file mode 100644
index 00000000000..12764c9387c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-7.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdio.h>
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int a[10] = {};
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+  ee_u8 i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      a[i] = crc;
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+int main()
+{
+  printf ("%04X\n", crcu8 (0, 0xaa));
+  printf ("%d", a[0]);
+}
+
+
+/* { dg-final { scan-tree-dump "crcu8 function maybe contains CRC calculation." "crc"} } */
+/* { dg-final { scan-tree-dump "Loop iteration number is 7" "crc"} } */
+/* { dg-final { scan-tree-dump "Bit reversed" "crc"} } */
+/* { dg-final { scan-tree-dump-times "calculates CRC!" 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-8.c b/gcc/testsuite/gcc.dg/crc-side-instr-8.c
new file mode 100644
index 00000000000..921f439f03c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-8.c
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+#include <stdio.h>
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int a;
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+  ee_u8 i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      a += crc; // Defined variable is used outside the loop.
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	crc |= 0x8000;
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+int main()
+{
+  printf ("%04X\n", crcu8 (0, 0xaa));
+  printf ("%d", a);
+}
+
+/* { dg-final { scan-tree-dump "There is more than one output phi." "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/crc-side-instr-9.c b/gcc/testsuite/gcc.dg/crc-side-instr-9.c
new file mode 100644
index 00000000000..6f6f7dd39aa
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/crc-side-instr-9.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-crc-details" } */
+
+typedef unsigned short ee_u16;
+typedef unsigned char ee_u8;
+
+int a;
+ee_u16 crcu8 (ee_u8 data, ee_u16 crc) {
+  ee_u8 i = 0, x16 = 0, carry = 0;
+  for (i = 0; i < 8; i++) {
+      x16 = (ee_u8) ((data & 1) ^ ((ee_u8) crc & 1));
+      data >>= 1;
+      if (x16 == 1) {
+	  crc ^= 0x4002;
+	  carry = 1;
+	} else
+	carry = 0;
+      crc >>= 1;
+      if (carry)
+	{
+	  a = crc;
+	  crc |= 0x8000;
+	}
+      else
+	crc &= 0x7fff;
+    }
+  return crc;
+}
+
+/* { dg-final { scan-tree-dump "There is more than one output phi." "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c
new file mode 100644
index 00000000000..aa0a06ccb81
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-1-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-1.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c
new file mode 100644
index 00000000000..27c4fee0c58
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-10-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-10.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c
new file mode 100644
index 00000000000..46978f1063b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-12-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details -fdisable-tree-phiopt2 -fdisable-tree-phiopt3" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-12.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c
new file mode 100644
index 00000000000..8e873455342
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-13-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-13.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c
new file mode 100644
index 00000000000..108801ac50d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-14-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-14.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c
new file mode 100644
index 00000000000..7b1bcfc1711
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-17-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-17.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c
new file mode 100644
index 00000000000..13e23451427
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-18-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-18.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-21-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-21-zbc.c
new file mode 100644
index 00000000000..5028164c974
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-21-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-21.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-rv64-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-22-rv64-zbc.c
new file mode 100644
index 00000000000..ce91e32f971
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-rv64-zbc.c
@@ -0,0 +1,8 @@
+/* { dg-do run { target { riscv64*-*-* } } } */
+/* { dg-options "-fdump-tree-crc-details -march=rv64gc_zbc" } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-22.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c
new file mode 100644
index 00000000000..4aae6c99360
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-22-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-22.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c
new file mode 100644
index 00000000000..f433023d0dc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-23-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-23.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c
new file mode 100644
index 00000000000..cf0d6d0f262
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-4.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c
new file mode 100644
index 00000000000..970315aa4c3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-4-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-4.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c
new file mode 100644
index 00000000000..c9e3a719515
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-5.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c
new file mode 100644
index 00000000000..1cd7f0ede32
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-5-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-5.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c
new file mode 100644
index 00000000000..7d2d2dde105
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-6-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-6.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c
new file mode 100644
index 00000000000..00bf216ede5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-7-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-7.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c
new file mode 100644
index 00000000000..88a06d203e4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c b/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c
new file mode 100644
index 00000000000..a8f163f2d80
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-8-zbkb.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbkb" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbkb" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c
new file mode 100644
index 00000000000..b31cceb164f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-9-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-9.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c
new file mode 100644
index 00000000000..f4f1336a43d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data16-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-CCIT-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c
new file mode 100644
index 00000000000..8cc01a6c0d2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-CCIT-data8-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto" } } */
+
+#include "../../gcc.dg/crc-CCIT-data8.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-builtin-table-target32.c b/gcc/testsuite/gcc.target/riscv/crc-builtin-table-target32.c
new file mode 100644
index 00000000000..55305d39f26
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-builtin-table-target32.c
@@ -0,0 +1,37 @@
+/* { dg-do compile } */
+
+#include <stdint-gcc.h>
+
+int8_t crc8_data8 ()
+{
+  return __builtin_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t crc16_data8 ()
+{
+  return __builtin_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t crc16_data16 ()
+{
+  return __builtin_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t crc32_data8 ()
+{
+  return __builtin_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+
+int32_t crc32_data16 ()
+{
+  return __builtin_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t crc32_data32 ()
+{
+  return __builtin_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+}
+
+/* { dg-final { scan-assembler "crc_table_for_crc_8_polynomial_0x12" } } */
+/* { dg-final { scan-assembler "crc_table_for_crc_16_polynomial_0x1021"} } */
+/* { dg-final { scan-assembler "crc_table_for_crc_32_polynomial_0x4002123"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-builtin-table-target64.c b/gcc/testsuite/gcc.target/riscv/crc-builtin-table-target64.c
new file mode 100644
index 00000000000..5874431222c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-builtin-table-target64.c
@@ -0,0 +1,60 @@
+/* { dg-do compile { target lp64 } } */
+
+#include <stdint-gcc.h>
+
+int8_t crc8_data8 ()
+{
+  return __builtin_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t crc16_data8 ()
+{
+  return __builtin_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t crc16_data16 ()
+{
+  return __builtin_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t crc32_data8 ()
+{
+  return __builtin_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+
+int32_t crc32_data16 ()
+{
+  return __builtin_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t crc32_data32 ()
+{
+  return __builtin_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+}
+
+int64_t crc64_data8 ()
+{
+  return __builtin_crc64_data8 (0xffffffffffffffff, 0x32, 0x40021234002123);
+}
+
+int64_t crc64_data16 ()
+{
+  return __builtin_crc64_data16 (0xffffffffffffffff, 0x3232, 0x40021234002123);
+}
+
+int64_t crc64_data32 ()
+{
+  return __builtin_crc64_data32 (0xffffffffffffffff, 0x123546ff,
+				 0x40021234002123);
+}
+
+int64_t crc64_data64 ()
+{
+  return __builtin_crc64_data64 (0xffffffffffffffff, 0x123546ff123546ff,
+				 0x40021234002123);
+}
+
+/* { dg-final { scan-assembler "crc_table_for_crc_8_polynomial_0x12" } } */
+/* { dg-final { scan-assembler "crc_table_for_crc_16_polynomial_0x1021"} } */
+/* { dg-final { scan-assembler "crc_table_for_crc_32_polynomial_0x4002123"} } */
+/* { dg-final { scan-assembler "crc_table_for_crc_64_polynomial_0x40021234002123"} } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc32.c b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc32.c
new file mode 100644
index 00000000000..20d7d25f60e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc32.c
@@ -0,0 +1,21 @@
+/* { dg-do compile { target { riscv32*-*-* } } } */
+/* { dg-options "-march=rv32gc_zbc" } */
+
+#include <stdint-gcc.h>
+
+int8_t crc8_data8 ()
+{
+  return __builtin_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t crc16_data8 ()
+{
+  return __builtin_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t crc16_data16 ()
+{
+  return __builtin_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+/* { dg-final { scan-assembler-times "clmul\t" 6 } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc64.c b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc64.c
new file mode 100644
index 00000000000..c9509d56d01
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-builtin-zbc64.c
@@ -0,0 +1,66 @@
+/* { dg-do compile { target { riscv64*-*-* } } } */
+/* { dg-options "-march=rv64gc_zbc" } */
+
+#include <stdint-gcc.h>
+
+int8_t crc8_data8 ()
+{
+  return __builtin_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t crc16_data8 ()
+{
+  return __builtin_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t crc16_data16 ()
+{
+  return __builtin_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t crc32_data8 ()
+{
+  return __builtin_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+
+int32_t crc32_data16 ()
+{
+  return __builtin_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t crc32_data32 ()
+{
+  return __builtin_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+}
+
+int8_t rev_crc8_data8 ()
+{
+  return __builtin_rev_crc8_data8 (0x34, 'a', 0x12);
+}
+
+int16_t rev_crc16_data8 ()
+{
+  return __builtin_rev_crc16_data8 (0x1234, 'a', 0x1021);
+}
+
+int16_t rev_crc16_data16 ()
+{
+  return __builtin_rev_crc16_data16 (0x1234, 0x3214, 0x1021);
+}
+
+int32_t rev_crc32_data8 ()
+{
+  return __builtin_rev_crc32_data8 (0xffffffff, 0x32, 0x4002123);
+}
+
+int32_t rev_crc32_data16 ()
+{
+  return __builtin_rev_crc32_data16 (0xffffffff, 0x3232, 0x4002123);
+}
+
+int32_t rev_crc32_data32 ()
+{
+  return __builtin_rev_crc32_data32 (0xffffffff, 0x123546ff, 0x4002123);
+}
+/* { dg-final { scan-assembler-times "clmul\t" 18 } } */
+/* { dg-final { scan-assembler-times "clmulh" 6 } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c
new file mode 100644
index 00000000000..85e1fd2f312
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/crc-coremark-16bitdata-zbc.c
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-options "-w -fdump-tree-crc-details" } */
+/* { dg-additional-options "-march=rv64gc_zbc" { target { rv64 } } } */
+/* { dg-additional-options "-march=rv32gc_zbc" { target { rv32 } } } */
+/* { dg-skip-if "" { *-*-* } { "-flto"} } */
+
+#include "../../gcc.dg/crc-coremark16-data16.c"
+
+/* { dg-final { scan-tree-dump "calculates CRC!" "crc"} } */
+/* { dg-final { scan-tree-dump-times "Couldn't generate faster CRC code." 0 "crc"} } */
\ No newline at end of file
diff --git a/gcc/timevar.def b/gcc/timevar.def
index 8e2168e0817..80bcc215017 100644
--- a/gcc/timevar.def
+++ b/gcc/timevar.def
@@ -312,6 +312,7 @@ DEFTIMEVAR (TV_INITIALIZE_RTL        , "initialize rtl")
 DEFTIMEVAR (TV_GIMPLE_LADDRESS       , "address lowering")
 DEFTIMEVAR (TV_TREE_LOOP_IFCVT       , "tree loop if-conversion")
 DEFTIMEVAR (TV_WARN_ACCESS           , "access analysis")
+DEFTIMEVAR (TV_GIMPLE_CRC_OPTIMIZATION, "crc optimization")
 
 /* Everything else in rest_of_compilation not included above.  */
 DEFTIMEVAR (TV_EARLY_LOCAL	     , "early local passes")
diff --git a/gcc/tree-loop-distribution.cc b/gcc/tree-loop-distribution.cc
index 95203fefa18..45628cb0381 100644
--- a/gcc/tree-loop-distribution.cc
+++ b/gcc/tree-loop-distribution.cc
@@ -1275,83 +1275,6 @@ generate_memcpy_builtin (class loop *loop, partition *partition)
     }
 }
 
-/* Remove and destroy the loop LOOP.  */
-
-static void
-destroy_loop (class loop *loop)
-{
-  unsigned nbbs = loop->num_nodes;
-  edge exit = single_exit (loop);
-  basic_block src = loop_preheader_edge (loop)->src, dest = exit->dest;
-  basic_block *bbs;
-  unsigned i;
-
-  bbs = get_loop_body_in_dom_order (loop);
-
-  gimple_stmt_iterator dst_gsi = gsi_after_labels (exit->dest);
-  bool safe_p = single_pred_p (exit->dest);
-  for (unsigned i = 0; i < nbbs; ++i)
-    {
-      /* We have made sure to not leave any dangling uses of SSA
-         names defined in the loop.  With the exception of virtuals.
-	 Make sure we replace all uses of virtual defs that will remain
-	 outside of the loop with the bare symbol as delete_basic_block
-	 will release them.  */
-      for (gphi_iterator gsi = gsi_start_phis (bbs[i]); !gsi_end_p (gsi);
-	   gsi_next (&gsi))
-	{
-	  gphi *phi = gsi.phi ();
-	  if (virtual_operand_p (gimple_phi_result (phi)))
-	    mark_virtual_phi_result_for_renaming (phi);
-	}
-      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);)
-	{
-	  gimple *stmt = gsi_stmt (gsi);
-	  tree vdef = gimple_vdef (stmt);
-	  if (vdef && TREE_CODE (vdef) == SSA_NAME)
-	    mark_virtual_operand_for_renaming (vdef);
-	  /* Also move and eventually reset debug stmts.  We can leave
-	     constant values in place in case the stmt dominates the exit.
-	     ???  Non-constant values from the last iteration can be
-	     replaced with final values if we can compute them.  */
-	  if (gimple_debug_bind_p (stmt))
-	    {
-	      tree val = gimple_debug_bind_get_value (stmt);
-	      gsi_move_before (&gsi, &dst_gsi);
-	      if (val
-		  && (!safe_p
-		      || !is_gimple_min_invariant (val)
-		      || !dominated_by_p (CDI_DOMINATORS, exit->src, bbs[i])))
-		{
-		  gimple_debug_bind_reset_value (stmt);
-		  update_stmt (stmt);
-		}
-	    }
-	  else
-	    gsi_next (&gsi);
-	}
-    }
-
-  redirect_edge_pred (exit, src);
-  exit->flags &= ~(EDGE_TRUE_VALUE|EDGE_FALSE_VALUE);
-  exit->flags |= EDGE_FALLTHRU;
-  cancel_loop_tree (loop);
-  rescan_loop_exit (exit, false, true);
-
-  i = nbbs;
-  do
-    {
-      --i;
-      delete_basic_block (bbs[i]);
-    }
-  while (i != 0);
-
-  free (bbs);
-
-  set_immediate_dominator (CDI_DOMINATORS, dest,
-			   recompute_dominator (CDI_DOMINATORS, dest));
-}
-
 /* Generates code for PARTITION.  Return whether LOOP needs to be destroyed.  */
 
 static bool 
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index 29267589eeb..9b4adf96e44 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -387,6 +387,7 @@ extern gimple_opt_pass *make_pass_graphite_transforms (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_if_conversion (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_if_to_switch (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_loop_distribution (gcc::context *ctxt);
+extern gimple_opt_pass *make_pass_crc_optimization (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_vectorize (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_simduid_cleanup (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_slp_vectorize (gcc::context *ctxt);
diff --git a/gcc/tree-ssa-loop-manip.cc b/gcc/tree-ssa-loop-manip.cc
index 6cef1ae30c1..b63b93b6b80 100644
--- a/gcc/tree-ssa-loop-manip.cc
+++ b/gcc/tree-ssa-loop-manip.cc
@@ -1465,3 +1465,81 @@ canonicalize_loop_ivs (class loop *loop, tree *nit, bool bump_in_latch)
 
   return var_before;
 }
+
+/* Remove and destroy the loop LOOP.
+   Brought this function from th tree-loop-distribution.cc.  */
+
+void
+destroy_loop (class loop *loop)
+{
+  unsigned nbbs = loop->num_nodes;
+  edge exit = single_exit (loop);
+  basic_block src = loop_preheader_edge (loop)->src, dest = exit->dest;
+  basic_block *bbs;
+  unsigned i;
+
+  bbs = get_loop_body_in_dom_order (loop);
+
+  gimple_stmt_iterator dst_gsi = gsi_after_labels (exit->dest);
+  bool safe_p = single_pred_p (exit->dest);
+  for (unsigned i = 0; i < nbbs; ++i)
+    {
+      /* We have made sure to not leave any dangling uses of SSA
+	 names defined in the loop.  With the exception of virtuals.
+	 Make sure we replace all uses of virtual defs that will remain
+	 outside of the loop with the bare symbol as delete_basic_block
+	 will release them.  */
+      for (gphi_iterator gsi = gsi_start_phis (bbs[i]); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gphi *phi = gsi.phi ();
+	  if (virtual_operand_p (gimple_phi_result (phi)))
+	    mark_virtual_phi_result_for_renaming (phi);
+	}
+      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);)
+	{
+	  gimple *stmt = gsi_stmt (gsi);
+	  tree vdef = gimple_vdef (stmt);
+	  if (vdef && TREE_CODE (vdef) == SSA_NAME)
+	    mark_virtual_operand_for_renaming (vdef);
+	  /* Also move and eventually reset debug stmts.  We can leave
+	     constant values in place in case the stmt dominates the exit.
+	     ???  Non-constant values from the last iteration can be
+	     replaced with final values if we can compute them.  */
+	  if (gimple_debug_bind_p (stmt))
+	    {
+	      tree val = gimple_debug_bind_get_value (stmt);
+	      gsi_move_before (&gsi, &dst_gsi);
+	      if (val
+		  && (!safe_p
+		      || !is_gimple_min_invariant (val)
+		      || !dominated_by_p (CDI_DOMINATORS, exit->src, bbs[i])))
+		{
+		  gimple_debug_bind_reset_value (stmt);
+		  update_stmt (stmt);
+		}
+	    }
+	  else
+	    gsi_next (&gsi);
+	}
+    }
+
+  redirect_edge_pred (exit, src);
+  exit->flags &= ~(EDGE_TRUE_VALUE|EDGE_FALSE_VALUE);
+  exit->flags |= EDGE_FALLTHRU;
+  cancel_loop_tree (loop);
+  rescan_loop_exit (exit, false, true);
+
+  i = nbbs;
+  do
+    {
+      --i;
+      delete_basic_block (bbs[i]);
+    }
+  while (i != 0);
+
+  free (bbs);
+
+  set_immediate_dominator (CDI_DOMINATORS, dest,
+			   recompute_dominator (CDI_DOMINATORS, dest));
+}
\ No newline at end of file
diff --git a/gcc/tree-ssa-loop-manip.h b/gcc/tree-ssa-loop-manip.h
index bcedd5bc949..9612f2fc268 100644
--- a/gcc/tree-ssa-loop-manip.h
+++ b/gcc/tree-ssa-loop-manip.h
@@ -51,6 +51,7 @@ extern void tree_transform_and_unroll_loop (class loop *, unsigned,
 extern void tree_unroll_loop (class loop *, unsigned, tree_niter_desc *);
 extern tree canonicalize_loop_ivs (class loop *, tree *, bool);
 extern unsigned int loop_invariant_motion_in_fun (function *, bool);
+extern void destroy_loop (class loop *loop);
 
 
 #endif /* GCC_TREE_SSA_LOOP_MANIP_H */
