diff --git a/gcc/simplify-rtx.cc b/gcc/simplify-rtx.cc
index 86baeb06ad48..3aaabdc9b055 100644
--- a/gcc/simplify-rtx.cc
+++ b/gcc/simplify-rtx.cc
@@ -4193,6 +4193,13 @@ simplify_context::simplify_binary_operation_1 (rtx_code code,
 		 and no precision is lost.  */
 	      if (SUBREG_P (op0) && subreg_lowpart_p (op0)
 		  && GET_CODE (XEXP (op0, 0)) == LSHIFTRT
+		  /* simplify_subreg asserts the object being accessed is not
+		     VOIDmode or BLKmode.  We may have a REG_EQUAL note which
+		     is not simplified and the source operand is a constant,
+		     and thus VOIDmode.  Guard against that.  */
+		  && GET_MODE (XEXP (XEXP (op0, 0), 0)) != VOIDmode
+		  && GET_MODE (XEXP (XEXP (op0, 0), 0)) != BLKmode
+		  && !CONST_INT_P (XEXP (XEXP (op0, 0), 0))
 		  && CONST_INT_P (XEXP (XEXP (op0, 0), 1))
 		  && INTVAL (XEXP (XEXP (op0, 0), 1)) >= 0
 		  && INTVAL (XEXP (XEXP (op0, 0), 1)) < HOST_BITS_PER_WIDE_INT
diff --git a/gcc/testsuite/gcc.dg/torture/pr122735.c b/gcc/testsuite/gcc.dg/torture/pr122735.c
new file mode 100644
index 000000000000..9499ce4607b0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr122735.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+int a;
+void b() {
+  int c;
+  unsigned d = c + 19;
+  a = d >> 32 + 19 + d + 255 - 293;
+}
